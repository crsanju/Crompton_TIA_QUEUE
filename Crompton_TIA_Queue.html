<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TMR Macro TIA+Queue Analysis</title>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --bg: #f6f3ef;
      --ink: #1c1c1c;
      --muted: #5f5f5f;
      --card: #ffffff;
      --line: #e1ded8;
      --brand: #1f5e63;
      --brand-2: #0f2f32;
      --shadow: 0 12px 30px rgba(0, 0, 0, 0.08);
    }

    * { box-sizing: border-box; }

    body {
      font-family: "Space Grotesk", "Trebuchet MS", "Lucida Sans Unicode", "Lucida Grande", "Lucida Sans", sans-serif;
      background: radial-gradient(1200px 600px at 10% -10%, #e8f0ef 0%, transparent 55%),
                  radial-gradient(1200px 600px at 100% -10%, #f3e7dc 0%, transparent 50%),
                  var(--bg);
      margin: 0;
      padding: 24px;
      color: var(--ink);
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 24px;
      box-shadow: var(--shadow);
    }

    .navbar {
      display: flex;
      align-items: center;
      margin-bottom: 20px;
      gap: 10px;
    }

    .home-button {
      background-color: var(--brand);
      color: white;
      padding: 10px 18px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 700;
      font-size: 15px;
      transition: 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      width: auto;
      text-decoration: none;
    }

    .home-button:hover { background-color: #174a4e; }
    .home-button::before { content: 'üè†'; }

    h1 {
      text-align: center;
      margin: 10px 0 8px;
      color: var(--brand-2);
      letter-spacing: 0.5px;
    }

    .subtitle {
      text-align: center;
      margin: 8px 0 16px;
      color: var(--muted);
      font-size: 0.96rem;
    }

    h2 {
      margin: 0 0 12px;
      color: var(--brand-2);
      font-size: 1.05rem;
      border-bottom: 2px solid var(--brand);
      padding-bottom: 8px;
    }

    .grid { display:grid; grid-template-columns:repeat(4, minmax(180px,1fr)); gap:12px; }
    .grid-2 { display:grid; grid-template-columns:repeat(2, minmax(180px,1fr)); gap:12px; }

    .card {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 16px;
      margin-top: 14px;
      background: var(--card);
    }

    label {
      display: block;
      font-size: 12px;
      font-weight: 700;
      margin-bottom: 6px;
      color: var(--muted);
    }

    .grid > div,
    .grid-2 > div {
      background: #fbfbfa;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px;
    }

    input, select {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #cfd6ce;
      border-radius: 8px;
      background: #fff;
      font-family: inherit;
      font-size: 0.95rem;
      transition: all 0.2s ease;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.02);
    }

    input:focus, select:focus {
      outline: none;
      border-color: var(--brand);
      box-shadow: 0 0 0 3px rgba(31, 94, 99, 0.15);
    }

    input[readonly], select[readonly] {
      background-color: #f8f9fa !important;
      border-color: #e9ecef !important;
      color: #6c757d !important;
      cursor: not-allowed;
    }

    select {
      appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 10px center;
      background-size: 1em;
      padding-right: 32px;
    }
+
+    @media print {
+      .copyright-footer { display: none !important; }
+    }

    .tooltip {
      position: relative;
      cursor: help;
      border-bottom: 1px dotted #999;
    }

    .tooltip::after {
      content: attr(data-tip);
      position: absolute;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--ink);
      color: #fff;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 11px;
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: 0.2s;
      font-weight: normal;
      z-index: 10;
    }

    .tooltip:hover::after {
      opacity: 1;
      visibility: visible;
    }

    button {
      width: 100%;
      margin-top: 14px;
      padding: 11px;
      border: none;
      border-radius: 8px;
      background: var(--brand);
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      font-size: 0.98rem;
    }

    button:hover { background: #174a4e; }

    .kpi-grid {
      display: grid;
      grid-template-columns: repeat(6, minmax(140px, 1fr));
      gap: 10px;
      margin-top: 8px;
    }

    .kpi {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px;
      background: #faf9f7;
    }

    .kpi-label {
      font-size: 0.75rem;
      color: var(--muted);
      font-weight: 700;
      margin-bottom: 4px;
      text-transform: uppercase;
      letter-spacing: 0.4px;
    }

    .kpi-value {
      font-size: 1.05rem;
      font-weight: 700;
      color: var(--brand-2);
    }

    .table-wrap {
      overflow-x: auto;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #fff;
    }

    .table-actions {
      display: flex;
      justify-content: flex-end;
      margin: 8px 0;
    }

    .copy-table-btn {
      width: auto;
      margin: 0;
      padding: 7px 12px;
      font-size: 0.84rem;
      border-radius: 7px;
      background: var(--brand);
      color: #fff;
      border: none;
      cursor: pointer;
      font-weight: 700;
    }

    .copy-table-btn:hover { background: #174a4e; }

    table { width:100%; border-collapse:collapse; font-size:13px; }
    th, td { border:1px solid #dbe2ea; padding:8px; text-align:center; }
    th { background: var(--brand); color:#fff; position: sticky; top: 0; z-index: 1; }
    .rowhead { text-align:left; font-weight:700; background:#f4f3f0; }
    .status-yes { background:#d1fae5; }
    .status-no { background:#fee2e2; }
    .hidden { display:none; }

    .table-note {
      margin: 8px 0 0;
      color: var(--muted);
      font-size: 0.82rem;
    }

    #macroMap {
      height: 320px;
      width: 100%;
      border: 2px solid #0056b3;
      border-radius: 8px;
      margin-top: 10px;
    }

    @media (max-width: 1180px) {
      .grid, .kpi-grid { grid-template-columns: repeat(2, minmax(150px, 1fr)); }
    }

    @media (max-width: 760px) {
      body { padding: 12px; }
      .container { padding: 14px; }
      .grid, .grid-2, .kpi-grid { grid-template-columns: 1fr; }
        .assumptions-grid { grid-template-columns: 1fr; }
      table { font-size: 12px; }
    }

    /* Print Styles */
    @media print {
      body { background: white; padding: 0; }
      .container { box-shadow: none; border: none; }
      .navbar, .home-button, button, .copy-table-btn { display: none !important; }
      #quickSearchCard, #formulaTraceSection { display: none !important; }
        .leaflet-control-container { display: none !important; }
      .card { page-break-inside: avoid; }
        #macroMap { height: 280px !important; border: 1px solid #9aa4ab; margin-top: 8px; page-break-inside: avoid; }
      h1 { font-size: 24pt; color: #000; }
      h2 { font-size: 16pt; page-break-after: avoid; }
      h3 { font-size: 12pt; page-break-after: avoid; }
      table { font-size: 9pt; }
      th { background: #333 !important; color: white !important; }
      .print-header { display: block !important; text-align: center; margin-bottom: 20px; }
      .print-header h2 { margin: 0; }
      .print-header p { margin: 5px 0; font-size: 10pt; color: #666; }
      details { display: block !important; }
      details summary { display: none !important; }
      details > * { display: block !important; }
    }

    .print-header { display: none; }
    
    .print-btn {
      background: #4caf50;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9em;
      margin-left: 10px;
      transition: background 0.2s;
    }
    
    .print-btn:hover {
      background: #45a049;
    }

    .report-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 14px;
    }

    .report-actions .print-btn {
      margin-left: 0;
    }

    .source-pill {
      display: inline-block;
      padding: 2px 10px;
      border-radius: 999px;
      font-size: 0.82em;
      font-weight: 700;
      border: 1px solid transparent;
    }

    .source-tmr {
      background: #e3f2fd;
      color: #1565c0;
      border-color: #90caf9;
    }

    .source-gold-coast {
      background: #fff3e0;
      color: #ef6c00;
      border-color: #ffcc80;
    }

    .source-ipswich {
      background: #f3e5f5;
      color: #7b1fa2;
      border-color: #ce93d8;
    }

    .source-logan {
      background: #e8f5e9;
      color: #2e7d32;
      border-color: #a5d6a7;
    }
      .quality-pill {
        display: inline-block;
        padding: 2px 10px;
        border-radius: 999px;
        font-size: 0.82em;
        font-weight: 700;
        border: 1px solid transparent;
      }
      .quality-measured { background: #e8f5e9; color: #1b5e20; border-color: #81c784; }
      .quality-derived { background: #fff8e1; color: #ef6c00; border-color: #ffcc80; }
      .quality-estimated { background: #ffebee; color: #c62828; border-color: #ef9a9a; }
      .assumptions-grid {
        display: grid;
        grid-template-columns: repeat(3, minmax(200px, 1fr));
        gap: 10px;
      }
      .assumption-item {
        background: #f7fbfc;
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 8px 10px;
      }
      .assumption-key {
        font-size: 0.74rem;
        color: var(--muted);
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.35px;
        margin-bottom: 2px;
      }
      .assumption-value {
        font-size: 0.9rem;
        color: var(--brand-2);
        font-weight: 700;
      }
  </style>
</head>
<body>
  <div class="container">
    <div class="print-header">
      <h2>TMR Macro TIA+Queue Analysis Report</h2>
      <p>Generated: <span id="printDate"></span></p>
      <p>Crompton Traffic Analysis System</p>
    </div>
    
    <div class="navbar">
      <a class="home-button" href="#" onclick="window.location.reload(); return false;">Home</a>
      <span style="margin-left:auto; font-size:0.9em; color:#666;">
        <strong>Sites Loaded:</strong> <span id="sitesLoadedCount">0</span>
      </span>
    </div>
    <h1>TMR Macro TIA+Queue Analysis</h1>
    <p class="subtitle">TMR database-integrated directional traffic, queue metrics, and capacity checks with automated parameters.</p>

    <!-- ===== QUICK TIA ADDRESS SEARCH (TOP) ===== -->
    <div class="card" id="quickSearchCard" style="background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); border: 2px solid #1976d2;">
      <h2 style="color: #1565c0; margin-top: 0;">üöó Search Address</h2>
      <p style="color: #0d47a1; margin: 0 0 12px 0; font-size: 0.95em;">
       
      <div style="display: grid; grid-template-columns: 1fr 180px; gap: 12px; margin-bottom: 12px;">
        <div>
          <input type="text" id="quickTiaInput" placeholder="eg. Brisbane Road, Bellbird Park, Rockhampton" 
                 style="width: 100%; border: 2px solid #1976d2; padding: 10px; border-radius: 4px; font-size: 1em;" />
        </div>
        <button onclick="performQuickTIASearch()" style="background: #1976d2; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 0.95em;">
          üîç Search
        </button>
      </div>
      
      <div id="quickTiaPanel" style="display: none; background: white; border: 1px solid #1976d2; border-radius: 6px; padding: 12px; margin-bottom: 12px;">
        <h3 style="margin: 0 0 10px 0; color: #1565c0; border-bottom: 2px solid #1976d2; padding-bottom: 8px;">üìç Analysis Results</h3>
        
        <div id="quickTiaMatchInfo" style="background: #e3f2fd; border-left: 4px solid #1976d2; padding: 10px; margin-bottom: 10px; border-radius: 3px;">
          <strong style="color: #1565c0;">Match Type:</strong> <span id="quickTiaMatchType">-</span><br>
          <strong style="color: #1565c0;">Search Address:</strong> <span id="quickTiaSearchAddress">-</span><br>
          <strong style="color: #1565c0;">Geo Source:</strong> <span id="quickTiaGeoSource">-</span><br>
          <strong style="color: #1565c0;">Road/Location:</strong> <span id="quickTiaMatchRoad">-</span>
        </div>

        <!-- For Exact Match -->
        <div id="quickTiaExactMatch" style="display: none;">
          <div style="background: #e8f5e9; border: 1px solid #4caf50; border-radius: 6px; padding: 10px; margin-bottom: 10px;">
            <h4 style="margin: 0 0 8px 0; color: #2e7d32;">‚úì Exact Data Found</h4>
            <div style="font-size: 0.9em; line-height: 1.6;">
              <div><strong>VADT:</strong> <span id="quickTiaExactVADT">-</span> vehicles/day</div>
              <div><strong>D1 VADT:</strong> <span id="quickTiaExactD1">-</span></div>
              <div><strong>D2 VADT:</strong> <span id="quickTiaExactD2">-</span></div>
            </div>
          </div>
          <button onclick="useExactTIAData()" style="background: #4caf50; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; font-weight: bold;">
            ‚úì Use This Data
          </button>
        </div>

        <!-- For Multiple References -->
        <div id="quickTiaMultipleRefs" style="display: none;">
          <h4 style="margin: 0 0 10px 0; color: #d32f2f;">‚äô Using 3+ Reference Points (within 3km)</h4>
          <div id="quickTiaRefList" style="background: white; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 10px; display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 8px;"></div>
          <p style="font-size: 0.82em; color: #4e342e; margin: 0 0 10px 0; background: #fff3e0; border: 1px solid #ffcc80; border-radius: 6px; padding: 8px;">
            Each reference has its own route possibility slider (0‚Äì100%). Final traffic volume is a weighted average (not a sum).
          </p>

          <div id="quickTiaCalcResult" style="background: #e8f5e9; border: 1px solid #4caf50; border-radius: 6px; padding: 10px; margin-bottom: 10px;">
            <h5 style="margin: 0 0 8px 0; color: #2e7d32;">Calculated AADT (Weighted Average of References)</h5>
            <div style="font-size: 0.9em; line-height: 1.6;">
              <div><strong>Weighted Avg VADT:</strong> <span id="quickTiaCalcAvgVADT">-</span> vehicles/day</div>
              <div><strong>AADT to use:</strong> <span id="quickTiaCalcAdjVADT">-</span> vehicles/day</div>
              <div><strong>Calculated D1 VADT:</strong> <span id="quickTiaCalcD1">-</span></div>
              <div><strong>Calculated D2 VADT:</strong> <span id="quickTiaCalcD2">-</span></div>
            </div>
          </div>

          <button onclick="useCalculatedTIAData()" style="background: #1976d2; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; font-weight: bold;">
            ‚úì Use Calculated Data
          </button>
        </div>
      </div>

      <div id="quickTiaError" style="display: none; background: #ffebee; border: 1px solid #ef5350; border-radius: 6px; padding: 10px; color: #c30000;">
        <strong>‚ùå No matches found</strong><br>
        <span style="font-size: 0.9em;">Try searching by different road name or manually select from database below.</span>
      </div>
    </div>

    <!-- Site Selection Card -->
    <div class="card">
      <h2>1. Select Site or Manual Entry</h2>
      <div class="grid-2" style="margin-bottom: 12px; grid-template-columns: 1fr;">
        <div style="background: #e8f5e9; border: 2px solid #4caf50; border-radius: 8px; padding: 10px;">
          <label style="color: #2e7d32;">Search & Select from Database</label>
          <div style="margin-bottom: 8px;">
            <label for="macroSourceFilter" style="color: #2e7d32; font-size: 0.8em; margin-bottom: 4px;">Data Source</label>
            <select id="macroSourceFilter" style="border: 2px solid #4caf50; background-color: #f0fdf4;">
              <option value="ALL" selected>All Sources (TMR + Gold Coast + Ipswich + Logan + Toowoomba)</option>
              <option value="TMR">TMR Only</option>
              <option value="Gold Coast">Gold Coast Only</option>
              <option value="Ipswich">Ipswich Only</option>
              <option value="Logan">Logan Only</option>
              <option value="Toowoomba">Toowoomba Only</option>
            </select>
          </div>
          <input type="text" id="macroSiteSearch" list="macroSitesList" placeholder="Type Site ID or Name to autofill..." style="border: 2px solid #4caf50; background-color: #f0fdf4;" />
          <datalist id="macroSitesList"></datalist>
          <p style="font-size: 0.75em; color: #666; margin-top: 6px;">Or manually enter VADT & parameters below</p>
        </div>
      </div>

      <div id="macroSiteDetailsPanel" style="display:none; background:#e8f5e9; border:1px solid #81c784; border-radius:6px; padding:12px; margin-bottom:12px;">
        <h3 style="margin:0 0 8px 0; color:#2e7d32;">üìç Selected Site Details</h3>
        <div style="display:grid; grid-template-columns:160px 1fr; gap:6px; font-size:0.9em;">
          <div style="font-weight:700;">Site ID:</div><div id="macroDetailSiteId">-</div>
          <div style="font-weight:700;">Source:</div><div id="macroDetailSource">-</div>
          <div style="font-weight:700;">Road Name:</div><div id="macroDetailRoadName">-</div>
          <div style="font-weight:700;">Description:</div><div id="macroDetailDescription">-</div>
          <div style="font-weight:700;">Coordinates:</div><div id="macroDetailCoords">-</div>
          <div style="font-weight:700;">Google Maps:</div><div>üìç <a id="macroMapLink" href="javascript:void(0)" target="_blank" style="color:#0056b3; text-decoration:none;">View on Google Maps</a></div>
          <div style="font-weight:700;">Count Year:</div><div id="macroDetailCountYear">-</div>
          <div style="font-weight:700;">Growth Rate:</div><div id="macroDetailGrowthRate">-</div>
          <div style="font-weight:700;">HV%:</div><div id="macroDetailHV">-</div>
          <div style="font-weight:700;">Data Quality:</div><div id="macroDetailQuality">-</div>
          <div style="font-weight:700;">D1 VADT:</div><div id="macroDetailD1">-</div>
          <div style="font-weight:700;">D2 VADT:</div><div id="macroDetailD2">-</div>
          <div style="font-weight:700;">Total VADT:</div><div id="macroDetailTotal">-</div>
        </div>
      </div>

      <div style="margin-top: 10px;">
        <h3 style="margin: 0 0 6px 0; color: #1f5e63; font-size: 1rem;">Site Location </h3>
        <p style="font-size: 0.85em; color:#555; margin: 0 0 8px 0;">Select a site from search or click a marker to auto-fill inputs.</p>
        <div id="macroMap"></div>
        <div style="background:#e3f2fd; border:1px solid #64b5f6; border-radius:6px; padding:8px; margin-top:8px;">
          <p style="margin:0; font-size:0.85em; color:#1565c0;">
            <strong>Map Status:</strong> <span id="macroMapInfo">Waiting for site data...</span>
          </p>
        </div>
      </div>
    </div>

    <!-- Database Data Visualization (Collapsed by Default) -->
    <details class="card" id="macroDataVizSection" style="display:none;">
      <summary style="cursor: pointer; font-size: 1.1em; font-weight: 700; color: #1f5e63; padding: 10px 0;">
        üìä Data Loaded from Database (Click to Expand)
      </summary>
      <div style="margin-top: 15px;">
        <h3 style="color: #1f5e63; margin: 0 0 10px 0;">Hourly Traffic Profile</h3>
        <canvas id="macroHourlyChart" style="max-height: 350px;"></canvas>
        
        <h3 style="color: #1f5e63; margin: 20px 0 10px 0;">Directional Distribution</h3>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
          <div>
            <h4 style="text-align: center; color: #2e7d32; margin: 0 0 10px 0;">Gazettal</h4>
            <canvas id="macroD1PieChart" style="max-height: 250px;"></canvas>
          </div>
          <div>
            <h4 style="text-align: center; color: #c30000; margin: 0 0 10px 0;">Against Gazettal</h4>
            <canvas id="macroD2PieChart" style="max-height: 250px;"></canvas>
          </div>
        </div>
        
        <h3 style="color: #1f5e63; margin: 20px 0 10px 0;">Peak Hour Analysis</h3>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
          <div style="background: #e8f5e9; border: 1px solid #4caf50; border-radius: 8px; padding: 12px;">
            <h4 style="color: #2e7d32; margin: 0 0 8px 0;">Gazettal Peak Hours</h4>
            <div id="macroD1PeakHours" style="font-size: 0.9em;"></div>
          </div>
          <div style="background: #ffebee; border: 1px solid #ef5350; border-radius: 8px; padding: 12px;">
            <h4 style="color: #c30000; margin: 0 0 8px 0;">Against Gazettal Peak Hours</h4>
            <div id="macroD2PeakHours" style="font-size: 0.9em;"></div>
          </div>
        </div>
      </div>
    </details>

    <div class="card">
      <h2 style="display: flex; justify-content: space-between; align-items: center;">
        Analysis Parameters
        <span style="font-size: 0.75em; font-weight: normal;">
          <span style="color:#f44336;">üî¥ User Input</span> | <span style="color:#4caf50;">üü¢ Auto-calculated</span>
        </span>
      </h2>

      <!-- AUTO-FILLED TAB -->
      <fieldset style="border: 2px solid #4caf50; padding: 15px; border-radius: 8px; margin-bottom: 15px; background: #f0fdf4;">
        <legend style="padding: 0 12px; font-weight: bold; color: #2e7d32; font-size: 1.1em;">‚úì Auto-filled from Database</legend>
        <div class="grid-2">
          <div style="background: #e8f5e9; border: 1px solid #81c784; border-radius: 6px; padding: 10px;">
            <label style="color: #2e7d32; font-weight: bold;">Site ID</label>
            <input id="macroSiteId" type="text" readonly style="border: 1px solid #81c784; background-color: #f1f8f6; color: #1b5e20;" />
          </div>
          <div style="background: #e8f5e9; border: 1px solid #81c784; border-radius: 6px; padding: 10px;">
            <label style="color: #2e7d32; font-weight: bold;">Base Year</label>
            <input id="baseYear" type="number" readonly style="border: 1px solid #81c784; background-color: #f1f8f6; color: #1b5e20;" />
          </div>
          <div style="background: #e8f5e9; border: 1px solid #81c784; border-radius: 6px; padding: 10px;">
            <label style="color: #2e7d32; font-weight: bold;">HV % (from DB)</label>
            <input id="baseHVPercent" type="number" readonly style="border: 1px solid #81c784; background-color: #f1f8f6; color: #1b5e20;" />
          </div>
          <div style="background: #e8f5e9; border: 1px solid #81c784; border-radius: 6px; padding: 10px;">
            <label style="color: #2e7d32; font-weight: bold;">D1 VADT (from DB)</label>
            <input id="D1_VADT" type="number" readonly style="border: 1px solid #81c784; background-color: #f1f8f6; color: #1b5e20;" />
          </div>
          <div style="background: #e8f5e9; border: 1px solid #81c784; border-radius: 6px; padding: 10px;">
            <label style="color: #2e7d32; font-weight: bold;">D2 VADT (from DB)</label>
            <input id="D2_VADT" type="number" readonly style="border: 1px solid #81c784; background-color: #f1f8f6; color: #1b5e20;" />
          </div>
          <div style="background: #e8f5e9; border: 1px solid #81c784; border-radius: 6px; padding: 10px;">
            <label style="color: #2e7d32; font-weight: bold;">VADT (Auto-calc)</label>
            <input id="VADT" type="number" readonly style="border: 1px solid #81c784; background-color: #f1f8f6; color: #1b5e20;" />
          </div>
          <div style="background: #e8f5e9; border: 1px solid #81c784; border-radius: 6px; padding: 10px;">
            <label style="color: #2e7d32; font-weight: bold;" class="tooltip" data-tip="Directional Traffic Characterisation Algorithm">DTCA (Auto-detect)</label>
            <select id="DTCA" readonly style="border: 1px solid #81c784; background-color: #f1f8f6; color: #1b5e20; pointer-events: none;"><option>Yes</option><option>No</option></select>
          </div>
          <div style="background: #e8f5e9; border: 1px solid #81c784; border-radius: 6px; padding: 10px;">
            <label style="color: #2e7d32; font-weight: bold;">Target Year (Auto-filled, editable)</label>
            <input id="macroOpeningYear" type="number" value="" min="2024" step="1" style="border: 1px solid #81c784; background-color: #f1f8f6; color: #1b5e20;" />
          </div>
        </div>
      </fieldset>

      <!-- USER INPUT TAB -->
      <fieldset style="border: 2px solid #f44336; padding: 15px; border-radius: 8px; background: #fff8f8;">
        <legend style="padding: 0 12px; font-weight: bold; color: #c30000; font-size: 1.1em;">‚úé You Must Fill These</legend>
        
        <div class="grid" style="margin-bottom: 12px;">
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;">Growth Rate (% p.a.) *</label>
            <p style="font-size: 0.8em; color: #666; margin: 0 0 4px 0;">(auto-filled if in DB)</p>
            <input id="macroGrowthRate" type="number" value="2.5" step="0.1" style="border: 1px solid #ffc107; background-color: #fffbf0;" />
          </div>
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;">Terrain *</label>
            <select id="macroTerrainType" style="border: 1px solid #ffc107; background-color: #fffbf0;">
              <option value="flat">Flat</option>
              <option value="rolling">Rolling</option>
              <option value="mountainous">Mountainous</option>
            </select>
          </div>
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;">Road Trains (RTR)? *</label>
            <select id="RTR" style="border: 1px solid #ffc107; background-color: #fffbf0;"><option>No</option><option>Yes</option></select>
          </div>
        </div>

        <div class="grid" style="margin-bottom: 12px; border-top: 1px solid #ddd; padding-top: 12px;">
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;">D1 Lanes *</label>
            <p style="font-size: 0.8em; color: #666; margin: 0 0 4px 0;">(auto-filled if in DB)</p>
            <input id="D1_Lanes" type="number" value="1" min="1" style="border: 1px solid #ffc107; background-color: #fffbf0;" />
          </div>
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;">D2 Lanes *</label>
            <p style="font-size: 0.8em; color: #666; margin: 0 0 4px 0;">(auto-filled if in DB)</p>
            <input id="D2_Lanes" type="number" value="1" min="1" style="border: 1px solid #ffc107; background-color: #fffbf0;" />
          </div>
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;">HV (%) *</label>
            <p style="font-size: 0.8em; color: #666; margin: 0 0 4px 0;">(auto-filled if in DB)</p>
            <input id="HVP" type="number" value="5" step="0.1" style="border: 1px solid #ffc107; background-color: #fffbf0;" />
          </div>
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;" class="tooltip" data-tip="Directional Heavy Vehicle Percentage Allocation">DHVPA *</label>
            <select id="DHVPA" style="border: 1px solid #ffc107; background-color: #fffbf0;"><option>Yes</option><option selected>No</option></select>
          </div>
        </div>

        <div class="grid" style="margin-bottom: 12px; border-top: 1px solid #ddd; padding-top: 12px;">
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;">D1 HV% *</label>
            <input id="D1_HVP" type="number" value="5" step="0.1" style="border: 1px solid #ffc107; background-color: #fffbf0;" />
          </div>
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;">D2 HV% *</label>
            <input id="D2_HVP" type="number" value="5" step="0.1" style="border: 1px solid #ffc107; background-color: #fffbf0;" />
          </div>
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;">RTP (%) *</label>
            <input id="RTP" type="number" value="0" step="0.1" style="border: 1px solid #ffc107; background-color: #fffbf0;" />
          </div>
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;" class="tooltip" data-tip="Directional Road Train Percentage Allocation">DRTPA *</label>
            <select id="DRTPA" style="border: 1px solid #ffc107; background-color: #fffbf0;"><option>Yes</option><option selected>No</option></select>
          </div>
        </div>

        <div class="grid" style="border-top: 1px solid #ddd; padding-top: 12px;">
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;">D1 RT% *</label>
            <input id="D1_RTP" type="number" value="0" step="0.1" style="border: 1px solid #ffc107; background-color: #fffbf0;" />
          </div>
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;">D2 RT% *</label>
            <input id="D2_RTP" type="number" value="0" step="0.1" style="border: 1px solid #ffc107; background-color: #fffbf0;" />
          </div>
        </div>
      </fieldset>

      <div style="position: sticky; bottom: 20px; z-index: 100; margin-top: 20px;">
        <button id="calcBtn" style="padding: 16px; font-size: 1.1em; font-weight: bold; background: var(--brand); color: white; border: none; border-radius: 12px; cursor: pointer; width: 100%; box-shadow: 0 8px 20px rgba(31, 94, 99, 0.3); transition: transform 0.1s, box-shadow 0.1s;">
          üöÄ Calculate All Metrics
        </button>
      </div>
    </div>

    <div class="card" id="assumptionsCard">
      <h2>Analysis Assumptions</h2>
      <div class="assumptions-grid">
        <div class="assumption-item"><div class="assumption-key">DTCA Path</div><div class="assumption-value" id="assumptionDtca">-</div></div>
        <div class="assumption-item"><div class="assumption-key">HV Source</div><div class="assumption-value" id="assumptionHvSource">-</div></div>
        <div class="assumption-item"><div class="assumption-key">RT Source</div><div class="assumption-value" id="assumptionRtSource">-</div></div>
        <div class="assumption-item"><div class="assumption-key">Growth Source</div><div class="assumption-value" id="assumptionGrowthSource">-</div></div>
        <div class="assumption-item"><div class="assumption-key">Lane Source</div><div class="assumption-value" id="assumptionLaneSource">-</div></div>
        <div class="assumption-item"><div class="assumption-key">Profile Source</div><div class="assumption-value" id="assumptionProfileSource">-</div></div>
      </div>
    </div>

    <details class="card">
      <summary style="font-weight:700; color:#1f5e63; cursor:pointer;">Quick KPI (Optional)</summary>
      <div class="kpi-grid" style="margin-top:12px;">
        <div class="kpi"><div class="kpi-label">Design Volume (DV)</div><div class="kpi-value" id="kpiDV">-</div></div>
        <div class="kpi"><div class="kpi-label">D1 Peak Queue (2m)</div><div class="kpi-value" id="kpiD1PeakQueue">-</div></div>
        <div class="kpi"><div class="kpi-label">D2 Peak Queue (2m)</div><div class="kpi-value" id="kpiD2PeakQueue">-</div></div>
        <div class="kpi"><div class="kpi-label">Worst V/C Ratio</div><div class="kpi-value" id="kpiWorstVcr">-</div></div>
        <div class="kpi"><div class="kpi-label">SLRF Peak</div><div class="kpi-value" id="kpiSlrfPeak">-</div></div>
        <div class="kpi"><div class="kpi-label">Road Train Rule</div><div class="kpi-value" id="kpiRoadTrain">-</div></div>
      </div>
    </details>

    <div class="card">
      <h2>Grouped Directional Summary</h2>
      
      <h3 id="groupedHeaderD2" style="margin: 12px 0 8px 0; color: #c30000; font-size: 1.05em;">üî¥ Against Gazettal (D2)</h3>
      <div class="table-wrap">
        <table id="groupedTableD2">
          <thead>
            <tr>
              <th>Metric</th>
              <th>AM</th>
              <th>OP</th>
              <th>PM</th>
              <th>EV</th>
              <th>Daily Total</th>
            </tr>
          </thead>
          <tbody id="groupedBodyD2"></tbody>
        </table>
      </div>

      <h3 id="groupedHeaderD1" style="margin: 20px 0 8px 0; color: #2e7d32; font-size: 1.05em;">üü¢ Gazettal (D1)</h3>
      <div class="table-wrap">
        <table id="groupedTableD1">
          <thead>
            <tr>
              <th>Metric</th>
              <th>AM</th>
              <th>OP</th>
              <th>PM</th>
              <th>EV</th>
              <th>Daily Total</th>
            </tr>
          </thead>
          <tbody id="groupedBodyD1"></tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h2>Queue Length Estimation</h2>
      
      <h3 id="queueHeaderD2" style="margin: 12px 0 8px 0; color: #c30000; font-size: 1.05em;">üî¥ Against Gazettal (D2)</h3>
      <div class="table-wrap">
        <table id="queueGroupedTableD2">
          <thead>
            <tr>
              <th>Queue Duration</th>
              <th>AM</th>
              <th>OP</th>
              <th>PM</th>
              <th>EV</th>
              <th>Max Queue</th>
            </tr>
          </thead>
          <tbody id="queueGroupedBodyD2"></tbody>
        </table>
      </div>

      <h3 id="queueHeaderD1" style="margin: 20px 0 8px 0; color: #2e7d32; font-size: 1.05em;">üü¢ Gazettal (D1)</h3>
      <div class="table-wrap">
        <table id="queueGroupedTableD1">
          <thead>
            <tr>
              <th>Queue Duration</th>
              <th>AM</th>
              <th>OP</th>
              <th>PM</th>
              <th>EV</th>
              <th>Max Queue</th>
            </tr>
          </thead>
          <tbody id="queueGroupedBodyD1"></tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h2>VCR / LOS Analysis</h2>

      <div id="vcrTableView">
      
      <h3 id="vcrHeaderD2" style="margin: 12px 0 8px 0; color: #c30000; font-size: 1.05em;">üî¥ Against Gazettal (D2)</h3>
      <div class="table-wrap" style="width:100%;">
        <table id="vcrGroupedTableD2">
          <thead>
            <tr><th>Metric</th><th>AM</th><th>OP</th><th>PM</th><th>EV</th></tr>
          </thead>
          <tbody id="vcrGroupedBodyD2"></tbody>
        </table>
      </div>

      <h3 id="vcrHeaderD1" style="margin: 20px 0 8px 0; color: #2e7d32; font-size: 1.05em;">üü¢ Gazettal (D1)</h3>
      <div class="table-wrap" style="width:100%;">
        <table id="vcrGroupedTableD1">
          <thead>
            <tr><th>Metric</th><th>AM</th><th>OP</th><th>PM</th><th>EV</th></tr>
          </thead>
          <tbody id="vcrGroupedBodyD1"></tbody>
        </table>
      </div>
      </div>

      <div id="vcrChartView" style="display: none;">
        <h3 id="vcrHeaderD2Chart" style="margin: 12px 0 8px 0; color: #c30000; font-size: 1.05em;">üî¥ Against Gazettal (D2)</h3>
        <div style="background: #fafafa; border: 1px solid #e0e0e0; border-radius: 6px; padding: 8px; margin-bottom: 10px;">
          <canvas id="vcrChartD2" style="max-height: 280px; width: 100%;"></canvas>
        </div>

        <h3 id="vcrHeaderD1Chart" style="margin: 20px 0 8px 0; color: #2e7d32; font-size: 1.05em;">üü¢ Gazettal (D1)</h3>
        <div style="background: #fafafa; border: 1px solid #e0e0e0; border-radius: 6px; padding: 8px; margin-bottom: 10px;">
          <canvas id="vcrChartD1" style="max-height: 280px; width: 100%;"></canvas>
        </div>
      </div>
      <p class="table-note">* Design Volume is greater of 30th highest hour of AADT or 500.</p>
    </div>

    <details class="card" id="formulaTraceSection">
      <summary style="cursor: pointer; font-size: 1.2em; font-weight: 700; color: #1f5e63; margin-bottom: 10px;">Formula Trace (Click to Expand)</summary>
      <div class="table-wrap">
        <table id="traceTable">
          <thead>
            <tr><th>Trace Item</th><th>Applied Value / Rule</th></tr>
          </thead>
          <tbody id="traceBody"></tbody>
        </table>
      </div>
    </details>

    <div class="report-actions">
      <button class="print-btn" onclick="printReport()">üñ®Ô∏è Print Report</button>
    </div>
  </div>

  <div class="copyright-footer" style="text-align: center; color: #7a7a7a; font-size: 0.85em; padding: 14px 0 18px 0;">Copyright@SANJU BHANDARI 2026</div>

<script>
  // ===== GITHUB CONFIG & DATA LOADING =====
  const GITHUB_TMR_URL = 'https://raw.githubusercontent.com/crsanju/Cromton_Traffic_Analysis/main/tmr.geojson';
  const GITHUB_GOLDCOAST_URL = 'https://raw.githubusercontent.com/crsanju/Crompton_TIA_QUEUE/refs/heads/main/goldcoast.geojson';
  const GITHUB_IPSWICH_URL = 'https://raw.githubusercontent.com/crsanju/Crompton_TIA_QUEUE/refs/heads/main/Ipswich.geojson';
  const GITHUB_LOGAN_URL = 'https://raw.githubusercontent.com/crsanju/Crompton_TIA_QUEUE/main/logan.geojson';
  const GITHUB_TOOWOOMBA_URL = 'https://raw.githubusercontent.com/crsanju/Crompton_TIA_QUEUE/refs/heads/main/toowoomba.geojson';

  let macroSitesData = {};
  let selectedMacroSite = null;
  let macroMapInstance = null;
  let macroSiteLayer = null;
  let macroSearchMarkerLayer = null;
  let macroReferenceLinkLayer = null;
  let selectedMacroMarker = null;
  let macroSourceFilter = 'ALL';
  const macroMarkersById = {};

  function getFilteredMacroSiteEntries() {
    const entries = Object.entries(macroSitesData);
    if (macroSourceFilter === 'ALL') return entries;
    return entries.filter(([, site]) => site && site.source && site.source === macroSourceFilter);
  }

  function initMacroMap() {
    if (macroMapInstance || !document.getElementById('macroMap') || typeof L === 'undefined') return;
    macroMapInstance = L.map('macroMap', {
      maxBounds: [[-29, 138], [-10, 154]], // Queensland bounds
      restrictBounds: true
    }).setView([-27.55, 152.95], 8);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '¬© OpenStreetMap contributors',
      maxZoom: 19
    }).addTo(macroMapInstance);
    macroSiteLayer = L.layerGroup().addTo(macroMapInstance);
  }

  function renderMacroMapSites() {
    if (!macroMapInstance || !macroSiteLayer || typeof L === 'undefined') return;
    macroSiteLayer.clearLayers();
    selectedMacroMarker = null;
    Object.keys(macroMarkersById).forEach(key => delete macroMarkersById[key]);

    const points = [];
    const filteredEntries = getFilteredMacroSiteEntries();
    filteredEntries.forEach(([siteId, site]) => {
      const lat = Number(site.latitude);
      const lon = Number(site.longitude);
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;

      const marker = L.circleMarker([lat, lon], {
        radius: 4,
        color: '#1f5e63',
        fillColor: '#1f5e63',
        fillOpacity: 0.75,
        weight: 1
      }).addTo(macroSiteLayer);

      marker.bindTooltip(`${siteId} - ${site.road_name || site.description || 'Site'}`);
      marker.on('click', () => selectMacroSite(siteId));
      macroMarkersById[siteId] = marker;
      points.push([lat, lon]);
    });

    if (points.length) {
      macroMapInstance.fitBounds(points, { padding: [24, 24] });
      const info = document.getElementById('macroMapInfo');
      if (info) {
        const label = macroSourceFilter === 'ALL' ? 'TMR + Gold Coast + Ipswich + Logan + Toowoomba' : macroSourceFilter;
        info.textContent = `${points.length} sites loaded for ${label}. Click a marker to select a site.`;
      }
    } else {
      const info = document.getElementById('macroMapInfo');
      if (info) {
        const label = macroSourceFilter === 'ALL' ? 'TMR + Gold Coast + Ipswich + Logan + Toowoomba' : macroSourceFilter;
        info.textContent = `No mappable sites found for ${label}.`;
      }
    }
  }

  function focusMacroSiteOnMap(siteId) {
    if (!macroMapInstance) return;
    const marker = macroMarkersById[siteId];
    if (!marker) return;

    if (selectedMacroMarker) {
      selectedMacroMarker.setStyle({ radius: 4, color: '#1f5e63', fillColor: '#1f5e63', fillOpacity: 0.75, weight: 1 });
    }

    marker.setStyle({ radius: 7, color: '#d36b2c', fillColor: '#d36b2c', fillOpacity: 0.95, weight: 2 });
    selectedMacroMarker = marker;
    const pos = marker.getLatLng();
    macroMapInstance.setView(pos, Math.max(macroMapInstance.getZoom(), 17));

    const info = document.getElementById('macroMapInfo');
    const site = macroSitesData[siteId];
    if (info && site) {
      info.textContent = `Selected ${siteId} (${site.road_name || site.description || 'Site'}) at ${pos.lat.toFixed(5)}, ${pos.lng.toFixed(5)}`;
    }
  }

  async function fetchGitHubData(url) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000);
      console.log(`Fetching: ${url}`);
      const response = await fetch(url, { signal: controller.signal });
      clearTimeout(timeoutId);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const data = await response.json();
      console.log(`Fetched from ${url}: ${data.features ? data.features.length : 0} features`);
      return data;
    } catch (err) {
      console.error(`Fetch failed for ${url}:`, err.message, err);
      return null;
    }
  }

  function parseMacroTrafficData(jsonData, sourceName = 'TMR') {
    const sites = {};
    const features = jsonData.features || [];
    const sourceUpper = String(sourceName || '').toUpperCase();
    const isIpswich = sourceUpper === 'IPSWICH';
    const isLogan = sourceUpper === 'LOGAN';
    const isToowoomba = sourceUpper === 'TOOWOOMBA';

    const normalizeDirectionKey = (rawDirection) => {
      if (!rawDirection) return null;
      const value = String(rawDirection).trim().toUpperCase();
      if (value === 'GAZETTAL' || value === 'D1' || value.includes('WITH GAZ') || value.includes('WITH_GAZ')) return 'GAZETTAL';
      if (value === 'AGAINST GAZETTAL' || value === 'D2' || value.includes('AGAINST')) return 'AGAINST GAZETTAL';
      return null;
    };

    const expandDirectionLabel = (rawDirection) => {
      const value = String(rawDirection || '').trim().toUpperCase();
      if (!value) return '';
      if (value === 'N' || value === 'NB' || value.includes('NORTH')) return 'Northbound';
      if (value === 'S' || value === 'SB' || value.includes('SOUTH')) return 'Southbound';
      if (value === 'E' || value === 'EB' || value.includes('EAST')) return 'Eastbound';
      if (value === 'W' || value === 'WB' || value.includes('WEST') || value === 'WE') return 'Westbound';
      return String(rawDirection).trim();
    };

    const parseYearFromAny = (...values) => {
      for (const value of values) {
        if (value === null || value === undefined || value === '') continue;
        const asNumber = Number(value);
        if (Number.isFinite(asNumber) && asNumber >= 1900 && asNumber <= 2100) return Math.round(asNumber);
        const match = String(value).match(/(19|20)\d{2}/);
        if (match) return Number(match[0]);
      }
      return 2024;
    };

    const calcLoganHvPercent = (props) => {
      const heavyFields = ['M3_5_PCENT', 'M4_5_PCENT', 'L3_PCENT', 'L4_PCENT', 'L5_PCENT', 'L6_PCENT', 'L7_8_PCENT'];
      const total = heavyFields.reduce((sum, field) => sum + (Number(props[field]) || 0), 0);
      return total > 0 ? Math.round(total * 10) / 10 : null;
    };

    const normalizePercentValue = (value) => {
      const n = Number(value);
      if (!Number.isFinite(n) || n <= 0) return null;
      // Some sources store percentages as fractions (e.g. 0.09 = 9%)
      const normalized = n <= 1 ? (n * 100) : n;
      return Math.round(normalized * 100) / 100;
    };

    const createIpswichSiteKey = (props) => {
      const road = String(props['Road Name'] || '').trim();
      const suburb = String(props['Suburb'] || '').trim();
      const siteDesc = String(props['Site Description'] || '').trim();
      const lat = Number(props['Latitude']);
      const lon = Number(props['Longitude']);
      const loc = (Number.isFinite(lat) && Number.isFinite(lon)) ? `${lat.toFixed(5)},${lon.toFixed(5)}` : '';
      const key = [road, suburb, siteDesc].filter(Boolean).join(' | ');
      return key || loc || String(props['Id'] || props['ID'] || props['id'] || '').trim();
    };

    features.forEach(feature => {
      const props = feature.properties;
      if (!props) return;

      const rawSiteId = isIpswich
        ? createIpswichSiteKey(props)
        : (props['SITE_ID'] || props['site_id'] || props['OBJECTID'] || props['ID'] || props['id'] || props['Id'] || props['SITE'] || props['Site'] || '');
      const siteId = String(rawSiteId || '').trim();
      if (!siteId) return;

      const suburb = props['SUBURB'] || props['Suburb'] || props['Suburb'] || '';
      const rawDescription = props['DESCRIPTION'] || props['LOCATION'] || props['COUNTER_LOCATION_BETWEEN'] || props['Site Description'] || props['Local_Road_Alias'] || '';
      const description = suburb ? `${suburb} - ${rawDescription}` : String(rawDescription).replace(/"/g, '').trim();
      const roadName = String(props['ROAD_NAME'] || props['STREET'] || props['STREET_NAME'] || props['Road Name'] || props['Road_Name'] || '').replace(/"/g, '').trim();
      const geomCoords = feature && feature.geometry && Array.isArray(feature.geometry.coordinates) ? feature.geometry.coordinates : [];

      let longitude = props['LONGITUDE'] || props['LON'] || props['LONG'] || props['Longitude'];
      let latitude = props['LATITUDE'] || props['LAT'] || props['Latitude'];

      if (!longitude || !latitude) {
        if (feature.geometry && feature.geometry.type === 'LineString' && geomCoords.length > 0) {
          const midIdx = Math.floor(geomCoords.length / 2);
          const midPoint = geomCoords[midIdx];
          if (Array.isArray(midPoint) && midPoint.length >= 2) {
            longitude = longitude || midPoint[0];
            latitude = latitude || midPoint[1];
          }
        } else if (feature.geometry && feature.geometry.type === 'MultiLineString' && geomCoords.length > 0 && Array.isArray(geomCoords[0])) {
          const firstLine = geomCoords[0];
          const midIdx = Math.floor(firstLine.length / 2);
          const midPoint = firstLine[midIdx];
          if (Array.isArray(midPoint) && midPoint.length >= 2) {
            longitude = longitude || midPoint[0];
            latitude = latitude || midPoint[1];
          }
        } else if (feature.geometry && feature.geometry.type === 'Point') {
          longitude = longitude || geomCoords[0];
          latitude = latitude || geomCoords[1];
        }
      }

      if (!Number.isFinite(Number(longitude)) || !Number.isFinite(Number(latitude))) return;

      const countYear = parseYearFromAny(
        props['COUNT_YEAR'], props['DATA_YEAR'], props['YEAR'], props['AADT_DATE'], props['SURVEY_DATE'], props['AAWT_DATE'], props['Start Day|Survey'], props['Finish_Date']
      );
      const growthRate = Number(props['GROWTH_RATE'] || props['GROWTH'] || '') || null;
      const hvPercentDirectRaw = props['HV_PERCENT'] || props['HVP'] || props['Percentage Commercial Vehicles'] || props['Percent_Commercial_Heavy_Vehicl'];
      const hvPercentDirect = normalizePercentValue(hvPercentDirectRaw);
      const hvPercent = hvPercentDirect !== null ? hvPercentDirect : normalizePercentValue(isLogan ? calcLoganHvPercent(props) : null);
      const totalVadtFromProps = Number(props['VADT'] || props['AADT'] || props['VPD'] || props['TOTAL_VADT'] || props['Average Daily Traffic Adt Vehicles Per Day'] || props['Average Weekday Traffic Awt Vehicles Per Day'] || props['ADT']) || null;

      let d1VadtFromProps = Number(props['D1_VADT'] || props['GAZETTAL_VADT'] || props['VADT_D1'] || props['VOL1'] || '') || null;
      let d2VadtFromProps = Number(props['D2_VADT'] || props['AGAINST_GAZETTAL_VADT'] || props['VADT_D2'] || props['VOL2'] || '') || null;
      if (!d1VadtFromProps && props['DIRECTION_1A']) {
        const m = String(props['DIRECTION_1A']).match(/(\d+)/);
        if (m) d1VadtFromProps = Number(m[1]);
      }
      if (!d2VadtFromProps && props['DIRECTION_2A']) {
        const m = String(props['DIRECTION_2A']).match(/(\d+)/);
        if (m) d2VadtFromProps = Number(m[1]);
      }

      let d1Lanes = Number(props['D1_LANES'] || props['GAZETTAL_LANES'] || props['LANES_D1'] || '') || null;
      let d2Lanes = Number(props['D2_LANES'] || props['AGAINST_GAZETTAL_LANES'] || props['LANES_D2'] || '') || null;
      let totalLanes = Number(props['LANES'] || props['NUM_LANES'] || props['TOTAL_LANES'] || '') || null;
      if (isLogan) {
        const laneNoAadt = Number(props['LANE_NO_AADT']) || null;
        if (laneNoAadt && laneNoAadt > 0) {
          totalLanes = totalLanes || laneNoAadt;
          if (!d1Lanes && !d2Lanes) {
            d1Lanes = Math.max(1, Math.ceil(laneNoAadt / 2));
            d2Lanes = Math.max(1, Math.floor(laneNoAadt / 2));
          }
        }
      }

      if (!sites[siteId]) {
        sites[siteId] = {
          id: siteId,
          source: sourceName,
          description,
          road_name: roadName,
          longitude: Number(longitude),
          latitude: Number(latitude),
          countYear,
          vadt: 0,
          growth_rate: growthRate,
          hv_percent: hvPercent,
          d1_lanes: d1Lanes,
          d2_lanes: d2Lanes,
          total_lanes: totalLanes,
          d1_vadt: 0,
          d2_vadt: 0,
          dtca_auto: false,
          d1_direction_label: 'Gazettal',
          d2_direction_label: 'Against Gazettal',
          directions_weekday: {
            'GAZETTAL': new Array(24).fill(0),
            'AGAINST GAZETTAL': new Array(24).fill(0)
          },
          directions: {
            'GAZETTAL': new Array(24).fill(0),
            'AGAINST GAZETTAL': new Array(24).fill(0)
          },
          hour_order: {
            'GAZETTAL': [],
            'AGAINST GAZETTAL': []
          },
          direction_descriptions: {
            'GAZETTAL': '',
            'AGAINST GAZETTAL': ''
          },
          _directionMap: {}
        };
      }

      const site = sites[siteId];
      if (totalVadtFromProps && (!site.vadt || site.vadt <= 0 || countYear >= (site.countYear || 0))) {
        site.vadt = totalVadtFromProps;
      }
      if (d1VadtFromProps) site.d1_vadt = d1VadtFromProps;
      if (d2VadtFromProps) site.d2_vadt = d2VadtFromProps;
      if (!site.hv_percent && hvPercent) site.hv_percent = hvPercent;
      if (!site.growth_rate && growthRate) site.growth_rate = growthRate;
      if (!site.d1_lanes && d1Lanes) site.d1_lanes = d1Lanes;
      if (!site.d2_lanes && d2Lanes) site.d2_lanes = d2Lanes;
      if (!site.total_lanes && totalLanes) site.total_lanes = totalLanes;

      const ipswichDirection = props['Direction'];
      if (ipswichDirection && totalVadtFromProps) {
        const dirKey = String(ipswichDirection).trim();
        if (!site._directionMap[dirKey]) {
          const assignedDirs = Object.keys(site._directionMap);
          if (assignedDirs.length === 0) {
            site._directionMap[dirKey] = 'GAZETTAL';
            site.d1_vadt = totalVadtFromProps;
            site.direction_descriptions['GAZETTAL'] = expandDirectionLabel(dirKey);
          } else if (assignedDirs.length === 1) {
            site._directionMap[dirKey] = 'AGAINST GAZETTAL';
            site.d2_vadt = totalVadtFromProps;
            site.direction_descriptions['AGAINST GAZETTAL'] = expandDirectionLabel(dirKey);
          }
        }
      }

      const dir1Label = props['DIRECTION_1A'] || props['DIR1'] || '';
      const dir2Label = props['DIRECTION_2A'] || props['DIR2'] || '';
      if (dir1Label) {
        const match = String(dir1Label).match(/(North|South|East|West|Northbound|Southbound|Eastbound|Westbound|N|S|E|W|NB|SB|EB|WB)/i);
        if (match) site.direction_descriptions['GAZETTAL'] = expandDirectionLabel(match[0]);
      }
      if (dir2Label) {
        const match = String(dir2Label).match(/(North|South|East|West|Northbound|Southbound|Eastbound|Westbound|N|S|E|W|NB|SB|EB|WB)/i);
        if (match) site.direction_descriptions['AGAINST GAZETTAL'] = expandDirectionLabel(match[0]);
      }

      const hours = props['HOURS'];
      const hourMatch = hours ? String(hours).match(/^(\d+)\s+to\s+(\d+)$/) : null;
      const direction = normalizeDirectionKey(props['GAZETTAL_DIRECTION'] || props['DIRECTION'] || props['direction']);

      if (direction && (description || roadName)) {
        const textToSearch = `${description} ${roadName}`;
        const dirMatch = textToSearch.match(/(Northbound|Southbound|Eastbound|Westbound|North|South|East|West|NB|SB|EB|WB)/i);
        if (dirMatch && !site.direction_descriptions[direction]) {
          site.direction_descriptions[direction] = expandDirectionLabel(dirMatch[0]);
        }
      }

      if (!direction && props['Direction']) {
        const ipswichDir = String(props['Direction']).trim();
        let amPeakStartHour = null;
        if (props['Weekday Avg AM Peak Start Hour']) {
          const m = String(props['Weekday Avg AM Peak Start Hour']).match(/^(\d+):/);
          amPeakStartHour = m ? parseInt(m[1], 10) : null;
        }
        let pmPeakStartHour = null;
        if (props['Weekday Avg PM Peak Start Hour']) {
          const m = String(props['Weekday Avg PM Peak Start Hour']).match(/^(\d+):/);
          pmPeakStartHour = m ? parseInt(m[1], 10) : null;
        }

        const amPeakFlow = Number(props['Weekday Avg AM Peak Flow Vehicles Per Hour']) || null;
        const pmPeakFlow = Number(props['Weekday Avg PM Peak Flow Vehicles Per Hour']) || null;
        const assignedDir = site._directionMap[ipswichDir];

        if (assignedDir) {
          if (amPeakStartHour !== null && amPeakFlow !== null && amPeakStartHour >= 0 && amPeakStartHour < 24) {
            site.directions_weekday[assignedDir][amPeakStartHour] = Math.ceil(amPeakFlow);
            site.directions[assignedDir][amPeakStartHour] = Math.ceil(amPeakFlow);
          }
          if (pmPeakStartHour !== null && pmPeakFlow !== null && pmPeakStartHour >= 0 && pmPeakStartHour < 24) {
            site.directions_weekday[assignedDir][pmPeakStartHour] = Math.ceil(pmPeakFlow);
            site.directions[assignedDir][pmPeakStartHour] = Math.ceil(pmPeakFlow);
          }
        }
      }

      if (hourMatch) {
        const hourIndex = parseInt(hourMatch[1], 10);
        if (hourIndex >= 0 && hourIndex < 24 && direction && site.directions_weekday[direction]) {
          const weekdayAvg = props['WEEKDAY_AVERAGE'] ? Math.ceil(parseFloat(props['WEEKDAY_AVERAGE'])) : 0;
          site.directions_weekday[direction][hourIndex] = weekdayAvg;
          site.directions[direction][hourIndex] = weekdayAvg;
        }
      }

      if (isLogan) {
        const amPeak = Number(props['AM_PEAK']) || 0;
        const pmPeak = Number(props['PM_PEAK']) || 0;
        const amHour = Number(props['AM_FROM_HUR']);
        const pmHour = Number(props['PM_FROM_HUR']);
        const amIdx = Number.isFinite(amHour) && amHour >= 0 && amHour < 24 ? amHour : 8;
        const pmIdx = Number.isFinite(pmHour) && pmHour >= 0 && pmHour < 24 ? pmHour : 17;

        if (amPeak > 0) {
          site.directions_weekday['GAZETTAL'][amIdx] = Math.max(site.directions_weekday['GAZETTAL'][amIdx], Math.round(amPeak * 0.5));
          site.directions_weekday['AGAINST GAZETTAL'][amIdx] = Math.max(site.directions_weekday['AGAINST GAZETTAL'][amIdx], Math.round(amPeak * 0.5));
        }
        if (pmPeak > 0) {
          site.directions_weekday['GAZETTAL'][pmIdx] = Math.max(site.directions_weekday['GAZETTAL'][pmIdx], Math.round(pmPeak * 0.5));
          site.directions_weekday['AGAINST GAZETTAL'][pmIdx] = Math.max(site.directions_weekday['AGAINST GAZETTAL'][pmIdx], Math.round(pmPeak * 0.5));
        }
      }

      if (isToowoomba) {
        const adt = Number(props['ADT']) || 0;
        if (adt > 0 && (!site.vadt || site.vadt <= 0)) site.vadt = adt;
      }
    });

    // Calculate D1 & D2 VADT from directional data and set labels
    const isGoldCoast = sourceUpper === 'GOLD COAST';
    Object.keys(sites).forEach(siteId => {
      const site = sites[siteId];
      const gazData = site.directions_weekday['GAZETTAL'] || new Array(24).fill(0);
      const agData = site.directions_weekday['AGAINST GAZETTAL'] || new Array(24).fill(0);
      
      const d1Total = gazData.reduce((a, b) => a + (Number(b) || 0), 0);
      const d2Total = agData.reduce((a, b) => a + (Number(b) || 0), 0);
      
      const computedD1 = Math.ceil(d1Total);
      const computedD2 = Math.ceil(d2Total);

      if (computedD1 > 0 || computedD2 > 0) {
        site.d1_vadt = computedD1;
        site.d2_vadt = computedD2;
      }

      if (site.d1_vadt <= 0 && site.d2_vadt <= 0) {
        const totalVadt = Number(site.vadt || 0);
        if (totalVadt > 0) {
          site.d1_vadt = Math.round(totalVadt * 0.5);
          site.d2_vadt = Math.round(totalVadt * 0.5);
        }
      } else if (!site.vadt || site.vadt <= 0) {
        // If we have d1/d2 but no total, calculate it (for Ipswich data)
        site.vadt = (site.d1_vadt || 0) + (site.d2_vadt || 0);
      }

      if (isGoldCoast) {
        let totalVadt = Number(site.vadt || 0);
        let d1Vadt = Number(site.d1_vadt || 0);
        let d2Vadt = Number(site.d2_vadt || 0);

        if (totalVadt > 0 && d1Vadt > 0 && d2Vadt > 0) {
          const dirSum = d1Vadt + d2Vadt;
          const diffRatio = Math.abs(dirSum - totalVadt) / totalVadt;
          if (dirSum > 0 && diffRatio > 0.35) {
            d1Vadt = Math.round(totalVadt * (d1Vadt / dirSum));
            d2Vadt = Math.max(0, totalVadt - d1Vadt);
          }
        }

        if (totalVadt > 0 && d1Vadt > 0 && d2Vadt <= 0) {
          d2Vadt = Math.max(0, totalVadt - d1Vadt);
        }
        if (totalVadt > 0 && d2Vadt > 0 && d1Vadt <= 0) {
          d1Vadt = Math.max(0, totalVadt - d2Vadt);
        }
        if (totalVadt <= 0 && d1Vadt > 0 && d2Vadt > 0) {
          totalVadt = d1Vadt + d2Vadt;
        }
        if (totalVadt > 0 && d1Vadt <= 0 && d2Vadt <= 0) {
          d1Vadt = Math.round(totalVadt * 0.5);
          d2Vadt = Math.max(0, totalVadt - d1Vadt);
        }

        site.vadt = Math.round(Math.max(0, totalVadt));
        site.d1_vadt = Math.round(Math.max(0, d1Vadt));
        site.d2_vadt = Math.round(Math.max(0, d2Vadt));
      }

      if (isGoldCoast && Number(site.vadt || 0) <= 0 && Number(site.d1_vadt || 0) <= 0 && Number(site.d2_vadt || 0) <= 0) {
        delete sites[siteId];
        return;
      }

      if (isToowoomba && Number(site.vadt || 0) <= 0 && Number(site.d1_vadt || 0) <= 0 && Number(site.d2_vadt || 0) <= 0) {
        delete sites[siteId];
        return;
      }

      site.dtca_auto = (d1Total > 0 && d2Total > 0);

      if (!site.dtca_auto && site.d1_vadt > 0 && site.d2_vadt > 0) {
        site.dtca_auto = true;
      }
      
      // Clean up helper property
      delete site._directionMap;
      
      // Smart direction labeling with opposite direction inference
      const gazLabel = site.direction_descriptions['GAZETTAL'];
      const agLabel = site.direction_descriptions['AGAINST GAZETTAL'];
      
      // If both have the same direction or one is missing, infer the opposite
      const getOppositeDir = (dir) => {
        if (!dir) return null;
        const d = dir.toLowerCase();
        if (d.includes('north') || d === 'nb') return 'Southbound';
        if (d.includes('south') || d === 'sb') return 'Northbound';
        if (d.includes('east') || d === 'eb') return 'Westbound';
        if (d.includes('west') || d === 'wb') return 'Eastbound';
        return null;
      };
      
      let finalGazLabel = gazLabel;
      let finalAgLabel = agLabel;
      
      // If both exist and are the same (error case), fix it
      if (gazLabel && agLabel && gazLabel.toLowerCase() === agLabel.toLowerCase()) {
        finalAgLabel = getOppositeDir(gazLabel);
      }
      // If only one exists, infer the other
      else if (gazLabel && !agLabel) {
        finalAgLabel = getOppositeDir(gazLabel);
      }
      else if (!gazLabel && agLabel) {
        finalGazLabel = getOppositeDir(agLabel);
      }
      
      site.d1_direction_label = finalGazLabel ? `Gazettal (${finalGazLabel})` : 'Gazettal';
      site.d2_direction_label = finalAgLabel ? `Against Gazettal (${finalAgLabel})` : 'Against Gazettal';
    });

    console.log(`${sourceName}: Processed ${features.length} features, created ${Object.keys(sites).length} unique sites`);
    return sites;
  }

  function mergeMacroSites(...siteMaps) {
    const merged = {};
    siteMaps.forEach(map => {
      Object.entries(map || {}).forEach(([siteId, site]) => {
        let uniqueKey = siteId;
        if (merged[uniqueKey]) {
          const src = site && site.source ? site.source : 'DATA';
          uniqueKey = `${siteId} (${src})`;
        }
        merged[uniqueKey] = {
          ...site,
          id: uniqueKey
        };
      });
    });
    return merged;
  }

  async function loadMacroSitesData() {
    console.log('Loading Macro sites from GitHub (TMR + Gold Coast + Ipswich + Logan + Toowoomba)...');
    const [tmrData, goldCoastData, ipswichData, loganData, toowoombaData] = await Promise.all([
      fetchGitHubData(GITHUB_TMR_URL),
      fetchGitHubData(GITHUB_GOLDCOAST_URL),
      fetchGitHubData(GITHUB_IPSWICH_URL),
      fetchGitHubData(GITHUB_LOGAN_URL),
      fetchGitHubData(GITHUB_TOOWOOMBA_URL)
    ]);

    const tmrSites = tmrData ? parseMacroTrafficData(tmrData, 'TMR') : {};
    const goldCoastSites = goldCoastData ? parseMacroTrafficData(goldCoastData, 'Gold Coast') : {};
    const ipswichSites = ipswichData ? parseMacroTrafficData(ipswichData, 'Ipswich') : (console.warn('ipswichData is null/falsy'), {});
    const loganSites = loganData ? parseMacroTrafficData(loganData, 'Logan') : {};
    const toowoomSites = toowoombaData ? parseMacroTrafficData(toowoombaData, 'Toowoomba') : {};

    macroSitesData = mergeMacroSites(tmrSites, goldCoastSites, ipswichSites, loganSites, toowoomSites);

    console.log(`Loaded ${Object.keys(macroSitesData).length} macro sites (TMR: ${Object.keys(tmrSites).length}, Gold Coast: ${Object.keys(goldCoastSites).length}, Ipswich: ${Object.keys(ipswichSites).length}, Logan: ${Object.keys(loganSites).length}, Toowoomba: ${Object.keys(toowoomSites).length})`);
    document.getElementById('sitesLoadedCount').textContent = Object.keys(macroSitesData).length;
    populateMacroSitesDatalist();
    initMacroMap();
    renderMacroMapSites();

    const mapInfo = document.getElementById('macroMapInfo');
    if (mapInfo) {
      mapInfo.textContent = `${Object.keys(macroSitesData).length} combined sites loaded (TMR + Gold Coast + Ipswich + Logan + Toowoomba). Click a marker to select a site.`;
    }
  }

  function populateMacroSitesDatalist() {
    const datalist = document.getElementById('macroSitesList');
    datalist.innerHTML = '';
    const filteredEntries = getFilteredMacroSiteEntries();
    filteredEntries.forEach(([id, data]) => {
      const option = document.createElement('option');
      option.value = id;
      const sourceTag = data.source ? ` [${data.source}]` : '';
      option.textContent = `${id} - ${data.description}${sourceTag}`;
      datalist.appendChild(option);
    });
  }

  function selectMacroSite(siteId) {
    const data = macroSitesData[siteId];
    if (!data) return;

    const hasDbHv = data.hv_percent !== null
      && data.hv_percent !== undefined
      && Number.isFinite(Number(data.hv_percent))
      && Number(data.hv_percent) > 0;

    selectedMacroSite = siteId;
    document.getElementById('macroSiteSearch').value = siteId;
    
    const detailsPanel = document.getElementById('macroSiteDetailsPanel');
    if (detailsPanel) detailsPanel.style.display = 'block';

    const setText = (id, value) => {
      const el = document.getElementById(id);
      if (el) el.textContent = value || '-';
    };

    const setSourceBadge = (sourceValue) => {
      const el = document.getElementById('macroDetailSource');
      if (!el) return;
      const source = String(sourceValue || 'N/A').trim();
      const classSuffix = source.toLowerCase().replace(/\s+/g, '-');
      el.innerHTML = `<span class="source-pill source-${classSuffix}">${source}</span>`;
    };

    const setQualityBadge = () => {
      const el = document.getElementById('macroDetailQuality');
      if (!el) return;
      const d1 = Number(data.d1_vadt) || 0;
      const d2 = Number(data.d2_vadt) || 0;
      const hourlyD1 = data && data.directions_weekday && Array.isArray(data.directions_weekday['GAZETTAL'])
        ? data.directions_weekday['GAZETTAL'].reduce((s, v) => s + (Number(v) || 0), 0)
        : 0;
      const hourlyD2 = data && data.directions_weekday && Array.isArray(data.directions_weekday['AGAINST GAZETTAL'])
        ? data.directions_weekday['AGAINST GAZETTAL'].reduce((s, v) => s + (Number(v) || 0), 0)
        : 0;

      let label = 'Estimated';
      let cls = 'quality-estimated';

      if (hourlyD1 + hourlyD2 > 0) {
        label = 'Measured (Hourly)';
        cls = 'quality-measured';
      } else if (d1 > 0 && d2 > 0) {
        label = 'Derived (Directional)';
        cls = 'quality-derived';
      } else if ((Number(data.vadt) || 0) > 0) {
        label = 'Estimated (Total only)';
        cls = 'quality-estimated';
      }

      el.innerHTML = `<span class="quality-pill ${cls}">${label}</span>`;
    };

    setText('macroDetailSiteId', siteId);
    setSourceBadge(data.source || 'N/A');
    setText('macroDetailRoadName', data.road_name || 'N/A');
    setText('macroDetailDescription', data.description || 'N/A');
    setText('macroDetailCountYear', data.countYear || data.count_year || 'N/A');
    setText('macroDetailGrowthRate', data.growth_rate ? `${data.growth_rate}% p.a.` : 'N/A');
    setText('macroDetailHV', hasDbHv ? `${data.hv_percent}%` : 'N/A');
    setQualityBadge();

    const d1 = Number(data.d1_vadt) || 0;
    const d2 = Number(data.d2_vadt) || 0;
    const vadt = d1 + d2;

    setText('macroDetailD1', d1.toLocaleString());
    setText('macroDetailD2', d2.toLocaleString());
    setText('macroDetailTotal', vadt.toLocaleString());

    if (Number.isFinite(Number(data.latitude)) && Number.isFinite(Number(data.longitude))) {
      const lat = Number(data.latitude);
      const lon = Number(data.longitude);
      setText('macroDetailCoords', `${lat.toFixed(6)}, ${lon.toFixed(6)}`);
      document.getElementById('macroMapLink').href = `https://www.google.com/maps?q=${lat},${lon}`;
    } else {
      setText('macroDetailCoords', 'N/A');
      document.getElementById('macroMapLink').href = 'javascript:void(0)';
    }

    // Auto-fill DATABASE fields (green)
    document.getElementById('macroSiteId').value = siteId;
    document.getElementById('baseYear').value = data.countYear || 2024;
    document.getElementById('baseHVPercent').value = hasDbHv ? Number(data.hv_percent) : '';
    document.getElementById('D1_VADT').value = d1;
    document.getElementById('D2_VADT').value = d2;
    
    // Auto-calculate VADT
    document.getElementById('VADT').value = Math.round(vadt);
    
    // Auto-detect DTCA based on directional data
    document.getElementById('DTCA').value = data.dtca_auto ? 'Yes' : 'No';
    
    // Auto-fill growth rate if available in DB and visually mark DB/manual mode
    const growthEl = document.getElementById('macroGrowthRate');
    const growthWrapper = growthEl ? growthEl.closest('div') : null;
    const growthLabel = growthWrapper ? growthWrapper.querySelector('label') : null;
    if (data.growth_rate !== null && data.growth_rate !== undefined && Number.isFinite(Number(data.growth_rate))) {
      growthEl.value = data.growth_rate;
      growthEl.readOnly = true;
      growthEl.style.border = '1px solid #81c784';
      growthEl.style.backgroundColor = '#f1f8f6';
      growthEl.style.color = '#1b5e20';
      if (growthWrapper) {
        growthWrapper.style.background = '#e8f5e9';
        growthWrapper.style.border = '1px solid #81c784';
      }
      if (growthLabel) {
        growthLabel.style.color = '#2e7d32';
        growthLabel.innerHTML = 'Growth Rate (% p.a.) (from DB)';
      }
    } else {
      growthEl.readOnly = false;
      growthEl.style.border = '1px solid #ffc107';
      growthEl.style.backgroundColor = '#fffbf0';
      growthEl.style.color = '#000';
      if (growthWrapper) {
        growthWrapper.style.background = '#fff3cd';
        growthWrapper.style.border = '1px solid #ffc107';
      }
      if (growthLabel) {
        growthLabel.style.color = '#c30000';
        growthLabel.innerHTML = 'Growth Rate (% p.a.) *';
      }
    }
    
    // Auto-fill HVP if available in DB and visually mark it as database-driven
    const hvpEl = document.getElementById('HVP');
    const hvpWrapper = hvpEl ? hvpEl.closest('div') : null;
    const hvpLabel = hvpWrapper ? hvpWrapper.querySelector('label') : null;
    if (hasDbHv) {
      hvpEl.value = data.hv_percent;
      hvpEl.readOnly = true;
      hvpEl.style.border = '1px solid #81c784';
      hvpEl.style.backgroundColor = '#f1f8f6';
      hvpEl.style.color = '#1b5e20';
      if (hvpWrapper) {
        hvpWrapper.style.background = '#e8f5e9';
        hvpWrapper.style.border = '1px solid #81c784';
      }
      if (hvpLabel) {
        hvpLabel.style.color = '#2e7d32';
        hvpLabel.innerHTML = 'HV (%) (from DB)';
      }
    } else {
      hvpEl.value = '';
      hvpEl.readOnly = false;
      hvpEl.style.border = '1px solid #ffc107';
      hvpEl.style.backgroundColor = '#fffbf0';
      hvpEl.style.color = '#000';
      if (hvpWrapper) {
        hvpWrapper.style.background = '#fff3cd';
        hvpWrapper.style.border = '1px solid #ffc107';
      }
      if (hvpLabel) {
        hvpLabel.style.color = '#c30000';
        hvpLabel.innerHTML = 'HV (%) *';
      }
    }
    
    // Auto-fill lane counts if available in DB
    const d1LanesEl = document.getElementById('D1_Lanes');
    const d2LanesEl = document.getElementById('D2_Lanes');
    const d1LanesWrapper = d1LanesEl ? d1LanesEl.closest('div') : null;
    const d2LanesWrapper = d2LanesEl ? d2LanesEl.closest('div') : null;
    const d1LanesLabel = d1LanesWrapper ? d1LanesWrapper.querySelector('label') : null;
    const d2LanesLabel = d2LanesWrapper ? d2LanesWrapper.querySelector('label') : null;
    
    if (data.d1_lanes !== null && data.d1_lanes > 0) {
      d1LanesEl.value = data.d1_lanes;
      d1LanesEl.readOnly = true;
      d1LanesEl.style.border = '1px solid #81c784';
      d1LanesEl.style.backgroundColor = '#f1f8f6';
      d1LanesEl.style.color = '#1b5e20';
      if (d1LanesWrapper) {
        d1LanesWrapper.style.background = '#e8f5e9';
        d1LanesWrapper.style.border = '1px solid #81c784';
      }
      if (d1LanesLabel) {
        d1LanesLabel.style.color = '#2e7d32';
        d1LanesLabel.innerHTML = 'D1 Lanes (from DB)';
      }
    } else {
      d1LanesEl.value = 1;
      d1LanesEl.readOnly = false;
      d1LanesEl.style.border = '1px solid #ffc107';
      d1LanesEl.style.backgroundColor = '#fffbf0';
      d1LanesEl.style.color = '#000';
      if (d1LanesWrapper) {
        d1LanesWrapper.style.background = '#fff3cd';
        d1LanesWrapper.style.border = '1px solid #ffc107';
      }
      if (d1LanesLabel) {
        d1LanesLabel.style.color = '#c30000';
        d1LanesLabel.innerHTML = 'D1 Lanes *';
      }
    }
    
    if (data.d2_lanes !== null && data.d2_lanes > 0) {
      d2LanesEl.value = data.d2_lanes;
      d2LanesEl.readOnly = true;
      d2LanesEl.style.border = '1px solid #81c784';
      d2LanesEl.style.backgroundColor = '#f1f8f6';
      d2LanesEl.style.color = '#1b5e20';
      if (d2LanesWrapper) {
        d2LanesWrapper.style.background = '#e8f5e9';
        d2LanesWrapper.style.border = '1px solid #81c784';
      }
      if (d2LanesLabel) {
        d2LanesLabel.style.color = '#2e7d32';
        d2LanesLabel.innerHTML = 'D2 Lanes (from DB)';
      }
    } else {
      d2LanesEl.value = 1;
      d2LanesEl.readOnly = false;
      d2LanesEl.style.border = '1px solid #ffc107';
      d2LanesEl.style.backgroundColor = '#fffbf0';
      d2LanesEl.style.color = '#000';
      if (d2LanesWrapper) {
        d2LanesWrapper.style.background = '#fff3cd';
        d2LanesWrapper.style.border = '1px solid #ffc107';
      }
      if (d2LanesLabel) {
        d2LanesLabel.style.color = '#c30000';
        d2LanesLabel.innerHTML = 'D2 Lanes *';
      }
    }
    
    syncVisibility();
    focusMacroSiteOnMap(siteId);
    updateAssumptionsPanel(data);
    
    // Render charts with database data
    renderMacroCharts(data);
    
    console.log(`Selected site: ${siteId}, VADT: ${vadt}, DTCA: ${data.dtca_auto}, D1: ${data.d1_vadt}, D2: ${data.d2_vadt}`);
  }

  // ===== CHART RENDERING =====
  let macroHourlyChartInstance = null;
  let macroD1PieChartInstance = null;
  let macroD2PieChartInstance = null;

  function renderMacroCharts(data) {
    if (!data || !data.directions_weekday) return;
    
    // Show the visualization section
    const vizSection = document.getElementById('macroDataVizSection');
    if (vizSection) vizSection.style.display = 'block';
    
    const buildSyntheticHourly = (dailyTotal) => {
      const total = Math.max(0, Math.round(Number(dailyTotal) || 0));
      const hourly = new Array(24).fill(0);
      if (total <= 0) return hourly;

      const blocks = [
        { hours: [6, 7, 8, 9], share: 0.20 },
        { hours: [10, 11, 12, 13, 14, 15], share: 0.40 },
        { hours: [16, 17, 18], share: 0.20 },
        { hours: [0, 1, 2, 3, 4, 5, 19, 20, 21, 22, 23], share: 0.20 }
      ];

      let assigned = 0;
      blocks.forEach((block, blockIndex) => {
        const blockTotal = blockIndex === blocks.length - 1
          ? (total - assigned)
          : Math.round(total * block.share);
        assigned += blockTotal;

        const perHour = Math.floor(blockTotal / block.hours.length);
        let remainder = blockTotal - (perHour * block.hours.length);
        block.hours.forEach((hour, idx) => {
          hourly[hour] = perHour + (idx < remainder ? 1 : 0);
        });
      });

      return hourly;
    };

    let gazData = data.directions_weekday['GAZETTAL'] || new Array(24).fill(0);
    let agData = data.directions_weekday['AGAINST GAZETTAL'] || new Array(24).fill(0);

    const gazTotal = gazData.reduce((sum, value) => sum + (Number(value) || 0), 0);
    const agTotal = agData.reduce((sum, value) => sum + (Number(value) || 0), 0);

    if (gazTotal <= 0 && Number(data.d1_vadt) > 0) {
      gazData = buildSyntheticHourly(data.d1_vadt);
    }
    if (agTotal <= 0 && Number(data.d2_vadt) > 0) {
      agData = buildSyntheticHourly(data.d2_vadt);
    }
    
    // Hourly Profile Chart
    const ctx1 = document.getElementById('macroHourlyChart');
    if (ctx1) {
      if (macroHourlyChartInstance) macroHourlyChartInstance.destroy();
      
      macroHourlyChartInstance = new Chart(ctx1, {
        type: 'line',
        data: {
          labels: Array.from({length: 24}, (_, i) => `${i}:00`),
          datasets: [
            {
              label: 'Gazettal',
              data: gazData,
              borderColor: '#4caf50',
              backgroundColor: 'rgba(76, 175, 80, 0.1)',
              tension: 0.3,
              fill: true
            },
            {
              label: 'Against Gazettal',
              data: agData,
              borderColor: '#ef5350',
              backgroundColor: 'rgba(239, 83, 80, 0.1)',
              tension: 0.3,
              fill: true
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          plugins: {
            title: { display: false },
            legend: { position: 'top' }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: { display: true, text: 'Volume (vph)' }
            },
            x: {
              title: { display: true, text: 'Hour of Day' }
            }
          }
        }
      });
    }
    
    // Gazettal Pie Chart (AM/OP/PM/EV breakdown)
    const d1Total = gazData.reduce((a, b) => a + b, 0);
    const d1AM = [6,7,8].map(h => gazData[h]).reduce((a,b) => a+b, 0);
    const d1OP = [10,11,12,13,14,15].map(h => gazData[h]).reduce((a,b) => a+b, 0);
    const d1PM = [16,17,18].map(h => gazData[h]).reduce((a,b) => a+b, 0);
    const d1EV = d1Total - d1AM - d1OP - d1PM;
    
    const ctx2 = document.getElementById('macroD1PieChart');
    if (ctx2) {
      if (macroD1PieChartInstance) macroD1PieChartInstance.destroy();
      
      macroD1PieChartInstance = new Chart(ctx2, {
        type: 'pie',
        data: {
          labels: ['AM (6-9)', 'OP (10-15)', 'PM (16-18)', 'EV (Other)'],
          datasets: [{
            data: [d1AM, d1OP, d1PM, d1EV],
            backgroundColor: ['#ff9800', '#2196f3', '#f44336', '#9c27b0']
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          plugins: {
            legend: { position: 'bottom' }
          }
        }
      });
    }
    
    // Against Gazettal Pie Chart
    const d2Total = agData.reduce((a, b) => a + b, 0);
    const d2AM = [6,7,8].map(h => agData[h]).reduce((a,b) => a+b, 0);
    const d2OP = [10,11,12,13,14,15].map(h => agData[h]).reduce((a,b) => a+b, 0);
    const d2PM = [16,17,18].map(h => agData[h]).reduce((a,b) => a+b, 0);
    const d2EV = d2Total - d2AM - d2OP - d2PM;
    
    const ctx3 = document.getElementById('macroD2PieChart');
    if (ctx3) {
      if (macroD2PieChartInstance) macroD2PieChartInstance.destroy();
      
      macroD2PieChartInstance = new Chart(ctx3, {
        type: 'pie',
        data: {
          labels: ['AM (6-9)', 'OP (10-15)', 'PM (16-18)', 'EV (Other)'],
          datasets: [{
            data: [d2AM, d2OP, d2PM, d2EV],
            backgroundColor: ['#ff9800', '#2196f3', '#f44336', '#9c27b0']
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          plugins: {
            legend: { position: 'bottom' }
          }
        }
      });
    }
    
    // Peak Hours Analysis
    const getPeakHours = (hourlyData) => {
      const indexed = hourlyData
        .map((val, idx) => ({ hour: idx, volume: Number(val) || 0 }))
        .filter(item => item.volume > 0);
      indexed.sort((a, b) => b.volume - a.volume);
      return indexed;
    };
    
    const d1Peaks = getPeakHours(gazData);
    const d2Peaks = getPeakHours(agData);
    
    const d1PeakEl = document.getElementById('macroD1PeakHours');
    if (d1PeakEl) {
      d1PeakEl.innerHTML = d1Peaks.length
        ? d1Peaks.map((p, i) => `<div><strong>${i + 1}.</strong> ${p.hour}:00-${p.hour + 1}:00 ‚Üí ${Math.round(p.volume).toLocaleString()} vph</div>`).join('')
        : '<div>No non-zero hourly profile available from source data.</div>';
    }
    
    const d2PeakEl = document.getElementById('macroD2PeakHours');
    if (d2PeakEl) {
      d2PeakEl.innerHTML = d2Peaks.length
        ? d2Peaks.map((p, i) => `<div><strong>${i + 1}.</strong> ${p.hour}:00-${p.hour + 1}:00 ‚Üí ${Math.round(p.volume).toLocaleString()} vph</div>`).join('')
        : '<div>No non-zero hourly profile available from source data.</div>';
    }
  }

  // ===== PRINT FUNCTIONALITY =====
  function printReport() {
    document.getElementById('printDate').textContent = new Date().toLocaleDateString('en-AU', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
    if (macroMapInstance) {
      if (selectedMacroSite && macroSitesData[selectedMacroSite]) {
        const site = macroSitesData[selectedMacroSite];
        const lat = Number(site.latitude);
        const lon = Number(site.longitude);
        if (Number.isFinite(lat) && Number.isFinite(lon)) {
          macroMapInstance.setView([lat, lon], Math.max(macroMapInstance.getZoom(), 17));
        }
      }
      macroMapInstance.invalidateSize();
    }

    setTimeout(() => window.print(), 250);
  }

  function updateAssumptionsPanel(siteData) {
    const site = siteData || (selectedMacroSite ? macroSitesData[selectedMacroSite] : null);
    const set = (id, value) => {
      const el = document.getElementById(id);
      if (el) el.textContent = value;
    };

    const dtcaYes = txt('DTCA').toUpperCase() === 'YES';
    const dhvpaYes = txt('DHVPA').toUpperCase() === 'YES';
    const drtpaYes = txt('DRTPA').toUpperCase() === 'YES';
    const hasDbHv = !!(site && Number(site.hv_percent) > 0);
    const hasDbGrowth = !!(site && Number(site.growth_rate) > 0);
    const hasDbLanes = !!(site && Number(site.d1_lanes) > 0 && Number(site.d2_lanes) > 0);
    const d1Hourly = site && site.directions_weekday && Array.isArray(site.directions_weekday['GAZETTAL'])
      ? site.directions_weekday['GAZETTAL'].reduce((s, v) => s + (Number(v) || 0), 0)
      : 0;
    const d2Hourly = site && site.directions_weekday && Array.isArray(site.directions_weekday['AGAINST GAZETTAL'])
      ? site.directions_weekday['AGAINST GAZETTAL'].reduce((s, v) => s + (Number(v) || 0), 0)
      : 0;
    const hasSourceHourly = (d1Hourly + d2Hourly) > 0;

    set('assumptionDtca', dtcaYes ? 'Directional VADT path' : '50/50 split from total VADT');
    set('assumptionHvSource', dhvpaYes ? 'Directional HV% inputs' : (hasDbHv ? 'Database HV% shared' : 'User HV% shared'));
    set('assumptionRtSource', drtpaYes ? 'Directional RT% inputs' : 'Overall RT% shared');
    set('assumptionGrowthSource', hasDbGrowth ? 'Database growth rate' : 'User-entered growth rate');
    set('assumptionLaneSource', hasDbLanes ? 'Database lane counts' : 'User-entered lane counts');
    set('assumptionProfileSource', hasSourceHourly ? 'Source hourly profile' : 'Derived profile from daily VADT');
  }

  document.getElementById('macroSiteSearch').addEventListener('input', (e) => {
    const value = e.target.value.trim();
    if (value && macroSitesData[value]) {
      selectMacroSite(value);
    }
  });

  document.getElementById('macroSiteSearch').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      const value = e.target.value.trim();
      if (value && macroSitesData[value]) {
        selectMacroSite(value);
        e.preventDefault();
      }
    }
  });

  const macroSourceFilterEl = document.getElementById('macroSourceFilter');
  if (macroSourceFilterEl) {
    macroSourceFilterEl.addEventListener('change', (e) => {
      macroSourceFilter = String((e.target && e.target.value) || 'ALL');
      const searchInput = document.getElementById('macroSiteSearch');
      if (searchInput) searchInput.value = '';
      populateMacroSitesDatalist();
      renderMacroMapSites();
    });
  }

  // Load sites on page load
  document.addEventListener('DOMContentLoaded', () => {
    const openingYearInput = document.getElementById('macroOpeningYear');
    if (openingYearInput) {
      openingYearInput.value = String(new Date().getFullYear());
    }
    initMacroMap();
    loadMacroSitesData();
    updateAssumptionsPanel();
  });

  // ===== EXISTING CALCULATION LOGIC =====

  const ids = [
    'RTR','DTCA','DHVPA','DRTPA','VADT','D1_VADT','D2_VADT','HVP','RTP','D1_HVP','D2_HVP','D1_RTP','D2_RTP','D1_Lanes','D2_Lanes',
    'macroOpeningYear','macroGrowthRate','macroTerrainType'
  ];
  function txt(id){
    const el = document.getElementById(id);
    return String((el && el.value) || '').trim();
  }
  function num(id){
    const el = document.getElementById(id);
    return Number((el && el.value) || 0) || 0;
  }
  function numberRoundUp(n, digits=0){
    const m = Math.pow(10,digits);
    return Math.ceil(((Number(n)||0) * m) - 1e-12) / m;
  }
  function ceilingVBA(n, sig){
    if (!sig) return 0;
    return Math.ceil((Number(n)||0)/sig)*sig;
  }

  function applyYesNoColor(selectId){
    const el = document.getElementById(selectId);
    if (!el) return;
    el.classList.remove('status-yes','status-no');
    if (el.value === 'Yes') el.classList.add('status-yes');
    if (el.value === 'No') el.classList.add('status-no');
  }

  function syncVisibility(){
    const shouldHideDirectional = txt('DTCA') !== 'Yes';
    const wrap = document.getElementById('dirVadtWrap');
    if (wrap) {
      wrap.classList.toggle('hidden', shouldHideDirectional);
      return;
    }

    const d1Card = (document.getElementById('D1_VADT') || {}).closest ? document.getElementById('D1_VADT').closest('div[style]') : null;
    const d2Card = (document.getElementById('D2_VADT') || {}).closest ? document.getElementById('D2_VADT').closest('div[style]') : null;
    [d1Card, d2Card].forEach(card => {
      if (card && card.classList) card.classList.toggle('hidden', shouldHideDirectional);
    });
  }

  function syncDirectionalRtFromOverall() {
    const rtrYes = txt('RTR').toUpperCase() === 'YES';
    const drtpaNo = txt('DRTPA').toUpperCase() === 'NO';
    if (!rtrYes || !drtpaNo) return;

    const rtp = num('RTP');
    const d1 = document.getElementById('D1_RTP');
    const d2 = document.getElementById('D2_RTP');
    if (d1) d1.value = String(rtp);
    if (d2) d2.value = String(rtp);
  }

  function getHVPercent(direction){
    const dhvpa = txt('DHVPA').toUpperCase();
    if (dhvpa === 'YES') return numberRoundUp(num(`D${direction}_HVP`) / 100, 12);
    return numberRoundUp((num('HVP') / 2) / 100, 12);
  }

  function getRTPercent(direction){
    const drtpa = txt('DRTPA').toUpperCase();
    if (drtpa === 'YES') return numberRoundUp(num(`D${direction}_RTP`) / 100, 12);
    return numberRoundUp((num('RTP') / 2) / 100, 12);
  }

  function baseDirectionalVolume(direction){
    const dtca = txt('DTCA').toUpperCase();
    const vadt = num('VADT');
    if (dtca === 'YES') return num(`D${direction}_VADT`) * 0.12 * 0.8;
    return vadt * 0.12 * 0.8 * 0.5;
  }

  function calcDirection(direction){
    const lanes = Math.max(1, num(`D${direction}_Lanes`));

    const peakHV = numberRoundUp(baseDirectionalVolume(direction) * getHVPercent(direction), 0);
    const peakRT = numberRoundUp(baseDirectionalVolume(direction) * getRTPercent(direction), 0);
    const peakLV = numberRoundUp(baseDirectionalVolume(direction) - peakHV - peakRT, 0);

    const offLV = numberRoundUp(peakLV * 0.42, 0);
    const offHV = numberRoundUp(peakHV * 0.42, 0);
    const offRT = numberRoundUp(peakRT * 0.42, 0);

    const peakLVPL = numberRoundUp(peakLV / lanes, 0);
    const peakHVPL = numberRoundUp(peakHV / lanes, 0);
    const peakRTPL = numberRoundUp(peakRT / lanes, 0);

    const offLVPL = numberRoundUp(offLV / lanes, 0);
    const offHVPL = numberRoundUp(offHV / lanes, 0);
    const offRTPL = numberRoundUp(offRT / lanes, 0);

    const lv5mp = numberRoundUp(peakLVPL * 5 / 60, 0);
    const hv5mp = numberRoundUp(peakHVPL * 5 / 60, 0);
    const rt5mp = numberRoundUp(peakRTPL * 5 / 60, 0);

    const lv5mop = numberRoundUp(offLVPL * 5 / 60, 0);
    const hv5mop = numberRoundUp(offHVPL * 5 / 60, 0);
    const rt5mop = numberRoundUp(offRTPL * 5 / 60, 0);

    let q2qp = lv5mp*2.4 + hv5mp*8 + rt5mp*25.2;
    let q5qp = lv5mp*6 + hv5mp*20 + rt5mp*63;
    let q2qop = lv5mop*2.4 + hv5mop*8 + rt5mop*25.2;
    let q5qop = lv5mop*6 + hv5mop*20 + rt5mop*63;

    const rtr = txt('RTR').toUpperCase();
    const roadTrainFactor = rtr === 'YES' ? 1.5 : 1;
    const minQ = rtr === 'YES' ? 89 : 26;
    q2qp = q2qp * roadTrainFactor;
    q5qp = q5qp * roadTrainFactor;
    q2qop = q2qop * roadTrainFactor;
    q5qop = q5qop * roadTrainFactor;
    q2qp = q2qp < minQ ? minQ : q2qp;
    q5qp = q5qp < minQ ? minQ : q5qp;
    q2qop = q2qop < minQ ? minQ : q2qop;
    q5qop = q5qop < minQ ? minQ : q5qop;

    q2qp = ceilingVBA(q2qp, 5);
    q5qp = ceilingVBA(q5qp, 5);
    q2qop = ceilingVBA(q2qop, 5);
    q5qop = ceilingVBA(q5qop, 5);

    return {
      lanes,
      peakLV, peakHV, peakRT,
      offLV, offHV, offRT,
      peakLVPL, peakHVPL, peakRTPL,
      offLVPL, offHVPL, offRTPL,
      lv5mp, hv5mp, rt5mp,
      lv5mop, hv5mop, rt5mop,
      q2qp, q2qop, q5qp, q5qop
    };
  }

  function calculateDV(){
    const totalLanes = Math.max(1, num('D1_Lanes') + num('D2_Lanes'));
    let dv = num('VADT') * 0.12 / totalLanes;
    if (dv < 500) dv = 500;
    return numberRoundUp(dv, 0);
  }

  function vcrColor(v){
    if (v === null || Number.isNaN(v) || v < 0) return '';
    if (v <= 0.6) return '#00eb00';
    if (v <= 0.7) return '#add8e6';
    if (v <= 0.9) return '#ffff00';
    if (v <= 0.95) return '#ffc896';
    if (v <= 1.0) return '#ffc000';
    return '#c00000';
  }

  function fmtVcr(v){ return (v === null || Number.isNaN(v) || v < 0) ? 'N/A' : v.toFixed(3); }
  function losLabel(v){
    if (v === null || Number.isNaN(v) || v < 0) return 'N/A';
    if (v <= 0.60) return 'LOS A';
    if (v <= 0.70) return 'LOS B';
    if (v <= 0.90) return 'LOS C';
    if (v <= 0.95) return 'LOS D';
    if (v <= 1.00) return 'LOS E';
    return 'LOS F';
  }

  function setVcrCell(td, value){
    td.textContent = fmtVcr(value);
    td.style.background = vcrColor(value);
    td.style.fontWeight = '700';
  }

  function setVcrLosCell(td, value){
    td.textContent = `${fmtVcr(value)} (${losLabel(value)})`;
    td.style.background = vcrColor(value);
    td.style.fontWeight = '700';
  }

  let vcrChartD1Instance = null;
  let vcrChartD2Instance = null;
  let lastVcrChartData = null;

  function setVcrView(mode) {
    const tableView = document.getElementById('vcrTableView');
    const chartView = document.getElementById('vcrChartView');
    const showChart = mode === 'chart';

    if (tableView) tableView.style.display = showChart ? 'none' : 'block';
    if (chartView) chartView.style.display = showChart ? 'block' : 'none';

    const tableBtns = document.querySelectorAll('.vcr-toggle-btn[data-view="table"]');
    const chartBtns = document.querySelectorAll('.vcr-toggle-btn[data-view="chart"]');

    tableBtns.forEach(btn => {
      btn.style.background = showChart ? '#f5f5f5' : '#e3f2fd';
      btn.style.color = showChart ? '#37474f' : '#0d47a1';
    });
    chartBtns.forEach(btn => {
      btn.style.background = showChart ? '#e3f2fd' : '#f5f5f5';
      btn.style.color = showChart ? '#0d47a1' : '#37474f';
    });

    if (showChart && lastVcrChartData) {
      renderVcrCharts(lastVcrChartData);
    }
  }

  function renderVcrCharts({ labels, baseD1, slcD1, slrf, baseD2, slcD2, d1Label, d2Label }) {
    const buildSeries = (values) => labels.map(k => Number.isFinite(values[k]) ? Number(values[k]) : null);
    const datasetsFor = (base, slc) => ([
      {
        label: 'Base VCR',
        data: buildSeries(base),
        borderColor: '#1e88e5',
        backgroundColor: 'rgba(30,136,229,0.25)',
        tension: 0.2,
        spanGaps: true
      },
      {
        label: 'Single Lane Closure',
        data: buildSeries(slc),
        borderColor: '#fb8c00',
        backgroundColor: 'rgba(251,140,0,0.25)',
        tension: 0.2,
        spanGaps: true
      },
      {
        label: 'Single Lane Reversible Flow',
        data: buildSeries(slrf),
        borderColor: '#00897b',
        backgroundColor: 'rgba(0,137,123,0.25)',
        tension: 0.2,
        spanGaps: true
      }
    ]);

    const baseOptions = {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          suggestedMax: 1.2,
          ticks: { callback: (v) => Number(v).toFixed(2) }
        }
      },
      plugins: {
        legend: { position: 'bottom' },
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const value = ctx.parsed.y;
              if (!Number.isFinite(value)) return `${ctx.dataset.label}: N/A`;
              return `${ctx.dataset.label}: ${value.toFixed(3)} (${losLabel(value)})`;
            }
          }
        }
      }
    };

    const ctxD2 = document.getElementById('vcrChartD2');
    if (ctxD2) {
      if (vcrChartD2Instance) vcrChartD2Instance.destroy();
      vcrChartD2Instance = new Chart(ctxD2, {
        type: 'line',
        data: { labels, datasets: datasetsFor(baseD2, slcD2) },
        options: { ...baseOptions, plugins: { ...baseOptions.plugins, title: { display: false, text: d2Label } } }
      });
    }

    const ctxD1 = document.getElementById('vcrChartD1');
    if (ctxD1) {
      if (vcrChartD1Instance) vcrChartD1Instance.destroy();
      vcrChartD1Instance = new Chart(ctxD1, {
        type: 'line',
        data: { labels, datasets: datasetsFor(baseD1, slcD1) },
        options: { ...baseOptions, plugins: { ...baseOptions.plugins, title: { display: false, text: d1Label } } }
      });
    }
  }

  const periods = [
    { key: 'AM', hours: [6, 7, 8, 9] },
    { key: 'OP', hours: [10, 11, 12, 13, 14, 15] },
    { key: 'PM', hours: [16, 17, 18] },
    { key: 'EV', hours: [0, 1, 2, 3, 4, 5, 19, 20, 21, 22, 23] }
  ];

  function queueFromFiveMinute(total5, hvPct, rtPct, isRtr){
    const hv = total5 * hvPct;
    const rt = total5 * rtPct;
    const lv = Math.max(0, total5 - hv - rt);

    let q2 = (lv * 2.4) + (hv * 8) + (rt * 25.2);
    let q5 = (lv * 6) + (hv * 20) + (rt * 63);
    let q10 = (lv * 12) + (hv * 40) + (rt * 126);
    let q15 = (lv * 18) + (hv * 60) + (rt * 189);

    const factor = isRtr ? 1.5 : 1;
    const minQ = isRtr ? 89 : 26;

    q2 = Math.max(q2 * factor, minQ);
    q5 = Math.max(q5 * factor, minQ);
    q10 = Math.max(q10 * factor, minQ);
    q15 = Math.max(q15 * factor, minQ);

    return {
      q2: ceilingVBA(q2, 5),
      q5: ceilingVBA(q5, 5),
      q10: ceilingVBA(q10, 5),
      q15: ceilingVBA(q15, 5)
    };
  }

  function buildPeriodProfile(direction, dailyTotal, hvPct, rtPct, laneCount, rtrYes){
    const profile = {};
    const site = selectedMacroSite ? macroSitesData[selectedMacroSite] : null;
    const directionKey = direction === 1 ? 'GAZETTAL' : 'AGAINST GAZETTAL';
    const hourly = site && site.directions_weekday && Array.isArray(site.directions_weekday[directionKey])
      ? site.directions_weekday[directionKey]
      : null;

    const fallbackShares = { AM: 0.2, OP: 0.4, PM: 0.2, EV: 0.2 };
    const baseByPeriod = { AM: 0, OP: 0, PM: 0, EV: 0 };

    const hourlyTotal = hourly
      ? hourly.reduce((sum, value) => sum + (Number(value) || 0), 0)
      : 0;

    if (hourly && hourlyTotal > 0) {
      periods.forEach(period => {
        baseByPeriod[period.key] = period.hours.reduce((sum, hour) => sum + (Number(hourly[hour]) || 0), 0);
      });
    } else {
      periods.forEach(period => {
        baseByPeriod[period.key] = (Number(dailyTotal) || 0) * fallbackShares[period.key];
      });
    }

    const baseTotal = periods.reduce((sum, period) => sum + baseByPeriod[period.key], 0);
    const scale = baseTotal > 0 ? (Number(dailyTotal) || 0) / baseTotal : 1;

    const allocateByWeights = (totalUnits, weights) => {
      const safeTotal = Math.max(0, Math.round(Number(totalUnits) || 0));
      const positiveWeights = weights.map(w => Math.max(0, Number(w) || 0));
      const weightSum = positiveWeights.reduce((sum, value) => sum + value, 0);
      if (safeTotal === 0) return new Array(weights.length).fill(0);

      if (weightSum <= 0) {
        const equal = Math.floor(safeTotal / weights.length);
        const out = new Array(weights.length).fill(equal);
        let remainder = safeTotal - (equal * weights.length);
        for (let i = 0; i < out.length && remainder > 0; i += 1) {
          out[i] += 1;
          remainder -= 1;
        }
        return out;
      }

      const raw = positiveWeights.map(w => (safeTotal * w) / weightSum);
      const base = raw.map(v => Math.floor(v));
      let remainder = safeTotal - base.reduce((sum, value) => sum + value, 0);

      const order = raw
        .map((v, idx) => ({ idx, frac: v - Math.floor(v) }))
        .sort((a, b) => b.frac - a.frac);

      let pos = 0;
      while (remainder > 0 && order.length > 0) {
        base[order[pos % order.length].idx] += 1;
        remainder -= 1;
        pos += 1;
      }

      return base;
    };

    const rawPeriodTotals = periods.map(period => Math.max(0, baseByPeriod[period.key] * scale));
    const dailyTotalInt = Math.max(0, Math.round(Number(dailyTotal) || 0));
    const periodTotals = allocateByWeights(dailyTotalInt, rawPeriodTotals);
    const hvTotal = Math.round(dailyTotalInt * Math.max(0, Number(hvPct) || 0));
    const rtTotal = Math.round(dailyTotalInt * Math.max(0, Number(rtPct) || 0));
    const hvByPeriod = allocateByWeights(hvTotal, periodTotals);
    const rtByPeriod = allocateByWeights(rtTotal, periodTotals);

    periods.forEach((period, idx) => {
      const total = periodTotals[idx];
      let hv = hvByPeriod[idx];
      let rt = rtByPeriod[idx];

      if (hv + rt > total) {
        const overflow = (hv + rt) - total;
        if (rt >= overflow) rt -= overflow;
        else {
          const remaining = overflow - rt;
          rt = 0;
          hv = Math.max(0, hv - remaining);
        }
      }

      const lv = Math.max(0, total - hv - rt);
      const hoursCount = period.hours.length;
      const hourlyAvg = hoursCount > 0 ? total / hoursCount : 0;
      const hourlyPerLane = laneCount > 0 ? hourlyAvg / laneCount : 0;
      const per5 = hourlyPerLane / 12;
      const queue = queueFromFiveMinute(per5, hvPct, rtPct, rtrYes);

      profile[period.key] = { total, lv, hv, rt, hourlyPerLane, per5, queue };
    });

    return profile;
  }

  function tableToText(table){
    if (!table) return '';
    const rows = table.querySelectorAll('tr');
    const lines = [];

    rows.forEach(row => {
      const cells = row.querySelectorAll('th, td');
      const values = Array.from(cells).map(cell =>
        (cell.textContent || '').replace(/\s+/g, ' ').trim()
      );
      lines.push(values.join('\t'));
    });

    return lines.join('\n');
  }

  function tableToHtml(table){
    if (!table) return '';
    return table.outerHTML;
  }

  async function copyTableById(tableId, button){
    const table = document.getElementById(tableId);
    if (!table) return;

    const text = tableToText(table);
    const html = tableToHtml(table);
    if (!text && !html) return;

    const original = button ? button.textContent : '';
    try {
      if (navigator.clipboard && window.ClipboardItem && html) {
        const data = {
          'text/html': new Blob([html], { type: 'text/html' }),
          'text/plain': new Blob([text || ''], { type: 'text/plain' })
        };
        await navigator.clipboard.write([new ClipboardItem(data)]);
      } else {
        await navigator.clipboard.writeText(text);
      }
      if (button) {
        button.textContent = 'Copied';
        setTimeout(() => { button.textContent = original; }, 1100);
      }
    } catch (_error) {
      if (html && navigator.clipboard && window.ClipboardItem) {
        try {
          await navigator.clipboard.write([new ClipboardItem({
            'text/html': new Blob([html], { type: 'text/html' }),
            'text/plain': new Blob([text || ''], { type: 'text/plain' })
          })]);
        } catch (_innerErr) {
          const ta = document.createElement('textarea');
          ta.value = text;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          document.body.removeChild(ta);
        }
      } else {
        const ta = document.createElement('textarea');
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
      }
      if (button) {
        button.textContent = 'Copied';
        setTimeout(() => { button.textContent = original; }, 1100);
      }
    }
  }

  function setupTableCopyButtons(){
    const tables = document.querySelectorAll('table[id]');
    tables.forEach(table => {
      const tableId = table.id;
      const wrapper = table.closest('.table-wrap');
      const host = wrapper || table.parentElement;
      if (!host) return;

      const existing = host.previousElementSibling;
      if (existing && existing.classList && existing.classList.contains('table-actions')) return;

      const actions = document.createElement('div');
      actions.className = 'table-actions';

      const copyBtn = document.createElement('button');
      copyBtn.type = 'button';
      copyBtn.className = 'copy-table-btn';
      copyBtn.textContent = 'Copy Table';
      copyBtn.addEventListener('click', () => copyTableById(tableId, copyBtn));

      actions.appendChild(copyBtn);
      if (tableId === 'vcrGroupedTableD1' || tableId === 'vcrGroupedTableD2') {
        const existingGroup = actions.querySelector('.vcr-toggle-group');
        if (!existingGroup) {
          const toggleGroup = document.createElement('div');
          toggleGroup.className = 'vcr-toggle-group';
          toggleGroup.style.cssText = 'display: inline-flex; gap: 6px; align-items: center; margin-left: 8px;';

          const tableBtn = document.createElement('button');
          tableBtn.type = 'button';
          tableBtn.className = 'vcr-toggle-btn';
          tableBtn.dataset.view = 'table';
          tableBtn.textContent = 'Table';
          tableBtn.style.cssText = 'padding: 6px 10px; border-radius: 4px; border: 1px solid #c7d4db; background: #e3f2fd; color: #0d47a1; cursor: pointer; font-weight: 600;';
          tableBtn.addEventListener('click', () => setVcrView('table'));

          const chartBtn = document.createElement('button');
          chartBtn.type = 'button';
          chartBtn.className = 'vcr-toggle-btn';
          chartBtn.dataset.view = 'chart';
          chartBtn.textContent = 'Chart';
          chartBtn.style.cssText = 'padding: 6px 10px; border-radius: 4px; border: 1px solid #c7d4db; background: #f5f5f5; color: #37474f; cursor: pointer; font-weight: 600;';
          chartBtn.addEventListener('click', () => setVcrView('chart'));

          toggleGroup.appendChild(tableBtn);
          toggleGroup.appendChild(chartBtn);
          actions.appendChild(toggleGroup);
        }
      }
      host.parentNode.insertBefore(actions, host);
    });
  }

  function maxValid(values){
    const nums = values.filter(v => Number.isFinite(v) && v >= 0);
    return nums.length ? Math.max(...nums) : null;
  }

  function updateSummaryKpis({ dv, d1, d2, rtr, slrfPeak, worstVcr }){
    const set = (id, value) => {
      const el = document.getElementById(id);
      if (el) el.textContent = value;
      return el;
    };

    set('kpiDV', `${dv}`);
    set('kpiD1PeakQueue', `${d1.q2qp} m`);
    set('kpiD2PeakQueue', `${d2.q2qp} m`);
    set('kpiRoadTrain', rtr === 'YES' ? 'Active' : 'Inactive');

    const slrfText = (slrfPeak === null || Number.isNaN(slrfPeak) || slrfPeak < 0) ? 'N/A' : slrfPeak.toFixed(3);
    const slrfEl = set('kpiSlrfPeak', slrfText);
    const worstText = (worstVcr === null || Number.isNaN(worstVcr) || worstVcr < 0) ? 'N/A' : worstVcr.toFixed(3);
    const worstEl = set('kpiWorstVcr', worstText);

    if (worstEl) {
      worstEl.style.background = vcrColor(worstVcr);
      worstEl.style.color = '#1c1c1c';
      worstEl.style.borderRadius = '6px';
      worstEl.style.padding = '2px 6px';
      worstEl.style.display = 'inline-block';
    }
    if (slrfEl) {
      slrfEl.style.background = vcrColor(slrfPeak);
      slrfEl.style.color = '#1c1c1c';
      slrfEl.style.borderRadius = '6px';
      slrfEl.style.padding = '2px 6px';
      slrfEl.style.display = 'inline-block';
    }
  }

  function calculateAll(){
    syncVisibility();
    syncDirectionalRtFromOverall();
    ['RTR','DTCA','DHVPA','DRTPA'].forEach(applyYesNoColor);
    updateAssumptionsPanel();

    const d1 = calcDirection(1);
    const d2 = calcDirection(2);
    const dv = calculateDV();
    
    // Get direction labels from selected site
    const d1Label = (selectedMacroSite && macroSitesData[selectedMacroSite]) ? macroSitesData[selectedMacroSite].d1_direction_label : 'Gazettal (D1)';
    const d2Label = (selectedMacroSite && macroSitesData[selectedMacroSite]) ? macroSitesData[selectedMacroSite].d2_direction_label : 'Against Gazettal (D2)';
    const dtca = txt('DTCA').toUpperCase();
    const dhvpa = txt('DHVPA').toUpperCase();
    const drtpa = txt('DRTPA').toUpperCase();
    const rtr = txt('RTR').toUpperCase();

    const d1Daily = dtca === 'YES' ? num('D1_VADT') : num('VADT') / 2;
    const d2Daily = dtca === 'YES' ? num('D2_VADT') : num('VADT') / 2;
    const d1Profile = buildPeriodProfile(1, d1Daily, getHVPercent(1), getRTPercent(1), d1.lanes, rtr === 'YES');
    const d2Profile = buildPeriodProfile(2, d2Daily, getHVPercent(2), getRTPercent(2), d2.lanes, rtr === 'YES');

    const base1Peak = (d1.peakLVPL + d1.peakHVPL + d1.peakRTPL) / dv;
    const base1Off  = (d1.offLVPL + d1.offHVPL + d1.offRTPL) / dv;
    const base2Peak = (d2.peakLVPL + d2.peakHVPL + d2.peakRTPL) / dv;
    const base2Off  = (d2.offLVPL + d2.offHVPL + d2.offRTPL) / dv;

    let slc1Peak = null, slc1Off = null, slc2Peak = null, slc2Off = null;
    if (d1.lanes === 2) {
      slc1Peak = ((d1.peakLVPL + d1.peakHVPL + d1.peakRTPL) * 2) / dv;
      slc1Off = ((d1.offLVPL + d1.offHVPL + d1.offRTPL) * 2) / dv;
    } else if (d1.lanes > 2) {
      slc1Peak = (((d1.peakLVPL + d1.peakHVPL + d1.peakRTPL) * d1.lanes) / (d1.lanes - 1)) / dv;
      slc1Off = (((d1.offLVPL + d1.offHVPL + d1.offRTPL) * d1.lanes) / (d1.lanes - 1)) / dv;
    }

    if (d2.lanes === 2) {
      slc2Peak = ((d2.peakLVPL + d2.peakHVPL + d2.peakRTPL) * 2) / dv;
      slc2Off = ((d2.offLVPL + d2.offHVPL + d2.offRTPL) * 2) / dv;
    } else if (d2.lanes > 2) {
      slc2Peak = (((d2.peakLVPL + d2.peakHVPL + d2.peakRTPL) * d2.lanes) / (d2.lanes - 1)) / dv;
      slc2Off = (((d2.offLVPL + d2.offHVPL + d2.offRTPL) * d2.lanes) / (d2.lanes - 1)) / dv;
    }

    let slrfPeak = null, slrfOff = null;
    if (d1.lanes === 1 && d2.lanes === 1) {
      slrfPeak = (d1.peakLVPL + d1.peakHVPL + d1.peakRTPL + d2.peakLVPL + d2.peakHVPL + d2.peakRTPL) / dv;
      slrfOff = (d1.offLVPL + d1.offHVPL + d1.offRTPL + d2.offLVPL + d2.offHVPL + d2.offRTPL) / dv;
    }

    // Update section headers with intelligent direction labels
    const setHeader = (id, emoji, label) => {
      const el = document.getElementById(id);
      if (el) el.innerHTML = `${emoji} ${label}`;
    };
    
    setHeader('groupedHeaderD2', 'üî¥', d2Label);
    setHeader('groupedHeaderD1', 'üü¢', d1Label);
    setHeader('queueHeaderD2', 'üî¥', d2Label);
    setHeader('queueHeaderD1', 'üü¢', d1Label);
    setHeader('vcrHeaderD2', 'üî¥', d2Label);
    setHeader('vcrHeaderD1', 'üü¢', d1Label);
    setHeader('vcrHeaderD2Chart', 'üî¥', d2Label);
    setHeader('vcrHeaderD1Chart', 'üü¢', d1Label);
    
    const groupedBodyD2 = document.getElementById('groupedBodyD2');
    if (groupedBodyD2) {
      groupedBodyD2.innerHTML = `
        <tr>
          <td class="rowhead">LV Volume</td>
          <td>${d2Profile.AM.lv.toLocaleString()}</td>
          <td>${d2Profile.OP.lv.toLocaleString()}</td>
          <td>${d2Profile.PM.lv.toLocaleString()}</td>
          <td>${d2Profile.EV.lv.toLocaleString()}</td>
          <td>${Math.round(d2Profile.AM.lv + d2Profile.OP.lv + d2Profile.PM.lv + d2Profile.EV.lv).toLocaleString()}</td>
        </tr>
        <tr>
          <td class="rowhead">HV Volume</td>
          <td>${d2Profile.AM.hv.toLocaleString()}</td>
          <td>${d2Profile.OP.hv.toLocaleString()}</td>
          <td>${d2Profile.PM.hv.toLocaleString()}</td>
          <td>${d2Profile.EV.hv.toLocaleString()}</td>
          <td>${Math.round(d2Profile.AM.hv + d2Profile.OP.hv + d2Profile.PM.hv + d2Profile.EV.hv).toLocaleString()}</td>
        </tr>
        <tr>
          <td class="rowhead">Hrly Avg / lane</td>
          <td>${Math.round(d2Profile.AM.hourlyPerLane).toLocaleString()}</td>
          <td>${Math.round(d2Profile.OP.hourlyPerLane).toLocaleString()}</td>
          <td>${Math.round(d2Profile.PM.hourlyPerLane).toLocaleString()}</td>
          <td>${Math.round(d2Profile.EV.hourlyPerLane).toLocaleString()}</td>
          <td>-</td>
        </tr>
      `;
    }

    const groupedBodyD1 = document.getElementById('groupedBodyD1');
    if (groupedBodyD1) {
      groupedBodyD1.innerHTML = `
        <tr>
          <td class="rowhead">LV Volume</td>
          <td>${d1Profile.AM.lv.toLocaleString()}</td>
          <td>${d1Profile.OP.lv.toLocaleString()}</td>
          <td>${d1Profile.PM.lv.toLocaleString()}</td>
          <td>${d1Profile.EV.lv.toLocaleString()}</td>
          <td>${Math.round(d1Profile.AM.lv + d1Profile.OP.lv + d1Profile.PM.lv + d1Profile.EV.lv).toLocaleString()}</td>
        </tr>
        <tr>
          <td class="rowhead">HV Volume</td>
          <td>${d1Profile.AM.hv.toLocaleString()}</td>
          <td>${d1Profile.OP.hv.toLocaleString()}</td>
          <td>${d1Profile.PM.hv.toLocaleString()}</td>
          <td>${d1Profile.EV.hv.toLocaleString()}</td>
          <td>${Math.round(d1Profile.AM.hv + d1Profile.OP.hv + d1Profile.PM.hv + d1Profile.EV.hv).toLocaleString()}</td>
        </tr>
        <tr>
          <td class="rowhead">Hrly Avg / lane</td>
          <td>${Math.round(d1Profile.AM.hourlyPerLane).toLocaleString()}</td>
          <td>${Math.round(d1Profile.OP.hourlyPerLane).toLocaleString()}</td>
          <td>${Math.round(d1Profile.PM.hourlyPerLane).toLocaleString()}</td>
          <td>${Math.round(d1Profile.EV.hourlyPerLane).toLocaleString()}</td>
          <td>-</td>
        </tr>
      `;
    }

    const queueGroupedBodyD2 = document.getElementById('queueGroupedBodyD2');
    if (queueGroupedBodyD2) {
      const queueRowsD2 = [
        { label: 'Per 2 minutes', values: ['AM','OP','PM','EV'].map(k => d2Profile[k].queue.q2) },
        { label: 'Per 5 minutes', values: ['AM','OP','PM','EV'].map(k => d2Profile[k].queue.q5) },
        { label: 'Per 10 minutes', values: ['AM','OP','PM','EV'].map(k => d2Profile[k].queue.q10) },
        { label: 'Per 15 minutes', values: ['AM','OP','PM','EV'].map(k => d2Profile[k].queue.q15) }
      ];

      queueGroupedBodyD2.innerHTML = queueRowsD2.map(row => {
        const maxQueue = Math.max(...row.values);
        return `
          <tr>
            <td class="rowhead">${row.label} Length (m)</td>
            <td>${Math.round(row.values[0]).toLocaleString()}</td>
            <td>${Math.round(row.values[1]).toLocaleString()}</td>
            <td>${Math.round(row.values[2]).toLocaleString()}</td>
            <td>${Math.round(row.values[3]).toLocaleString()}</td>
            <td><strong>${Math.round(maxQueue).toLocaleString()}</strong></td>
          </tr>
        `;
      }).join('');
    }

    const queueGroupedBodyD1 = document.getElementById('queueGroupedBodyD1');
    if (queueGroupedBodyD1) {
      const queueRowsD1 = [
        { label: 'Per 2 minutes', values: ['AM','OP','PM','EV'].map(k => d1Profile[k].queue.q2) },
        { label: 'Per 5 minutes', values: ['AM','OP','PM','EV'].map(k => d1Profile[k].queue.q5) },
        { label: 'Per 10 minutes', values: ['AM','OP','PM','EV'].map(k => d1Profile[k].queue.q10) },
        { label: 'Per 15 minutes', values: ['AM','OP','PM','EV'].map(k => d1Profile[k].queue.q15) }
      ];

      queueGroupedBodyD1.innerHTML = queueRowsD1.map(row => {
        const maxQueue = Math.max(...row.values);
        return `
          <tr>
            <td class="rowhead">${row.label} Length (m)</td>
            <td>${Math.round(row.values[0]).toLocaleString()}</td>
            <td>${Math.round(row.values[1]).toLocaleString()}</td>
            <td>${Math.round(row.values[2]).toLocaleString()}</td>
            <td>${Math.round(row.values[3]).toLocaleString()}</td>
            <td><strong>${Math.round(maxQueue).toLocaleString()}</strong></td>
          </tr>
        `;
      }).join('');
    }

    const periodKeys = ['AM','OP','PM','EV'];
    const baseD1 = Object.fromEntries(periodKeys.map(k => [k, d1Profile[k].hourlyPerLane / dv]));
    const baseD2 = Object.fromEntries(periodKeys.map(k => [k, d2Profile[k].hourlyPerLane / dv]));

    const slcFromBase = (baseMap, laneCount) => {
      const out = {};
      periodKeys.forEach(k => {
        if (laneCount === 2) out[k] = baseMap[k] * 2;
        else if (laneCount > 2) out[k] = (baseMap[k] * laneCount) / (laneCount - 1);
        else out[k] = null;
      });
      return out;
    };

    const slcD1 = slcFromBase(baseD1, d1.lanes);
    const slcD2 = slcFromBase(baseD2, d2.lanes);
    const slrf = {};
    periodKeys.forEach(k => {
      if (d1.lanes === 1 && d2.lanes === 1) slrf[k] = (d1Profile[k].hourlyPerLane + d2Profile[k].hourlyPerLane) / dv;
      else slrf[k] = null;
    });

    const vcrGroupedBodyD2 = document.getElementById('vcrGroupedBodyD2');
    if (vcrGroupedBodyD2) {
      const rowsD2 = [
        { label: `Design Volume (Capacity) * = ${Math.round(dv).toLocaleString()}`, values: null },
        { label: 'Base VCR', values: baseD2 },
        { label: 'Single Lane Closure', values: slcD2 },
        { label: 'Single Lane Reversible Flow', values: slrf }
      ];

      vcrGroupedBodyD2.innerHTML = '';
      rowsD2.forEach(row => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td class="rowhead">${row.label}</td>
          <td class="vcr-cell"></td>
          <td class="vcr-cell"></td>
          <td class="vcr-cell"></td>
          <td class="vcr-cell"></td>
        `;
        const cells = tr.querySelectorAll('.vcr-cell');
        if (!row.values) {
          cells.forEach(cell => {
            cell.textContent = '-';
            cell.style.background = '#f4f3f0';
          });
        } else {
          setVcrLosCell(cells[0], row.values.AM);
          setVcrLosCell(cells[1], row.values.OP);
          setVcrLosCell(cells[2], row.values.PM);
          setVcrLosCell(cells[3], row.values.EV);
        }
        vcrGroupedBodyD2.appendChild(tr);
      });
    }

    const vcrGroupedBodyD1 = document.getElementById('vcrGroupedBodyD1');
    if (vcrGroupedBodyD1) {
      const rowsD1 = [
        { label: `Design Volume (Capacity) * = ${Math.round(dv).toLocaleString()}`, values: null },
        { label: 'Base VCR', values: baseD1 },
        { label: 'Single Lane Closure', values: slcD1 },
        { label: 'Single Lane Reversible Flow', values: slrf }
      ];

      vcrGroupedBodyD1.innerHTML = '';
      rowsD1.forEach(row => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td class="rowhead">${row.label}</td>
          <td class="vcr-cell"></td>
          <td class="vcr-cell"></td>
          <td class="vcr-cell"></td>
          <td class="vcr-cell"></td>
        `;
        const cells = tr.querySelectorAll('.vcr-cell');
        if (!row.values) {
          cells.forEach(cell => {
            cell.textContent = '-';
            cell.style.background = '#f4f3f0';
          });
        } else {
          setVcrLosCell(cells[0], row.values.AM);
          setVcrLosCell(cells[1], row.values.OP);
          setVcrLosCell(cells[2], row.values.PM);
          setVcrLosCell(cells[3], row.values.EV);
        }
        vcrGroupedBodyD1.appendChild(tr);
      });
    }

    lastVcrChartData = {
      labels: periodKeys,
      baseD1,
      slcD1,
      slrf,
      baseD2,
      slcD2,
      d1Label,
      d2Label
    };
    renderVcrCharts(lastVcrChartData);

    const worstVcr = maxValid([
      base1Peak, base1Off, base2Peak, base2Off,
      slc1Peak, slc1Off, slc2Peak, slc2Off,
      slrfPeak, slrfOff
    ]);

    updateSummaryKpis({ dv, d1, d2, rtr, slrfPeak, worstVcr });

    const traceRows = [
      ['DTCA Path', dtca === 'YES' ? 'Directional VADT (D1_VADT / D2_VADT)' : '50/50 split from VADT'],
      ['DHVPA Path', dhvpa === 'YES' ? 'Directional HV% (D1_HVP / D2_HVP)' : 'HVP/2 applied per direction'],
      ['DRTPA Path', drtpa === 'YES' ? 'Directional RT% (D1_RTP / D2_RTP)' : 'RTP/2 applied per direction'],
      ['RTR Queue Rule', rtr === 'YES' ? 'Road Train: queue √ó1.5, then min 89 m, then ceiling-to-5' : 'No Road Train: min 26 m, then ceiling-to-5'],
      ['DV Formula', `max(500, VADT√ó0.12/(D1_Lanes+D2_Lanes)) = ${dv}`],
      ['D1 Base Peak Volume', `VADT branch result = ${numberRoundUp(baseDirectionalVolume(1), 3)}`],
      ['D2 Base Peak Volume', `VADT branch result = ${numberRoundUp(baseDirectionalVolume(2), 3)}`],
      ['D1 HV% Used', `${numberRoundUp(getHVPercent(1) * 100, 3)}%`],
      ['D2 HV% Used', `${numberRoundUp(getHVPercent(2) * 100, 3)}%`],
      ['D1 RT% Used', `${numberRoundUp(getRTPercent(1) * 100, 3)}%`],
      ['D2 RT% Used', `${numberRoundUp(getRTPercent(2) * 100, 3)}%`],
      ['SLC Applied', 'Only when lane count is 2 or >2 per direction'],
      ['SLRF Applied', (d1.lanes === 1 && d2.lanes === 1) ? 'Yes (both directions single lane)' : 'No (requires D1=1 and D2=1 lanes)']
    ];

    const traceBody = document.getElementById('traceBody');
    if (traceBody) {
      traceBody.innerHTML = '';
      traceRows.forEach(([k,v]) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td class="rowhead">${k}</td><td>${v}</td>`;
        traceBody.appendChild(tr);
      });
    }
  }

  // Auto-calculation removed: user must click "Calculate All" button
  // ids.forEach(id => {
  //   const el = document.getElementById(id);
  //   if (!el) return;
  //   el.addEventListener('change', calculateAll);
  //   el.addEventListener('input', calculateAll);
  // });

  ['RTR', 'DRTPA', 'RTP'].forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('change', syncDirectionalRtFromOverall);
    el.addEventListener('input', syncDirectionalRtFromOverall);
  });

  ['DTCA', 'DHVPA', 'DRTPA', 'HVP', 'D1_HVP', 'D2_HVP', 'RTP', 'D1_RTP', 'D2_RTP', 'D1_Lanes', 'D2_Lanes', 'macroGrowthRate'].forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('change', () => updateAssumptionsPanel());
    el.addEventListener('input', () => updateAssumptionsPanel());
  });

  const calcBtn = document.getElementById('calcBtn');
  if (calcBtn) {
    calcBtn.addEventListener('click', calculateAll);
  }
  setupTableCopyButtons();
  setVcrView('table');
  // Initial calculation removed: calculateAll();

  // ===== TIA ANALYSIS TOOL FUNCTIONS =====
  
  // Haversine distance calculation (meters)
  function haversineDistance(lat1, lon1, lat2, lon2) {
    const R = 6371000; // Earth radius in meters
    const œÜ1 = lat1 * Math.PI / 180;
    const œÜ2 = lat2 * Math.PI / 180;
    const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
    const ŒîŒª = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
              Math.cos(œÜ1) * Math.cos(œÜ2) *
              Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  // Find best matching site (exact road match or closest distance)
  function findBestMatchSite(searchTerm) {
    const searchLower = searchTerm.toLowerCase().trim();
    const sites = Object.entries(macroSitesData);
    
    // First, try exact road name match
    const roadMatches = sites.filter(([, data]) => 
      data.road_name && data.road_name.toLowerCase().includes(searchLower)
    );
    
    if (roadMatches.length > 0) {
      return { sites: roadMatches, matchType: 'exact_road' };
    }
    
    // Try description/suburb match
    const descMatches = sites.filter(([, data]) => 
      (data.description && data.description.toLowerCase().includes(searchLower)) ||
      (data.source && data.source.toLowerCase().includes(searchLower))
    );
    
    if (descMatches.length > 0) {
      return { sites: descMatches, matchType: 'description' };
    }
    
    // Return closest 3 sites as fallback
    if (sites.length > 0) {
      return { sites: sites.slice(0, 3), matchType: 'nearby' };
    }
    
    return null;
  }

  // Queue modeling using M/M/c (Erlang C)
  function calculateQueueMetrics(peakVolume, lanes, serviceDuration = 2.5) {
    const serviceRate = 3600 / serviceDuration; // vehicles per hour per lane
    const rho = peakVolume / (lanes * serviceRate); // utilization
    
    if (rho >= 1.0) {
      return {
        avgQueue: Infinity,
        p95Queue: Infinity,
        los: 'F',
        capacity: peakVolume + (peakVolume * 0.1)
      };
    }
    
    // Erlang C formula for average queue
    const erlangNum = Math.pow(rho * lanes, lanes) / factorial(lanes) * (1 / (1 - rho));
    const erlangDen = (Math.pow(rho * lanes, lanes) / factorial(lanes) * (1 / (1 - rho))) + 
                      (1 - rho) * sum(Array.from({length: lanes}, (_, n) => 
                        Math.pow(rho * lanes, n) / factorial(n)));
    const pw = erlangNum / erlangDen; // Probability of waiting
    
    // Average queue length (vehicles waiting)
    const avgQueue = (pw * rho) / (1 - rho) * lanes;
    
    // 95th percentile queue
    const p95Queue = avgQueue + Math.sqrt(avgQueue * 2);
    
    // Level of Service based on utilization
    let los = 'A';
    if (rho >= 0.85) los = 'E';
    else if (rho >= 0.70) los = 'D';
    else if (rho >= 0.50) los = 'C';
    else if (rho >= 0.30) los = 'B';
    
    return {
      avgQueue: Math.round(avgQueue * 10) / 10,
      p95Queue: Math.round(p95Queue * 10) / 10,
      los: los,
      utilization: Math.round(rho * 1000) / 10
    };
  }

  // Helper: Factorial
  function factorial(n) {
    if (n <= 1) return 1;
    let result = 1;
    for (let i = 2; i <= n; i++) result *= i;
    return result;
  }

  // Helper: Sum array
  function sum(arr) {
    return arr.reduce((a, b) => a + b, 0);
  }

  // Main TIA search function
  function performTIASearch() {
    const searchInput = document.getElementById('tiaSearchInput').value.trim();
    if (!searchInput) {
      alert('Please enter a road name or location');
      return;
    }

    const matchResult = findBestMatchSite(searchInput);
    if (!matchResult || !matchResult.sites.length) {
      document.getElementById('tiaResultsPanel').style.display = 'none';
      document.getElementById('tiaNoResultsPanel').style.display = 'block';
      return;
    }

    // Use the first matched site
    const [siteId, siteData] = matchResult.sites[0];
    const d1Lanes = siteData.d1_lanes || 1;
    const d2Lanes = siteData.d2_lanes || 1;
    
    // Calculate peak hour volumes (assume 9% of VADT occurs in peak hour)
    const peakHourPercent = 0.09;
    const d1PeakAM = Math.round(siteData.d1_vadt * peakHourPercent);
    const d2PeakAM = Math.round(siteData.d2_vadt * peakHourPercent);
    const d1PeakPM = d1PeakAM;
    const d2PeakPM = d2PeakAM;

    // Calculate queue metrics
    const d1Queue = calculateQueueMetrics(d1PeakAM, d1Lanes);
    const d2Queue = calculateQueueMetrics(d2PeakAM, d2Lanes);

    // Display source info
    document.getElementById('tiaSourceType').textContent = matchResult.matchType === 'exact_road' ? '‚úì Exact Road Match' : 
                                                           matchResult.matchType === 'description' ? '‚äô Location Match' : 
                                                           '‚äó Nearby Reference';
    document.getElementById('tiaSourceRoad').textContent = siteData.road_name || siteData.description || siteId;
    document.getElementById('tiaSourceDistance').textContent = matchResult.matchType === 'exact_road' ? 'Same Road' : 'Reference data';
    document.getElementById('tiaSourceVADT').textContent = siteData.vadt.toLocaleString() + ' vehicles/day';

    // Display peak hour info
    document.getElementById('tiaPeakAMD1').textContent = d1PeakAM;
    document.getElementById('tiaPeakAMD2').textContent = d2PeakAM;
    document.getElementById('tiaPeakPMD1').textContent = d1PeakPM;
    document.getElementById('tiaPeakPMD2').textContent = d2PeakPM;

    // Display queue results
    document.getElementById('tiaD1Lanes').textContent = d1Lanes;
    document.getElementById('tiaD1AvgQueue').textContent = isFinite(d1Queue.avgQueue) ? d1Queue.avgQueue.toFixed(1) : 'Breakdown';
    document.getElementById('tiaD1P95Queue').textContent = isFinite(d1Queue.p95Queue) ? d1Queue.p95Queue.toFixed(0) : 'Breakdown';
    document.getElementById('tiaD1LOS').textContent = d1Queue.los;
    document.getElementById('tiaD1Util').textContent = d1Queue.utilization.toFixed(1);

    document.getElementById('tiaD2Lanes').textContent = d2Lanes;
    document.getElementById('tiaD2AvgQueue').textContent = isFinite(d2Queue.avgQueue) ? d2Queue.avgQueue.toFixed(1) : 'Breakdown';
    document.getElementById('tiaD2P95Queue').textContent = isFinite(d2Queue.p95Queue) ? d2Queue.p95Queue.toFixed(0) : 'Breakdown';
    document.getElementById('tiaD2LOS').textContent = d2Queue.los;
    document.getElementById('tiaD2Util').textContent = d2Queue.utilization.toFixed(1);

    // Update note
    const note = matchResult.matchType === 'exact_road' ? 
                 '‚úì Data sourced from exact road match: ' + siteData.source :
                 matchResult.matchType === 'description' ?
                 '‚äô Data interpolated from nearby location match' :
                 '! Using nearest reference site for estimate';
    document.getElementById('tiaMatchNote').textContent = note;

    document.getElementById('tiaNoResultsPanel').style.display = 'none';
    document.getElementById('tiaResultsPanel').style.display = 'block';
  }

  // Allow Enter key to trigger search
  const tiaSearchInputEl = document.getElementById('tiaSearchInput');
  if (tiaSearchInputEl) {
    tiaSearchInputEl.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') performTIASearch();
    });
  }

  // ===== QUICK TIA SEARCH FUNCTIONS =====
  
  function normalizeRoadTokens(text) {
    const raw = String(text || '').toLowerCase();
    const drop = new Set(['road','rd','street','st','avenue','ave','drive','dr','lane','ln','highway','hwy','motorway','mtwy','the','and']);
    return raw
      .replace(/[^a-z0-9\s]/g, ' ')
      .split(/\s+/)
      .filter(token => token && token.length > 1 && !drop.has(token));
  }

  function tokenOverlapScore(searchText, roadText) {
    const a = new Set(normalizeRoadTokens(searchText));
    const b = new Set(normalizeRoadTokens(roadText));
    if (!a.size || !b.size) return 0;
    const intersection = Array.from(a).filter(token => b.has(token)).length;
    const union = new Set([...a, ...b]).size;
    return union > 0 ? (intersection / union) : 0;
  }

  function inferRoutePossibility(searchText, roadText, descriptionText, distanceMeters) {
    const overlap = tokenOverlapScore(searchText, `${roadText || ''} ${descriptionText || ''}`);
    const distanceScore = Math.max(0, 1 - (Math.min(Number(distanceMeters) || 0, 3000) / 3000));
    const sameRoadBoost = overlap > 0.45 ? 1 : 0;
    const blended = (overlap * 0.55) + (distanceScore * 0.35) + (sameRoadBoost * 0.10);
    return Math.max(0, Math.min(100, Math.round(blended * 100)));
  }

  // --- NEW SMART HELPERS ---
  function standardizeRoadName(name) {
    if (!name) return '';
    return name.toLowerCase().replace(/[.,'"]/g, '').trim()
      .replace(/\b(st|street)\b/g, 'street')
      .replace(/\b(rd|road)\b/g, 'road')
      .replace(/\b(ave|avenue)\b/g, 'avenue')
      .replace(/\b(dr|drive)\b/g, 'drive')
      .replace(/\b(hwy|highway|mwy|motorway)\b/g, 'highway');
  }

  function isSameRoad(road1, road2) {
    if (!road1 || !road2) return false;
    const r1 = standardizeRoadName(road1);
    const r2 = standardizeRoadName(road2);
    return r1 === r2 || (r1.length > 5 && r2.includes(r1)) || (r2.length > 5 && r1.includes(r2));
  }

  function getBearingDirection(lat1, lon1, lat2, lon2) {
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const l1 = lat1 * Math.PI / 180;
    const l2 = lat2 * Math.PI / 180;
    const y = Math.sin(dLon) * Math.cos(l2);
    const x = Math.cos(l1) * Math.sin(l2) - Math.sin(l1) * Math.cos(l2) * Math.cos(dLon);
    let brng = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
    const dirs = ["North", "Northeast", "East", "Southeast", "South", "Southwest", "West", "Northwest"];
    return dirs[Math.round(brng / 45) % 8];
  }

  // --- NEW GEOCODING HELPER FUNCTION ---
  // Converts the user's typed address into exact latitude and longitude
  async function geocodeAddress(address) {
    const toLocation = (item) => {
      if (!item) return null;
      const lat = Number(item.lat);
      const lon = Number(item.lon);
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
      return {
        lat,
        lon,
        displayName: item.display_name || item.name || address,
        road: item.address ? (item.address.road || item.address.pedestrian || null) : null,
        provider: item.provider || 'Geocoder'
      };
    };

    const fetchJsonWithTimeout = async (url, timeoutMs = 9000) => {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
      try {
        const response = await fetch(url, { signal: controller.signal, headers: { 'Accept-Language': 'en-AU,en;q=0.9' }});
        if (!response.ok) return null;
        return await response.json();
      } catch (_err) {
        return null;
      } finally { clearTimeout(timeoutId); }
    };

    const queries = [address, `${address}, Queensland, Australia`, `${address}, Australia`];
    for (const q of queries) {
      const nominatimAu = `https://nominatim.openstreetmap.org/search?format=jsonv2&limit=5&addressdetails=1&countrycodes=au&q=${encodeURIComponent(q)}`;
      const nominatimAny = `https://nominatim.openstreetmap.org/search?format=jsonv2&limit=5&addressdetails=1&q=${encodeURIComponent(q)}`;
      const mapsCo = `https://geocode.maps.co/search?q=${encodeURIComponent(q)}`;

      const responses = [
        { provider: 'Nominatim (AU)', data: await fetchJsonWithTimeout(nominatimAu) },
        { provider: 'Nominatim (Global)', data: await fetchJsonWithTimeout(nominatimAny) },
        { provider: 'Maps.co', data: await fetchJsonWithTimeout(mapsCo) }
      ];

      for (const responsePack of responses) {
        const data = responsePack.data;
        if (!Array.isArray(data) || data.length === 0) continue;

        const preferredAu = data.find(item => String(item.display_name || '').toLowerCase().includes('australia'));
        const chosen = preferredAu || data[0];
        chosen.provider = responsePack.provider;
        const location = toLocation(chosen);
        if (location) return location;
      }
    }
    return null;
  }

  // --- UPDATED MAIN SEARCH FUNCTION ---
  async function performQuickTIASearch() {
    const searchInput = document.getElementById('quickTiaInput').value.trim();
    if (!searchInput) return alert('Please enter a road name or location');

    const searchBtn = document.querySelector('button[onclick="performQuickTIASearch()"]');
    const originalBtnText = searchBtn.innerHTML;
    searchBtn.innerHTML = '‚è≥ Searching...';
    searchBtn.disabled = true;

    document.getElementById('quickTiaError').style.display = 'none';
    document.getElementById('quickTiaPanel').style.display = 'none';
    document.getElementById('quickTiaSearchAddress').textContent = searchInput;
    const geoSourceEl = document.getElementById('quickTiaGeoSource');
    if (geoSourceEl) geoSourceEl.textContent = 'Searching...';

    // 1. Geocode
    let location = await geocodeAddress(searchInput);

    if (!location) {
      const fallbackMatch = findBestMatchSite(searchInput);
      if (fallbackMatch && fallbackMatch.sites.length) {
        const [id, data] = fallbackMatch.sites[0];
        if (Number.isFinite(Number(data.latitude))) {
          location = {
            lat: Number(data.latitude),
            lon: Number(data.longitude),
            displayName: data.road_name,
            road: data.road_name,
            provider: 'Local Database Fallback'
          };
        }
      }
    }

    if (!location) {
      document.getElementById('quickTiaError').innerHTML = `<strong>‚ùå Could not find that address on the map.</strong><br><span style="font-size: 0.9em;">Try adding suburb/city.</span>`;
      document.getElementById('quickTiaError').style.display = 'block';
      searchBtn.innerHTML = originalBtnText; searchBtn.disabled = false;
      return;
    }

    if (geoSourceEl) geoSourceEl.textContent = location.provider;
    addSearchMarker(location.lat, location.lon, searchInput);
    
    // 2. Map distances and bearings to all sites
    const sites = Object.entries(macroSitesData).filter(([, d]) => d.latitude && d.longitude).map(([id, data]) => {
      const dist = haversineDistance(location.lat, location.lon, Number(data.latitude), Number(data.longitude));
      const direction = getBearingDirection(location.lat, location.lon, Number(data.latitude), Number(data.longitude));
      return { id, data, dist, direction };
    });

    // 3. SMART FILTER: Check for sites on the EXACT SAME ROAD
    const targetRoad = location.road || searchInput;
    const sameRoadSites = sites
      .filter(s => isSameRoad(targetRoad, s.data.road_name))
      .sort((a, b) => a.dist - b.dist);

    if (sameRoadSites.length > 0) {
      const selectedPoints = sameRoadSites.slice(0, 3);

      if (selectedPoints.length === 1 && selectedPoints[0].dist < 150) {
        displayQuickTiaExactMatch(selectedPoints[0].id, selectedPoints[0].data);
        showNotification(`‚úì Exact data found on ${selectedPoints[0].data.road_name}!`);
      } else {
        const formattedArray = selectedPoints.map(s => [s.id, s.data, s.dist, s.direction]);
        displayQuickTiaMultipleRefs(targetRoad, formattedArray, location.lat, location.lon, true);
        showNotification(`üìç Found ${formattedArray.length} traffic counters along ${targetRoad}.`);
      }
    } else {
      const radiusMeters = 3000;
      const closestSites = sites
        .filter(s => s.dist <= radiusMeters)
        .sort((a, b) => a.dist - b.dist)
        .slice(0, 5);
      if (closestSites.length === 0) {
        document.getElementById('quickTiaError').innerHTML = `<strong>‚ùå No traffic data found within 3km.</strong>`;
        document.getElementById('quickTiaError').style.display = 'block';
      } else {
        const nearbyArray = closestSites.map(s => [s.id, s.data, s.dist, s.direction]);
        displayQuickTiaMultipleRefs(searchInput, nearbyArray, location.lat, location.lon, false);
        showNotification(`‚ö† Address found, but no counters on that exact road. Loading nearest references within 3km.`);
      }
    }

    searchBtn.innerHTML = originalBtnText;
    searchBtn.disabled = false;
  }

  function addSearchMarker(lat, lon, label) {
    // Clear previous search markers
    if (macroSearchMarkerLayer) {
      macroMapInstance.removeLayer(macroSearchMarkerLayer);
    }

    // Create new marker layer for search result
    macroSearchMarkerLayer = L.layerGroup().addTo(macroMapInstance);

    // Add marker with custom styling
    const marker = L.circleMarker([lat, lon], {
      radius: 10,
      fillColor: '#ff7043',
      color: '#d84315',
      weight: 3,
      opacity: 1,
      fillOpacity: 0.7
    }).addTo(macroSearchMarkerLayer);

    // Add popup with label
    marker.bindPopup(`<b>${label}</b>`, {
      autoClose: false,
      closeButton: true
    }).openPopup();

    // Pan and zoom to marker
    macroMapInstance.setView([lat, lon], Math.max(macroMapInstance.getZoom(), 17));
  }

  function showNotification(message) {
    // Create or reuse notification element
    let notif = document.getElementById('quickTiaNotification');
    if (!notif) {
      notif = document.createElement('div');
      notif.id = 'quickTiaNotification';
      notif.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #4caf50;
        color: white;
        padding: 12px 20px;
        border-radius: 4px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        z-index: 10000;
        font-weight: bold;
      `;
      document.body.appendChild(notif);
    }

    notif.textContent = message;
    notif.style.display = 'block';

    // Auto-hide after 3 seconds
    setTimeout(() => {
      notif.style.display = 'none';
    }, 3000);
  }

  function displayQuickTiaExactMatch(siteId, siteData) {
    document.getElementById('quickTiaMatchType').textContent = '‚úì Exact Road Match';
    document.getElementById('quickTiaMatchRoad').textContent = siteData.road_name || siteData.description;
    
    document.getElementById('quickTiaExactVADT').textContent = siteData.vadt.toLocaleString();
    document.getElementById('quickTiaExactD1').textContent = siteData.d1_vadt.toLocaleString();
    document.getElementById('quickTiaExactD2').textContent = siteData.d2_vadt.toLocaleString();

    document.getElementById('quickTiaExactMatch').style.display = 'block';
    document.getElementById('quickTiaMultipleRefs').style.display = 'none';
    
    // Store for later use
    window.selectedTiaData = {
      type: 'exact',
      siteId: siteId,
      vadt: siteData.vadt,
      d1_vadt: siteData.d1_vadt,
      d2_vadt: siteData.d2_vadt,
      lat: siteData.latitude,
      lon: siteData.longitude,
      road: siteData.road_name,
      countYear: siteData.countYear || siteData.count_year || null
    };

    document.getElementById('quickTiaPanel').style.display = 'block';
  }

  function displayQuickTiaMultipleRefs(searchTerm, nearbyArray, centerLat, centerLon, isSameRoadMatch = false) {
    document.getElementById('quickTiaMatchType').textContent = isSameRoadMatch
      ? `üìç Along Same Road (${searchTerm})`
      : '‚äô Nearby References (Radius Search)';
    document.getElementById('quickTiaMatchRoad').textContent = isSameRoadMatch
      ? 'Interpolating data points forward/backward on this street.'
      : 'Using closest points (may be on adjacent streets).';
    
    const refList = document.getElementById('quickTiaRefList');
    refList.innerHTML = '';
    
    const refArray = nearbyArray.map((item) => {
      const siteId = item[0];
      const data = item[1];
      const distFromCenter = item[2] || haversineDistance(centerLat, centerLon, Number(data.latitude), Number(data.longitude));
      const direction = item[3] || 'Nearby';
      return {
        siteId,
        road: data.road_name || data.description,
        vadt: data.vadt,
        d1_vadt: data.d1_vadt,
        d2_vadt: data.d2_vadt,
        lat: data.latitude,
        lon: data.longitude,
        source: data.source || 'Unknown',
        distance: Math.round(distFromCenter),
        description: data.description,
        direction,
        countYear: data.countYear || data.count_year || null
      };
    });

    let totalInverseDist = 0;
    refArray.forEach(site => {
      site.invDist = 1 / (site.distance + 10);
      totalInverseDist += site.invDist;
    });

    let currentWeightSum = 0;
    refArray.forEach(site => {
      site.autoWeight = Math.round((site.invDist / totalInverseDist) * 100);
      currentWeightSum += site.autoWeight;
    });

    if (refArray.length > 0 && currentWeightSum !== 100) {
      refArray[0].autoWeight += (100 - currentWeightSum);
    }

    // Draw link lines from search point to each reference site
    if (macroMapInstance && typeof L !== 'undefined') {
      if (macroReferenceLinkLayer) {
        macroMapInstance.removeLayer(macroReferenceLinkLayer);
      }
      macroReferenceLinkLayer = L.layerGroup().addTo(macroMapInstance);
    }

    refArray.forEach((site, idx) => {
      const div = document.createElement('div');
      div.style.cssText = isSameRoadMatch
        ? 'padding: 10px; border: 1px solid #e0e0e0; border-radius: 6px; font-size: 0.85em; background: #e8f5e9;'
        : 'padding: 10px; border: 1px solid #e0e0e0; border-radius: 6px; font-size: 0.85em; background: #fafafa;';
      const distanceText = site.distance < 1000 ? `${site.distance}m` : `${(site.distance/1000).toFixed(1)}km`;
      const sourceLabel = `[${site.source}]`;
      const suggestedWeight = Math.max(0, Math.min(100, site.autoWeight));
      const matchBadge = isSameRoadMatch
        ? '<span style="margin-left: 6px; padding: 1px 6px; border-radius: 10px; background: #2e7d32; color: #fff; font-size: 0.72em;">Same road</span>'
        : '<span style="margin-left: 6px; padding: 1px 6px; border-radius: 10px; background: #546e7a; color: #fff; font-size: 0.72em;">Nearby</span>';
      div.innerHTML = `
        <strong>${idx + 1}.</strong> ${site.road} ${matchBadge}<br/>
        <small style="color: #666;">${sourceLabel} ‚Ä¢ <strong>${distanceText} ${site.direction} of address</strong> ‚Ä¢ ${site.vadt.toLocaleString()} VADT</small>
        <div style="margin-top: 6px; display: grid; grid-template-columns: 1fr auto auto; align-items: center; gap: 8px;">
          <span style="color: #333; font-size: 0.8em;">Distance Weighting:</span>
          <input type="range" class="ref-weight-slider" data-siteid="${site.siteId}" min="0" max="100" step="1" value="${suggestedWeight}" style="width: 100%; cursor: pointer;" />
          <input type="number" class="ref-weight" data-siteid="${site.siteId}" min="0" max="100" step="1" value="${suggestedWeight}" style="width: 62px; padding: 2px 4px; border: 1px solid #ccc; border-radius: 3px; font-size: 0.85em;" />
          <span style="font-size: 0.8em; color: #666;">%</span>
        </div>
      `;
      refList.appendChild(div);

      const sliderInput = div.querySelector('.ref-weight-slider');
      const weightInput = div.querySelector('.ref-weight');
      if (sliderInput && weightInput) {
        sliderInput.addEventListener('input', () => {
          weightInput.value = sliderInput.value;
          updateTiaCalculations();
        });
        weightInput.addEventListener('input', () => {
          const v = Math.max(0, Math.min(100, Number(weightInput.value) || 0));
          weightInput.value = String(v);
          sliderInput.value = String(v);
          updateTiaCalculations();
        });
      }

      // Add visual link on the map
      if (macroReferenceLinkLayer && Number.isFinite(site.lat) && Number.isFinite(site.lon)) {
        L.polyline([[centerLat, centerLon], [Number(site.lat), Number(site.lon)]], {
          color: '#1976d2',
          weight: 2,
          opacity: 0.7,
          dashArray: '4,6'
        }).addTo(macroReferenceLinkLayer);
      }
    });

    // Calculate weighted averages based on per-road weights
    const weightInputs = refList.querySelectorAll('.ref-weight');
    const weights = Array.from(weightInputs).map(input => Number(input.value) || 0);
    const weightTotal = weights.reduce((sum, w) => sum + w, 0) || 1;

    const avgVADT = Math.round(refArray.reduce((sum, s, i) => sum + (s.vadt * (weights[i] || 0)), 0) / weightTotal);
    const avgD1 = Math.round(refArray.reduce((sum, s, i) => sum + (s.d1_vadt * (weights[i] || 0)), 0) / weightTotal);
    const avgD2 = Math.round(refArray.reduce((sum, s, i) => sum + (s.d2_vadt * (weights[i] || 0)), 0) / weightTotal);

    window.selectedTiaData = {
      type: 'references',
      references: refArray,
      avgVADT: avgVADT,
      avgD1: avgD1,
      avgD2: avgD2
    };

    updateTiaCalculations();

    document.getElementById('quickTiaExactMatch').style.display = 'none';
    document.getElementById('quickTiaMultipleRefs').style.display = 'block';
    document.getElementById('quickTiaPanel').style.display = 'block';
  }

  function updateTiaCalculations() {
    if (!window.selectedTiaData || window.selectedTiaData.type !== 'references') return;

    const refWeights = Array.from(document.querySelectorAll('#quickTiaRefList .ref-weight')).map(input => Number(input.value) || 0);
    const refs = window.selectedTiaData.references || [];
    const n = Math.max(1, refs.length);
    const percentAdjustedMean = (key) => {
      const adjustedSum = refs.reduce((sum, s, i) => {
        const value = Number(s[key]) || 0;
        const percent = Math.max(0, Math.min(100, Number(refWeights[i]) || 0));
        return sum + ((percent / 100) * value);
      }, 0);
      return adjustedSum / n;
    };

    const avgVadtRaw = percentAdjustedMean('vadt');
    const avgD1Raw = percentAdjustedMean('d1_vadt');
    const avgD2Raw = percentAdjustedMean('d2_vadt');

    const weightedAvgVADT = Math.round(avgVadtRaw);
    const weightedAvgD1 = Math.round(avgD1Raw);
    const weightedAvgD2 = Math.round(avgD2Raw);

    window.selectedTiaData.avgVADT = weightedAvgVADT;
    window.selectedTiaData.avgD1 = weightedAvgD1;
    window.selectedTiaData.avgD2 = weightedAvgD2;

    document.getElementById('quickTiaCalcAvgVADT').textContent = weightedAvgVADT.toLocaleString();
    document.getElementById('quickTiaCalcAdjVADT').textContent = weightedAvgVADT.toLocaleString();
    document.getElementById('quickTiaCalcD1').textContent = weightedAvgD1.toLocaleString();
    document.getElementById('quickTiaCalcD2').textContent = weightedAvgD2.toLocaleString();
  }

  function useExactTIAData() {
    if (!window.selectedTiaData || !window.selectedTiaData.siteId) return;
    
    // Auto-fill the main form
    document.getElementById('macroSiteSearch').value = window.selectedTiaData.siteId;
    document.getElementById('D1_VADT').value = window.selectedTiaData.d1_vadt;
    document.getElementById('D2_VADT').value = window.selectedTiaData.d2_vadt;
    document.getElementById('VADT').value = window.selectedTiaData.vadt;
    const baseYearInput = document.getElementById('baseYear');
    if (baseYearInput) {
      const year = Number(window.selectedTiaData.countYear);
      baseYearInput.value = Number.isFinite(year) ? year : '';
    }
    
    // Scroll to form
    document.querySelector('.card:nth-of-type(2)').scrollIntoView({ behavior: 'smooth' });
  }

  function useCalculatedTIAData() {
    if (!window.selectedTiaData || window.selectedTiaData.type !== 'references') return;

    const adjVADT = Math.round(window.selectedTiaData.avgVADT || 0);
    let adjD1 = Math.round(window.selectedTiaData.avgD1 || 0);
    let adjD2 = Math.round(window.selectedTiaData.avgD2 || 0);

    const dirSum = adjD1 + adjD2;
    if (adjVADT > 0 && dirSum !== adjVADT) {
      const d1Ratio = dirSum > 0 ? (adjD1 / dirSum) : 0.5;
      adjD1 = Math.round(adjVADT * d1Ratio);
      adjD2 = Math.max(0, adjVADT - adjD1);
    }

    // Auto-fill the main form
    document.getElementById('D1_VADT').value = adjD1;
    document.getElementById('D2_VADT').value = adjD2;
    document.getElementById('VADT').value = adjVADT;
    document.getElementById('macroSiteSearch').value = 'Calculated (weighted average of references)';
    const baseYearInput = document.getElementById('baseYear');
    if (baseYearInput) {
      const years = (window.selectedTiaData.references || [])
        .map(ref => Number(ref.countYear))
        .filter(y => Number.isFinite(y) && y > 0);
      if (years.length) {
        const avgYear = Math.round(years.reduce((sum, y) => sum + y, 0) / years.length);
        baseYearInput.value = avgYear;
      } else {
        baseYearInput.value = '';
      }
    }
    
    // Scroll to form
    const allCards = document.querySelectorAll('.card');
    allCards[1].scrollIntoView({ behavior: 'smooth' });
  }

  // Allow Enter key on quick search
  document.getElementById('quickTiaInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') performQuickTIASearch();
  });

</script>
</body>
</html>