<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Crompton TIA+ Queue Length Analysis</title>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --bg: #f6f3ef;
      --ink: #1c1c1c;
      --muted: #5f5f5f;
      --card: #ffffff;
      --line: #e1ded8;
      --brand: #1f5e63;
      --brand-2: #0f2f32;
      --shadow: 0 12px 30px rgba(0, 0, 0, 0.08);
      --radius: 12px;
    }

    * { box-sizing: border-box; }

    body {
      font-family: "Space Grotesk", "Trebuchet MS", "Lucida Sans Unicode", "Lucida Grande", "Lucida Sans", sans-serif;
      background: radial-gradient(1200px 600px at 10% -10%, #e8f0ef 0%, transparent 55%),
                  radial-gradient(1200px 600px at 100% -10%, #f3e7dc 0%, transparent 50%),
                  var(--bg);
      margin: 0;
      padding: 24px;
      color: var(--ink);
      line-height: 1.35;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: linear-gradient(180deg, #ffffff 0%, #fcfbf9 100%);
      border: 1px solid var(--line);
      border-radius: 18px;
      padding: 24px;
      box-shadow: var(--shadow);
    }

    .navbar {
      display: flex;
      align-items: center;
      margin-bottom: 20px;
      gap: 10px;
      padding: 8px 10px;
      background: #f8fbfa;
      border: 1px solid #e4ebe8;
      border-radius: 10px;
    }

    .home-button {
      background: linear-gradient(135deg, var(--brand) 0%, var(--brand-2) 100%);
      color: white;
      padding: 10px 18px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 700;
      font-size: 15px;
      transition: transform 0.16s ease, box-shadow 0.16s ease, filter 0.16s ease;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      width: auto;
      text-decoration: none;
      box-shadow: 0 8px 16px rgba(15, 47, 50, 0.24);
    }

    .home-button:hover {
      filter: brightness(1.04);
      transform: translateY(-1px);
      box-shadow: 0 12px 18px rgba(15, 47, 50, 0.28);
    }
    .home-button::before { content: 'üè†'; }

    h1 {
      text-align: center;
      margin: 12px 0 8px;
      color: var(--brand-2);
      letter-spacing: 0.3px;
      font-size: clamp(1.6rem, 2.3vw, 2.1rem);
    }

    .subtitle {
      text-align: center;
      margin: 8px 0 16px;
      color: var(--muted);
      font-size: 0.98rem;
      max-width: 880px;
      margin-left: auto;
      margin-right: auto;
    }

    h2 {
      margin: 0 0 12px;
      color: var(--brand-2);
      font-size: 1.05rem;
      border-bottom: 2px solid var(--brand);
      padding-bottom: 8px;
    }

    .grid { display:grid; grid-template-columns:repeat(4, minmax(180px,1fr)); gap:12px; }
    .grid-2 { display:grid; grid-template-columns:repeat(2, minmax(180px,1fr)); gap:12px; }

    .card {
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 16px;
      margin-top: 14px;
      background: var(--card);
      box-shadow: 0 6px 16px rgba(15, 47, 50, 0.06);
      transition: transform 0.18s ease, box-shadow 0.18s ease, border-color 0.18s ease;
    }

    .card:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 24px rgba(15, 47, 50, 0.1);
      border-color: #d1ccc3;
    }

    details.card > summary {
      list-style: none;
      border-radius: 8px;
      padding: 8px 10px;
      background: linear-gradient(180deg, #ffffff 0%, #f7faf9 100%);
      border: 1px solid #e4ebe8;
      margin-bottom: 10px;
      position: relative;
      padding-right: 34px;
    }

    details.card > summary::after {
      content: '‚ñæ';
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%) rotate(0deg);
      color: var(--brand);
      font-size: 0.95rem;
      transition: transform 0.18s ease;
    }

    details.card[open] > summary::after {
      transform: translateY(-50%) rotate(180deg);
    }

    details.card > summary::-webkit-details-marker {
      display: none;
    }

    label {
      display: block;
      font-size: 12px;
      font-weight: 700;
      margin-bottom: 6px;
      color: var(--muted);
    }

    .grid > div,
    .grid-2 > div {
      background: linear-gradient(180deg, #ffffff 0%, #fbfbfa 100%);
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px;
    }

    input, select {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #cfd6ce;
      border-radius: 8px;
      background: #fff;
      font-family: inherit;
      font-size: 0.95rem;
      transition: all 0.2s ease;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.02), 0 1px 0 rgba(255,255,255,0.8);
    }

    input::placeholder {
      color: #8a8f96;
    }

    input:focus, select:focus {
      outline: none;
      border-color: var(--brand);
      box-shadow: 0 0 0 3px rgba(31, 94, 99, 0.15);
    }

    input[readonly], select[readonly] {
      background-color: #f8f9fa !important;
      border-color: #e9ecef !important;
      color: #6c757d !important;
      cursor: not-allowed;
    }

    select {
      appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 10px center;
      background-size: 1em;
      padding-right: 32px;
    }
/* ===== PROFESSIONAL PRINT STYLES ===== */
    @media print {
      /* 1. Force background colors to print (Crucial for VCR tables & Work Window) */
      * {
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
      }

      body { 
        background: white; 
        padding: 0; 
        color: #000;
        font-size: 10.5pt;
        line-height: 1.28;
      }

      .container { 
        box-shadow: none !important; 
        border: none !important; 
        padding: 0 !important;
        max-width: 100%;
      }

      /* 2. Hide purely interactive UI elements */
      .navbar, .home-button, button, .copy-table-btn, .copyright-footer,
      #selfDiagnosticsCard, #printCustomizationCard, .leaflet-control-container,
      input[type="range"], .tooltip::after, .tooltip-label::after, .tooltip-label::before { 
        display: none !important; 
      }

      /* Hide the database search inputs, keep only the details */
      #macroSourceFilter, #macroSiteSearch, label[for="macroSourceFilter"], 
      #detourSiteSearch, #detourSiteSelect {
        display: none !important;
      }

      /* 3. Convert inputs and dropdowns into plain text for the report */
      input, select {
        border: none !important;
        background: transparent !important;
        box-shadow: none !important;
        padding: 0 !important;
        color: #000 !important;
        font-weight: bold;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
      }
      
      /* Remove dropdown arrows */
      select { background-image: none !important; }

      /* 4. Layout & Page Breaks */
      .card { 
        page-break-inside: auto !important;
        break-inside: auto !important;
        border: 1px solid #ddd !important;
        box-shadow: none !important;
        margin: 6px 0 !important;
        padding: 15px !important;
        background: #fff !important;
      }

      /* Allow the main assumption grids to break if absolutely necessary, but keep rows together */
      .grid, .grid-2, .kpi-grid, .assumptions-grid {
        page-break-inside: auto !important;
        break-inside: auto !important;
      }

      /* 5. Typography Formatting */
      h1 { font-size: 18pt; color: #000; text-align: center; margin-top: 0; }
      h2 { font-size: 13pt; color: #000; border-bottom: 2px solid #000; padding-bottom: 4px; page-break-after: avoid; }
      h3 { font-size: 11pt; color: #333; page-break-after: avoid; }
      
      table { font-size: 8.6pt; width: 100% !important; border-collapse: collapse; }
      th, td { padding: 6px 6px !important; line-height: 1.2 !important; }
      th { background: #eee !important; color: #000 !important; border: 1px solid #aaa !important; }
      td { border: 1px solid #aaa !important; }

      /* 6. Fix Map Printing */
      #macroMap { 
        height: 200px !important; 
        border: 1px solid #000 !important; 
        margin-top: 8px; 
        page-break-inside: avoid; 
      }
      #detourMap {
        min-height: 0 !important;
        height: 220px !important;
        page-break-inside: avoid;
      }

      /* 7. Ensure Header is visible */
      .print-header { 
        display: block !important; 
        text-align: center; 
        margin-bottom: 30px; 
        border-bottom: 3px double #000;
        padding-bottom: 10px;
      }
      .print-header h2 { border: none; font-size: 24pt; margin: 0; }
      .print-header p { margin: 5px 0; font-size: 11pt; color: #444; }
      .main-report-heading, .subtitle { display: none !important; }

      /* Force details blocks to open for printing */
      details { display: block !important; }
      details summary { display: none !important; }
      details > * { display: block !important; }

      /* Keep report sections flowing without large blank gaps */
      .card h2, .card h3, .card p { margin-top: 0 !important; margin-bottom: 6px !important; }
      .table-wrap { margin: 4px 0 !important; }
      .exclude-from-print { display: none !important; }

      /* Custom fixes for the new cards */
      #wwTimeline div { border-right: 1px solid #fff !important; } /* Keeps timeline blocks distinct */
    }

    .tooltip {
      position: relative;
      cursor: help;
      border-bottom: 1px dotted #999;
    }

    .tooltip::after {
      content: attr(data-tip);
      position: absolute;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--ink);
      color: #fff;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 11px;
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: 0.2s;
      font-weight: normal;
      z-index: 10;
    }

    .tooltip:hover::after {
      opacity: 1;
      visibility: visible;
    }

    button {
      width: 100%;
      margin-top: 14px;
      padding: 11px;
      border: none;
      border-radius: 8px;
      background: linear-gradient(135deg, var(--brand) 0%, var(--brand-2) 100%);
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      font-size: 0.98rem;
      box-shadow: 0 6px 14px rgba(31, 94, 99, 0.22);
      transition: transform 0.15s ease, box-shadow 0.15s ease, filter 0.15s ease;
    }

    button:hover {
      filter: brightness(1.03);
      transform: translateY(-1px);
      box-shadow: 0 10px 18px rgba(31, 94, 99, 0.28);
    }

    .kpi-grid {
      display: grid;
      grid-template-columns: repeat(6, minmax(140px, 1fr));
      gap: 10px;
      margin-top: 8px;
    }

    .kpi {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px;
      background: linear-gradient(180deg, #ffffff 0%, #f7faf9 100%);
      box-shadow: 0 4px 10px rgba(15, 47, 50, 0.05);
    }

    .kpi-label {
      font-size: 0.75rem;
      color: var(--muted);
      font-weight: 700;
      margin-bottom: 4px;
      text-transform: uppercase;
      letter-spacing: 0.4px;
    }

    .kpi-value {
      font-size: 1.05rem;
      font-weight: 700;
      color: var(--brand-2);
    }

    .table-wrap {
      overflow-x: auto;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: linear-gradient(180deg, #ffffff 0%, #fcfdfc 100%);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.8);
    }

    .chart-panel {
      background: linear-gradient(180deg, #fafdfd 0%, #f5f8f8 100%);
      border: 1px solid #dde6e6;
      border-radius: 10px;
      padding: 10px;
      margin-bottom: 10px;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.9);
    }

    .chart-panel canvas {
      width: 100%;
    }

    .chart-canvas-280 { max-height: 280px; }
    .chart-canvas-300 { max-height: 300px; }
    .chart-canvas-350 { max-height: 350px; }
    .chart-canvas-360 { max-height: 360px; }
    .chart-canvas-250 { max-height: 250px; }

    .table-actions {
      display: flex;
      justify-content: flex-end;
      margin: 8px 0;
    }

    .copy-table-btn {
      width: auto;
      margin: 0;
      padding: 7px 12px;
      font-size: 0.84rem;
      border-radius: 7px;
      background: linear-gradient(135deg, var(--brand) 0%, var(--brand-2) 100%);
      color: #fff;
      border: none;
      cursor: pointer;
      font-weight: 700;
      box-shadow: 0 4px 10px rgba(15, 47, 50, 0.2);
    }

    .copy-table-btn:hover {
      filter: brightness(1.03);
      transform: translateY(-1px);
    }

    table { width:100%; border-collapse:collapse; font-size:13px; }
    th, td { border:1px solid #dbe2ea; padding:8px; text-align:center; }
    th {
      background: linear-gradient(180deg, var(--brand) 0%, var(--brand-2) 100%);
      color:#fff;
      position: sticky;
      top: 0;
      z-index: 1;
      letter-spacing: 0.2px;
    }
    tbody tr:nth-child(even) td { background: #f8fbfb; }
    tbody tr:hover td { background: #eef6f6; }
    .rowhead {
      text-align:left;
      font-weight:700;
      background:#f4f3f0;
      position: sticky;
      left: 0;
      z-index: 1;
    }
    .status-yes { background:#d1fae5; }
    .status-no { background:#fee2e2; }
    .hidden { display:none; }

    .table-note {
      margin: 8px 0 0;
      color: var(--muted);
      font-size: 0.82rem;
    }

    .dir-heading {
      margin: 12px 0 8px 0;
      font-size: 1.05em;
      font-weight: 700;
      letter-spacing: 0.1px;
    }

    .dir-heading-spaced {
      margin-top: 20px;
    }

    .dir-heading-negative {
      color: #c30000;
    }

    .dir-heading-positive {
      color: #2e7d32;
    }

    .print-toggle-btn {
      width: auto !important;
      margin-top: 0 !important;
      padding: 5px 10px !important;
      border-radius: 999px;
      font-size: 0.78rem;
      font-weight: 700;
      line-height: 1;
      background: linear-gradient(135deg, #2e7d32 0%, #1b5e20 100%);
      box-shadow: 0 3px 8px rgba(27, 94, 32, 0.24);
    }

    .print-toggle-btn.is-off {
      background: linear-gradient(135deg, #757575 0%, #424242 100%);
      box-shadow: 0 3px 8px rgba(66, 66, 66, 0.22);
    }

    .section-print-toggle {
      position: static;
      z-index: 2;
    }

    .section-print-toggle-row {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      margin: -2px 0 8px 0;
      min-height: 26px;
    }

    .diag-card {
      border: 1px dashed #90a4ae;
      background: #f8fbfd;
    }

    .diag-summary {
      margin: 0 0 8px 0;
      font-weight: 700;
      color: #1f5e63;
    }

    .diag-pass {
      color: #1b5e20;
      font-weight: 700;
    }

    .diag-fail {
      color: #b71c1c;
      font-weight: 700;
    }

    .diag-btn {
      width: auto;
      margin-top: 0;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 0.82rem;
      box-shadow: 0 4px 10px rgba(13, 71, 161, 0.22);
      background: linear-gradient(135deg, #1565c0 0%, #0d47a1 100%);
    }

    .diag-note {
      font-size: 0.8rem;
      color: #607d8b;
      margin: 6px 0 0 0;
    }

    .print-custom-card {
      border: 1px dashed #90a4ae;
      background: #f9fcfe;
    }

    .print-custom-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .print-custom-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin: 0 0 10px 0;
    }

    .print-custom-actions button {
      width: auto;
      margin-top: 0;
      padding: 6px 10px;
      font-size: 0.78rem;
      border-radius: 999px;
      box-shadow: 0 3px 8px rgba(31, 94, 99, 0.22);
      background: linear-gradient(135deg, #1f5e63 0%, #0f2f32 100%);
    }

    .print-custom-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: 260px;
      overflow-y: auto;
      padding-right: 4px;
    }

    .print-custom-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      border: 1px solid #dde6ec;
      border-radius: 8px;
      padding: 6px 8px;
      background: #ffffff;
    }

    .print-custom-name {
      font-size: 0.82rem;
      color: #29434e;
      line-height: 1.25;
      overflow-wrap: anywhere;
    }

    .print-scope-badge {
      display: inline-block;
      margin-left: 6px;
      padding: 1px 6px;
      border-radius: 999px;
      font-size: 0.7rem;
      font-weight: 700;
      color: #455a64;
      background: #ecf3f7;
      border: 1px solid #d3e2ea;
    }

    .print-mini-toggle {
      width: auto !important;
      margin-top: 0 !important;
      padding: 4px 8px !important;
      border-radius: 999px;
      font-size: 0.74rem;
      line-height: 1;
      background: linear-gradient(135deg, #2e7d32 0%, #1b5e20 100%);
      box-shadow: 0 2px 6px rgba(27, 94, 32, 0.24);
      white-space: nowrap;
    }

    .print-mini-toggle.is-off {
      background: linear-gradient(135deg, #757575 0%, #424242 100%);
      box-shadow: 0 2px 6px rgba(66, 66, 66, 0.22);
    }

    #macroMap {
      height: 320px;
      width: 100%;
      border: 2px solid #0056b3;
      border-radius: 8px;
      margin-top: 10px;
    }

    @media (max-width: 1180px) {
      .grid, .kpi-grid { grid-template-columns: repeat(2, minmax(150px, 1fr)); }
    }

    @media (max-width: 760px) {
      body { padding: 12px; }
      .container { padding: 14px; }
      .grid, .grid-2, .kpi-grid { grid-template-columns: 1fr; }
        .assumptions-grid { grid-template-columns: 1fr; }
      table { font-size: 12px; }
    }

    /* Print Styles */
    @media print {
      body { background: white; padding: 0; font-size: 10.5pt; line-height: 1.28; }
      .container { box-shadow: none; border: none; }
      .navbar, .home-button, button, .copy-table-btn, .copyright-footer { display: none !important; }
      #selfDiagnosticsCard, #printCustomizationCard { display: none !important; }
        .leaflet-control-container { display: none !important; }
      .card {
        page-break-inside: auto !important;
        break-inside: auto !important;
        margin: 6px 0 !important;
      }
        #macroMap { height: 200px !important; border: 1px solid #9aa4ab; margin-top: 8px; page-break-inside: avoid; }
        #detourMap { min-height: 0 !important; height: 220px !important; page-break-inside: avoid; }
      h1 { font-size: 18pt; color: #000; }
      h2 { font-size: 13pt; page-break-after: avoid; }
      h3 { font-size: 11pt; page-break-after: avoid; }
      table { font-size: 8.6pt; }
      th, td { padding: 6px 6px !important; line-height: 1.2 !important; }
      th { background: #333 !important; color: white !important; }
      .print-header { display: block !important; text-align: center; margin-bottom: 20px; }
      .print-header h2 { margin: 0; }
      .print-header p { margin: 5px 0; font-size: 10pt; color: #666; }
      .main-report-heading, .subtitle { display: none !important; }
      details { display: block !important; }
      details summary { display: none !important; }
      details > * { display: block !important; }
      .card h2, .card h3, .card p { margin-top: 0 !important; margin-bottom: 6px !important; }
      .table-wrap { margin: 4px 0 !important; }
      .exclude-from-print { display: none !important; }
    }

    .print-header { display: none; }
    
    .print-btn {
      background: #4caf50;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9em;
      margin-left: 10px;
      transition: background 0.2s;
    }
    
    .print-btn:hover {
      background: #45a049;
    }

    .report-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 14px;
    }

    .report-actions .print-btn {
      margin-left: 0;
    }

    @media (prefers-reduced-motion: reduce) {
      .card,
      .home-button,
      button,
      .copy-table-btn,
      details.card > summary::after {
        transition: none !important;
      }
      .card:hover,
      .home-button:hover,
      button:hover,
      .copy-table-btn:hover {
        transform: none !important;
      }
    }

    .source-pill {
      display: inline-block;
      padding: 2px 10px;
      border-radius: 999px;
      font-size: 0.82em;
      font-weight: 700;
      border: 1px solid transparent;
    }

    .source-tmr {
      background: #e3f2fd;
      color: #1565c0;
      border-color: #90caf9;
    }

    .source-gold-coast {
      background: #fff3e0;
      color: #ef6c00;
      border-color: #ffcc80;
    }

    .source-ipswich {
      background: #f3e5f5;
      color: #7b1fa2;
      border-color: #ce93d8;
    }

    .source-logan {
      background: #e8f5e9;
      color: #2e7d32;
      border-color: #a5d6a7;
    }
    .source-custom-address {
      background: #ede7f6;
      color: #5e35b1;
      border-color: #b39ddb;
    }
      .quality-pill {
        display: inline-block;
        padding: 2px 10px;
        border-radius: 999px;
        font-size: 0.82em;
        font-weight: 700;
        border: 1px solid transparent;
      }
      .quality-measured { background: #e8f5e9; color: #1b5e20; border-color: #81c784; }
      .quality-derived { background: #fff8e1; color: #ef6c00; border-color: #ffcc80; }
      .quality-estimated { background: #ffebee; color: #c62828; border-color: #ef9a9a; }
      .assumptions-grid {
        display: grid;
        grid-template-columns: repeat(3, minmax(200px, 1fr));
        gap: 10px;
      }
      .assumption-item {
        background: #f7fbfc;
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 8px 10px;
      }
      .assumption-key {
        font-size: 0.74rem;
        color: var(--muted);
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.35px;
        margin-bottom: 2px;
      }
      .assumption-value {
        font-size: 0.9rem;
        color: var(--brand-2);
        font-weight: 700;
      }

    /* Detour List Hover Styles */
    .detour-list-item {
      padding: 10px 12px;
      border: 1px solid #ce93d8;
      border-radius: 6px;
      background: #fff;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .detour-list-item:hover {
      background: #f3e5f5;
      border-color: #8e24aa;
      transform: translateX(2px);
    }
    .detour-list-item.selected {
      background: #e1bee7;
      border-color: #8e24aa;
      box-shadow: 0 2px 4px rgba(142, 36, 170, 0.2);
    }
    /* Custom Scrollbar for the list */
    #detourListContainer::-webkit-scrollbar { width: 6px; }
    #detourListContainer::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 4px; }
    #detourListContainer::-webkit-scrollbar-thumb { background: #ce93d8; border-radius: 4px; }
    #detourListContainer::-webkit-scrollbar-thumb:hover { background: #ab47bc; }

    .company-logo-watermark {
      position: fixed;
      right: 18px;
      top: 18px;
      width: min(180px, 24vw);
      max-height: 64px;
      object-fit: contain;
      opacity: 0.14;
      z-index: 999;
      pointer-events: none;
      user-select: none;
      filter: grayscale(100%);
    }

    @media print {
      .company-logo-watermark { display: none !important; }
    }

    @media (max-width: 760px) {
      .company-logo-watermark {
        width: min(130px, 32vw);
        opacity: 0.12;
        right: 10px;
        top: 10px;
      }
    }
  </style>
</head>
<body>
  <img class="company-logo-watermark" src="./crompton-logo.png" alt="Crompton logo" />
  <div class="container">
    <div class="print-header">
      <h2>Crompton TIA+ Queue Length Analysis Report</h2>
      <p>Generated: <span id="printDate"></span></p>
      <p>Crompton Traffic Analysis System</p>
    </div>
    
    <div class="navbar">
      <a class="home-button" href="#" onclick="window.location.reload(); return false;">Home</a>
      <span style="margin-left:auto; font-size:0.9em; color:#666;">
        <strong>Sites Loaded:</strong> <span id="sitesLoadedCount">0</span>
      </span>
    </div>
    <h1 class="main-report-heading">Crompton TIA+ Queue Length Analysis</h1>
    <p class="subtitle">database-integrated directional traffic, queue metrics, and capacity checks</p>

    <!-- ===== QUICK TIA ADDRESS SEARCH (TOP) ===== -->
    <div class="card" id="quickSearchCard" style="background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); border: 2px solid #1976d2;">
      <h2 style="color: #1565c0; margin-top: 0;">üöó Search Address</h2>
      <p style="color: #0d47a1; margin: 0 0 12px 0; font-size: 0.95em;">
       
      <div style="display: grid; grid-template-columns: 1fr 180px; gap: 12px; margin-bottom: 12px;">
        <div>
          <input type="text" id="quickTiaInput" placeholder="eg. Brisbane Road, Bellbird Park, Rockhampton" 
                 style="width: 100%; border: 2px solid #1976d2; padding: 10px; border-radius: 4px; font-size: 1em;" />
        </div>
        <button id="quickTiaSearchBtn" type="button" style="background: #1976d2; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 0.95em;">
          üîç Search
        </button>
      </div>
      
      <div id="quickTiaPanel" style="display: none; background: white; border: 1px solid #1976d2; border-radius: 6px; padding: 12px; margin-bottom: 12px;">
        <h3 style="margin: 0 0 10px 0; color: #1565c0; border-bottom: 2px solid #1976d2; padding-bottom: 8px;">üìç Analysis Results</h3>
        
        <div id="quickTiaMatchInfo" style="background: #e3f2fd; border-left: 4px solid #1976d2; padding: 10px; margin-bottom: 10px; border-radius: 3px;">
          <strong style="color: #1565c0;">Match Type:</strong> <span id="quickTiaMatchType">-</span><br>
          <strong style="color: #1565c0;">Search Address:</strong> <span id="quickTiaSearchAddress">-</span><br>
          <strong style="color: #1565c0;">Geo Source:</strong> <span id="quickTiaGeoSource">-</span><br>
          <strong style="color: #1565c0;">Road/Location:</strong> <span id="quickTiaMatchRoad">-</span>
        </div>

        <!-- For Exact Match -->
        <div id="quickTiaExactMatch" style="display: none;">
          <div style="background: #e8f5e9; border: 1px solid #4caf50; border-radius: 6px; padding: 10px; margin-bottom: 10px;">
            <h4 style="margin: 0 0 8px 0; color: #2e7d32;">‚úì Exact Data Found</h4>
            <div style="font-size: 0.9em; line-height: 1.6;">
              <div><strong>VADT:</strong> <span id="quickTiaExactVADT">-</span> vehicles/day</div>
              <div><strong id="quickTiaExactD1Label">D1 VADT:</strong> <span id="quickTiaExactD1">-</span></div>
              <div><strong id="quickTiaExactD2Label">D2 VADT:</strong> <span id="quickTiaExactD2">-</span></div>
            </div>
          </div>
          <button onclick="useExactTIAData()" style="background: #4caf50; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; font-weight: bold;">
            ‚úì Use This Data
          </button>
        </div>

        <!-- For Multiple References -->
        <div id="quickTiaMultipleRefs" style="display: none;">
          <h4 style="margin: 0 0 10px 0; color: #d32f2f;">‚äô Using 3+ Reference Points (within 5km)</h4>
          <div id="quickTiaRefList" style="background: white; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 10px; display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 8px;"></div>
          <p style="font-size: 0.82em; color: #4e342e; margin: 0 0 10px 0; background: #fff3e0; border: 1px solid #ffcc80; border-radius: 6px; padding: 8px;">
            Each reference has its own route possibility slider (0‚Äì100%). Final traffic volume is a weighted average (not a sum).
          </p>

          <div id="quickTiaCalcResult" style="background: #e8f5e9; border: 1px solid #4caf50; border-radius: 6px; padding: 10px; margin-bottom: 10px;">
            <h5 style="margin: 0 0 8px 0; color: #2e7d32;">Calculated AADT (Weighted Average of References)</h5>
            <div style="font-size: 0.9em; line-height: 1.6;">
              <div><strong>Detected Area Type:</strong> <span id="quickTiaAreaType">-</span> ‚Ä¢ <strong>Type%:</strong> <span id="quickTiaTypePercent">100%</span></div>
              <div><strong>Weighted Avg VADT:</strong> <span id="quickTiaCalcAvgVADT">-</span> vehicles/day</div>
              <div><strong>AADT to use:</strong> <span id="quickTiaCalcAdjVADT">-</span> vehicles/day</div>
              <div><strong id="quickTiaCalcD1Label">Calculated D1 VADT:</strong> <span id="quickTiaCalcD1">-</span></div>
              <div><strong id="quickTiaCalcD2Label">Calculated D2 VADT:</strong> <span id="quickTiaCalcD2">-</span></div>
            </div>
          </div>

          <button onclick="useCalculatedTIAData()" style="background: #1976d2; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; font-weight: bold;">
            ‚úì Use Calculated Data
          </button>
        </div>
      </div>

      <div id="quickTiaError" style="display: none; background: #ffebee; border: 1px solid #ef5350; border-radius: 6px; padding: 10px; color: #c30000;">
        <strong>‚ùå No matches found</strong><br>
        <span style="font-size: 0.9em;">Try searching by different road name or manually select from database below.</span>
      </div>
    </div>

    <!-- Site Selection Card -->
    <div class="card">
      <h2>1. Select Site or Manual Entry</h2>
      <div class="grid-2" style="margin-bottom: 12px; grid-template-columns: 1fr;">
        <div style="background: #e8f5e9; border: 2px solid #4caf50; border-radius: 8px; padding: 10px;">
          <label style="color: #2e7d32;">Search & Select from Database</label>
          <div style="margin-bottom: 8px;">
            <label for="macroSourceFilter" style="color: #2e7d32; font-size: 0.8em; margin-bottom: 4px;">Data Source</label>
            <select id="macroSourceFilter" style="border: 2px solid #4caf50; background-color: #f0fdf4;">
              <option value="ALL" selected>All Sources (TMR + Gold Coast + Ipswich + Logan + Toowoomba)</option>
              <option value="TMR">TMR Only</option>
              <option value="Gold Coast">Gold Coast Only</option>
              <option value="Ipswich">Ipswich Only</option>
              <option value="Logan">Logan Only</option>
              <option value="Toowoomba">Toowoomba Only</option>
            </select>
          </div>
          <input type="text" id="macroSiteSearch" list="macroSitesList" placeholder="Type Site ID or Name to autofill..." style="border: 2px solid #4caf50; background-color: #f0fdf4;" />
          <datalist id="macroSitesList"></datalist>
          <p style="font-size: 0.75em; color: #666; margin-top: 6px;">Or manually enter VADT & parameters below</p>
        </div>
      </div>

      <div id="macroSiteDetailsPanel" style="display:none; background:#e8f5e9; border:1px solid #81c784; border-radius:6px; padding:12px; margin-bottom:12px;">
        <h3 style="margin:0 0 8px 0; color:#2e7d32;">üìç Selected Site Details</h3>
        <div style="display:grid; grid-template-columns:160px 1fr; gap:6px; font-size:0.9em;">
          <div style="font-weight:700;">Site ID:</div><div id="macroDetailSiteId">-</div>
          <div style="font-weight:700;">Source:</div><div id="macroDetailSource">-</div>
          <div style="font-weight:700;">Road Name:</div><div id="macroDetailRoadName">-</div>
          <div style="font-weight:700;">Description:</div><div id="macroDetailDescription">-</div>
          <div style="font-weight:700;">Coordinates:</div><div id="macroDetailCoords">-</div>
          <div style="font-weight:700;">Google Maps:</div><div>üìç <a id="macroMapLink" href="javascript:void(0)" target="_blank" style="color:#0056b3; text-decoration:none;">View on Google Maps</a></div>
          <div style="font-weight:700;">Count Year:</div><div id="macroDetailCountYear">-</div>
          <div style="font-weight:700;">Growth Rate:</div><div id="macroDetailGrowthRate">-</div>
          <div style="font-weight:700;">HV%:</div><div id="macroDetailHV">-</div>
          <div style="font-weight:700;">Data Quality:</div><div id="macroDetailQuality">-</div>
          <div id="macroDetailD1Label" style="font-weight:700;">D1 VADT:</div><div id="macroDetailD1">-</div>
          <div id="macroDetailD2Label" style="font-weight:700;">D2 VADT:</div><div id="macroDetailD2">-</div>
          <div style="font-weight:700;">Total VADT:</div><div id="macroDetailTotal">-</div>
        </div>
      </div>

      <div style="margin-top: 10px;">
        <h3 style="margin: 0 0 6px 0; color: #1f5e63; font-size: 1rem;">Site Location </h3>
        <p style="font-size: 0.85em; color:#555; margin: 0 0 8px 0;">Select a site from search or click a marker to auto-fill inputs.</p>
        <div id="macroMap"></div>
        <div style="background:#e3f2fd; border:1px solid #64b5f6; border-radius:6px; padding:8px; margin-top:8px;">
          <p style="margin:0; font-size:0.85em; color:#1565c0;">
            <strong>Map Status:</strong> <span id="macroMapInfo">Waiting for site data...</span>
          </p>
        </div>
      </div>
    </div>

    <div class="card">
      <h2 style="display: flex; justify-content: space-between; align-items: center;">
        Analysis Parameters
        <span style="font-size: 0.75em; font-weight: normal;">
          <span style="color:#f44336;">üî¥ User Input</span> | <span style="color:#4caf50;">üü¢ Auto-calculated</span>
        </span>
      </h2>

      <!-- AUTO-FILLED TAB -->
      <fieldset style="border: 2px solid #4caf50; padding: 15px; border-radius: 8px; margin-bottom: 15px; background: #f0fdf4;">
        <legend style="padding: 0 12px; font-weight: bold; color: #2e7d32; font-size: 1.1em;">‚úì Auto-filled from Database</legend>
        <div class="grid-2">
          <div style="background: #e8f5e9; border: 1px solid #81c784; border-radius: 6px; padding: 10px;">
            <label style="color: #2e7d32; font-weight: bold;">Site ID</label>
            <input id="macroSiteId" type="text" readonly style="border: 1px solid #81c784; background-color: #f1f8f6; color: #1b5e20;" />
          </div>
          <div style="background: #e8f5e9; border: 1px solid #81c784; border-radius: 6px; padding: 10px;">
            <label style="color: #2e7d32; font-weight: bold;">Base Year</label>
            <input id="baseYear" type="number" readonly style="border: 1px solid #81c784; background-color: #f1f8f6; color: #1b5e20;" />
          </div>
          <div style="background: #e8f5e9; border: 1px solid #81c784; border-radius: 6px; padding: 10px;">
            <label style="color: #2e7d32; font-weight: bold;">HV % (from DB)</label>
            <input id="baseHVPercent" type="number" readonly style="border: 1px solid #81c784; background-color: #f1f8f6; color: #1b5e20;" />
          </div>
          <div style="background: #e8f5e9; border: 1px solid #81c784; border-radius: 6px; padding: 10px;">
            <label id="macroInputD1Label" style="color: #2e7d32; font-weight: bold;">D1 VADT (from DB)</label>
            <input id="D1_VADT" type="number" readonly style="border: 1px solid #81c784; background-color: #f1f8f6; color: #1b5e20;" />
          </div>
          <div style="background: #e8f5e9; border: 1px solid #81c784; border-radius: 6px; padding: 10px;">
            <label id="macroInputD2Label" style="color: #2e7d32; font-weight: bold;">D2 VADT (from DB)</label>
            <input id="D2_VADT" type="number" readonly style="border: 1px solid #81c784; background-color: #f1f8f6; color: #1b5e20;" />
          </div>
          <div style="background: #e8f5e9; border: 1px solid #81c784; border-radius: 6px; padding: 10px;">
            <label style="color: #2e7d32; font-weight: bold;">VADT (Auto-calc)</label>
            <input id="VADT" type="number" readonly style="border: 1px solid #81c784; background-color: #f1f8f6; color: #1b5e20;" />
          </div>
          <div style="background: #e8f5e9; border: 1px solid #81c784; border-radius: 6px; padding: 10px;">
            <label style="color: #2e7d32; font-weight: bold;">Predicted VADT @ Opening Year</label>
            <input id="predictedVADT" type="number" readonly style="border: 1px solid #81c784; background-color: #f1f8f6; color: #1b5e20;" />
          </div>
          <div style="background: #e8f5e9; border: 1px solid #81c784; border-radius: 6px; padding: 10px;">
            <label id="predictedD1Label" style="color: #2e7d32; font-weight: bold;">Predicted D1 VADT @ Opening Year</label>
            <input id="predictedD1VADT" type="number" readonly style="border: 1px solid #81c784; background-color: #f1f8f6; color: #1b5e20;" />
          </div>
          <div style="background: #e8f5e9; border: 1px solid #81c784; border-radius: 6px; padding: 10px;">
            <label id="predictedD2Label" style="color: #2e7d32; font-weight: bold;">Predicted D2 VADT @ Opening Year</label>
            <input id="predictedD2VADT" type="number" readonly style="border: 1px solid #81c784; background-color: #f1f8f6; color: #1b5e20;" />
          </div>
          <div style="background: #e8f5e9; border: 1px solid #81c784; border-radius: 6px; padding: 10px;">
            <label style="color: #2e7d32; font-weight: bold;" class="tooltip" data-tip="Directional Traffic Characterisation Algorithm">DTCA (Auto-detect)</label>
            <select id="DTCA" readonly style="border: 1px solid #81c784; background-color: #f1f8f6; color: #1b5e20; pointer-events: none;"><option>Yes</option><option>No</option></select>
          </div>
          <div style="background: #e8f5e9; border: 1px solid #81c784; border-radius: 6px; padding: 10px;">
            <label style="color: #2e7d32; font-weight: bold;">Target Year (Auto-filled, editable)</label>
            <input id="macroOpeningYear" type="number" value="" min="2024" step="1" style="border: 1px solid #81c784; background-color: #f1f8f6; color: #1b5e20;" />
          </div>
        </div>
      </fieldset>

      <!-- USER INPUT TAB -->
      <fieldset style="border: 2px solid #f44336; padding: 15px; border-radius: 8px; background: #fff8f8;">
        <legend style="padding: 0 12px; font-weight: bold; color: #c30000; font-size: 1.1em;">‚úé You Must Fill These</legend>
        
        <div class="grid" style="margin-bottom: 12px;">
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;">Growth Rate (% p.a.) *</label>
            <p style="font-size: 0.8em; color: #666; margin: 0 0 4px 0;">(auto-filled if in DB)</p>
            <input id="macroGrowthRate" type="number" value="2.5" step="0.1" style="border: 1px solid #ffc107; background-color: #fffbf0;" />
          </div>
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;">Terrain *</label>
            <select id="macroTerrainType" style="border: 1px solid #ffc107; background-color: #fffbf0;">
              <option value="flat">Flat</option>
              <option value="rolling">Rolling</option>
              <option value="mountainous">Mountainous</option>
            </select>
          </div>
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;">Road Trains (RTR)? *</label>
            <select id="RTR" style="border: 1px solid #ffc107; background-color: #fffbf0;"><option>No</option><option>Yes</option></select>
          </div>
        </div>

        <div class="grid" style="margin-bottom: 12px; border-top: 1px solid #ddd; padding-top: 12px;">
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;">D1 Lanes *</label>
            <p style="font-size: 0.8em; color: #666; margin: 0 0 4px 0;">(auto-filled if in DB)</p>
            <input id="D1_Lanes" type="number" value="1" min="1" style="border: 1px solid #ffc107; background-color: #fffbf0;" />
          </div>
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;">D2 Lanes *</label>
            <p style="font-size: 0.8em; color: #666; margin: 0 0 4px 0;">(auto-filled if in DB)</p>
            <input id="D2_Lanes" type="number" value="1" min="1" style="border: 1px solid #ffc107; background-color: #fffbf0;" />
          </div>
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;">HV (%) *</label>
            <p style="font-size: 0.8em; color: #666; margin: 0 0 4px 0;">(auto-filled if in DB)</p>
            <input id="HVP" type="number" value="5" step="0.1" style="border: 1px solid #ffc107; background-color: #fffbf0;" />
          </div>
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;" class="tooltip" data-tip="Directional Heavy Vehicle Percentage Allocation">DHVPA *</label>
            <select id="DHVPA" style="border: 1px solid #ffc107; background-color: #fffbf0;"><option>Yes</option><option selected>No</option></select>
          </div>
        </div>

        <div class="grid" style="margin-bottom: 12px; border-top: 1px solid #ddd; padding-top: 12px;">
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;">D1 HV% *</label>
            <input id="D1_HVP" type="number" value="5" step="0.1" style="border: 1px solid #ffc107; background-color: #fffbf0;" />
          </div>
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;">D2 HV% *</label>
            <input id="D2_HVP" type="number" value="5" step="0.1" style="border: 1px solid #ffc107; background-color: #fffbf0;" />
          </div>
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;">RTP (%) *</label>
            <input id="RTP" type="number" value="0" step="0.1" style="border: 1px solid #ffc107; background-color: #fffbf0;" />
          </div>
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;" class="tooltip" data-tip="Directional Road Train Percentage Allocation">DRTPA *</label>
            <select id="DRTPA" style="border: 1px solid #ffc107; background-color: #fffbf0;"><option>Yes</option><option selected>No</option></select>
          </div>
        </div>

        <div class="grid" style="border-top: 1px solid #ddd; padding-top: 12px;">
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;">D1 RT% *</label>
            <input id="D1_RTP" type="number" value="0" step="0.1" style="border: 1px solid #ffc107; background-color: #fffbf0;" />
          </div>
          <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px;">
            <label style="color: #c30000; font-weight: bold;">D2 RT% *</label>
            <input id="D2_RTP" type="number" value="0" step="0.1" style="border: 1px solid #ffc107; background-color: #fffbf0;" />
          </div>
        </div>
      </fieldset>

      <div style="position: sticky; bottom: 20px; z-index: 100; margin-top: 20px;">
        <button id="calcBtn" style="padding: 16px; font-size: 1.1em; font-weight: bold; background: var(--brand); color: white; border: none; border-radius: 12px; cursor: pointer; width: 100%; box-shadow: 0 8px 20px rgba(31, 94, 99, 0.3); transition: transform 0.1s, box-shadow 0.1s;">
          üöÄ Calculate All Metrics
        </button>
      </div>
    </div>

    <details class="card">
      <summary style="font-weight:700; color:#1f5e63; cursor:pointer;">Quick KPI (Optional)</summary>
      <div class="kpi-grid" style="margin-top:12px;">
        <div class="kpi"><div class="kpi-label">Design Volume (DV)</div><div class="kpi-value" id="kpiDV">-</div></div>
        <div class="kpi"><div class="kpi-label">D1 Peak Queue (2m)</div><div class="kpi-value" id="kpiD1PeakQueue">-</div></div>
        <div class="kpi"><div class="kpi-label">D2 Peak Queue (2m)</div><div class="kpi-value" id="kpiD2PeakQueue">-</div></div>
        <div class="kpi"><div class="kpi-label">Worst V/C Ratio</div><div class="kpi-value" id="kpiWorstVcr">-</div></div>
        <div class="kpi"><div class="kpi-label">SLRF Peak</div><div class="kpi-value" id="kpiSlrfPeak">-</div></div>
        <div class="kpi"><div class="kpi-label">Road Train Rule</div><div class="kpi-value" id="kpiRoadTrain">-</div></div>
      </div>
    </details>

    <div class="card">
      <h2>Grouped Directional Summary</h2>
      
      <h3 id="groupedHeaderD2" class="dir-heading dir-heading-negative">üî¥ Against Gazettal (D2)</h3>
      <div class="table-wrap">
        <table id="groupedTableD2">
          <thead>
            <tr>
              <th>Metric</th>
              <th>AM</th>
              <th>OP</th>
              <th>PM</th>
              <th>EV</th>
              <th>Daily Total</th>
            </tr>
          </thead>
          <tbody id="groupedBodyD2"></tbody>
        </table>
      </div>

      <h3 id="groupedHeaderD1" class="dir-heading dir-heading-spaced dir-heading-positive">üü¢ Gazettal (D1)</h3>
      <div class="table-wrap">
        <table id="groupedTableD1">
          <thead>
            <tr>
              <th>Metric</th>
              <th>AM</th>
              <th>OP</th>
              <th>PM</th>
              <th>EV</th>
              <th>Daily Total</th>
            </tr>
          </thead>
          <tbody id="groupedBodyD1"></tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h2>Queue Length Estimation</h2>
      <div id="queueRiskBadge" style="display:none; margin: 6px 0 10px 0; padding: 8px 10px; border-radius: 6px; background: #fff3e0; border: 1px solid #ffcc80; color: #e65100; font-weight: 700; font-size: 0.9em;"></div>

      <div id="queueTableView">
        <h3 id="queueHeaderD2" class="dir-heading dir-heading-negative">üî¥ Against Gazettal (D2)</h3>
        <div class="table-wrap">
          <table id="queueGroupedTableD2">
            <thead>
              <tr>
                <th>Queue Duration</th>
                <th>AM</th>
                <th>OP</th>
                <th>PM</th>
                <th>EV</th>
                <th>Max Queue</th>
              </tr>
            </thead>
            <tbody id="queueGroupedBodyD2"></tbody>
          </table>
        </div>

        <h3 id="queueHeaderD1" class="dir-heading dir-heading-spaced dir-heading-positive">üü¢ Gazettal (D1)</h3>
        <div class="table-wrap">
          <table id="queueGroupedTableD1">
            <thead>
              <tr>
                <th>Queue Duration</th>
                <th>AM</th>
                <th>OP</th>
                <th>PM</th>
                <th>EV</th>
                <th>Max Queue</th>
              </tr>
            </thead>
            <tbody id="queueGroupedBodyD1"></tbody>
          </table>
        </div>
      </div>

      <div id="queueChartView" style="display: none;">
        <h3 id="queueHeaderD2Chart" class="dir-heading dir-heading-negative">üî¥ Against Gazettal (D2)</h3>
        <div class="chart-panel">
          <canvas id="queueChartD2" class="chart-canvas-300"></canvas>
        </div>

        <h3 id="queueHeaderD1Chart" class="dir-heading dir-heading-spaced dir-heading-positive">üü¢ Gazettal (D1)</h3>
        <div class="chart-panel">
          <canvas id="queueChartD1" class="chart-canvas-300"></canvas>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>VCR / LOS Analysis</h2>
      <div id="vcrRiskBadge" style="display:none; margin: 6px 0 10px 0; padding: 8px 10px; border-radius: 6px; background: #ffebee; border: 1px solid #ef9a9a; color: #b71c1c; font-weight: 700; font-size: 0.9em;"></div>

      <div id="vcrTableView">
      
      <h3 id="vcrHeaderD2" class="dir-heading dir-heading-negative">üî¥ Against Gazettal (D2)</h3>
      <div class="table-wrap" style="width:100%;">
        <table id="vcrGroupedTableD2">
          <thead>
            <tr><th>Metric</th><th>AM</th><th>OP</th><th>PM</th><th>EV</th></tr>
          </thead>
          <tbody id="vcrGroupedBodyD2"></tbody>
        </table>
      </div>

      <h3 id="vcrHeaderD1" class="dir-heading dir-heading-spaced dir-heading-positive">üü¢ Gazettal (D1)</h3>
      <div class="table-wrap" style="width:100%;">
        <table id="vcrGroupedTableD1">
          <thead>
            <tr><th>Metric</th><th>AM</th><th>OP</th><th>PM</th><th>EV</th></tr>
          </thead>
          <tbody id="vcrGroupedBodyD1"></tbody>
        </table>
      </div>
      </div>

      <div id="vcrChartView" style="display: none;">
        <h3 id="vcrHeaderD2Chart" class="dir-heading dir-heading-negative">üî¥ Against Gazettal (D2)</h3>
        <div class="chart-panel">
          <canvas id="vcrChartD2" class="chart-canvas-280"></canvas>
        </div>

        <h3 id="vcrHeaderD1Chart" class="dir-heading dir-heading-spaced dir-heading-positive">üü¢ Gazettal (D1)</h3>
        <div class="chart-panel">
          <canvas id="vcrChartD1" class="chart-canvas-280"></canvas>
        </div>
      </div>
      <p class="table-note">* Design Volume is greater of 30th highest hour of AADT or 500.</p>
    </div>

    <details class="card" id="optionalFeaturesSection">
      <summary style="cursor: pointer; font-size: 1.2em; font-weight: 700; color: #1f5e63; margin-bottom: 10px;">Optional Features</summary>

    <div class="card" id="roadTypeSensitivityCard" style="border: 2px solid #0288d1; background: #e1f5fe;">
      <h2 style="display: flex; justify-content: space-between; align-items: center; border-bottom: none; margin-bottom: 0; color: #01579b;">
        üß† Road Type Sensitivity (Quick Search)
        <button type="button" class="print-toggle-btn" data-target-card="roadTypeSensitivityCard" aria-pressed="true">Include in Print: Yes</button>
      </h2>
      <p style="font-size: 0.85em; color: #555; margin: 4px 0 12px 0;">
        Tune how the model classifies residential vs busy roads and applies traffic scaling in quick search estimates.
      </p>
      <div class="grid" style="margin-bottom: 0;">
        <div style="background: #ffffff; border: 1px solid #81d4fa; border-radius: 6px; padding: 10px;">
          <label style="color: #01579b;">Residential Max Avg VADT</label>
          <input type="number" id="rtResidentialMaxVadt" value="4500" min="500" step="100" oninput="updateTiaCalculations()" style="border: 1px solid #81d4fa;" />
        </div>
        <div style="background: #ffffff; border: 1px solid #81d4fa; border-radius: 6px; padding: 10px;">
          <label style="color: #01579b;">Busy Min Avg VADT</label>
          <input type="number" id="rtBusyMinVadt" value="14000" min="3000" step="500" oninput="updateTiaCalculations()" style="border: 1px solid #81d4fa;" />
        </div>
        <div style="background: #ffffff; border: 1px solid #81d4fa; border-radius: 6px; padding: 10px;">
          <label style="color: #01579b;">Residential Factor (%)</label>
          <input type="number" id="rtResidentialFactor" value="50" min="30" max="100" step="1" oninput="updateTiaCalculations()" style="border: 1px solid #81d4fa;" />
        </div>
        <div style="background: #ffffff; border: 1px solid #81d4fa; border-radius: 6px; padding: 10px;">
          <label style="color: #01579b;">Mixed Factor (%)</label>
          <input type="number" id="rtMixedFactor" value="80" min="50" max="120" step="1" oninput="updateTiaCalculations()" style="border: 1px solid #81d4fa;" />
        </div>
        <div style="background: #ffffff; border: 1px solid #81d4fa; border-radius: 6px; padding: 10px;">
          <label style="color: #01579b;">Busy Factor (%)</label>
          <input type="number" id="rtBusyFactor" value="100" min="70" max="130" step="1" oninput="updateTiaCalculations()" style="border: 1px solid #81d4fa;" />
        </div>
      </div>
    </div>

    <div class="card" id="speedDelayCard" style="border: 2px solid #546e7a; background: #eceff1;">
      <h2 style="display: flex; justify-content: space-between; align-items: center; border-bottom: none; margin-bottom: 0; color: #37474f;">
        üìâ Speed Reduction Travel Time Impact
        <button type="button" class="print-toggle-btn" data-target-card="speedDelayCard" aria-pressed="true">Include in Print: Yes</button>
      </h2>
      <p style="font-size: 0.85em; color: #555; margin: 4px 0 12px 0;">
        Calculates the baseline time penalty added to every vehicle passing through the work zone due to reduced speed limits, assuming free-flowing conditions (no queuing).
      </p>

      <div class="grid" style="margin-bottom: 12px;">
        <div style="background: #ffffff; border: 1px solid #b0bec5; border-radius: 6px; padding: 10px;">
          <label style="color: #455a64;" class="tooltip" data-tip="Existing posted speed limit.">Normal Speed (km/h)</label>
          <input type="number" id="srNormSpeed" value="80" step="10" min="10" oninput="calculateSpeedDelay()" style="border: 1px solid #b0bec5;" />
        </div>
        <div style="background: #ffffff; border: 1px solid #b0bec5; border-radius: 6px; padding: 10px;">
          <label style="color: #455a64;" class="tooltip" data-tip="Reduced speed limit during roadworks.">Work Speed (km/h)</label>
          <input type="number" id="srWorkSpeed" value="40" step="10" min="10" oninput="calculateSpeedDelay()" style="border: 1px solid #b0bec5;" />
        </div>
        <div style="background: #ffffff; border: 1px solid #b0bec5; border-radius: 6px; padding: 10px;">
          <label style="color: #455a64;" class="tooltip" data-tip="Total length of the reduced speed zone, including advance warning signs.">Zone Length (m)</label>
          <input type="number" id="srLength" value="1000" step="50" min="50" oninput="calculateSpeedDelay()" style="border: 1px solid #b0bec5;" />
        </div>
      </div>

      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px;">
        <div style="background: #ffffff; border-left: 5px solid #ffb300; padding: 12px; border-radius: 6px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
          <div style="font-size: 0.8em; color: #666; font-weight: bold; text-transform: uppercase;">Added Delay Per Vehicle</div>
          <div id="srPerVehicle" style="font-size: 1.6em; font-weight: bold; color: #ff8f00; margin-top: 4px;">-</div>
          <div id="srTransitText" style="font-size: 0.8em; color: #777; margin-top: 4px;">-</div>
        </div>
        
        <div style="background: #ffffff; border-left: 5px solid #d32f2f; padding: 12px; border-radius: 6px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
          <div style="font-size: 0.8em; color: #666; font-weight: bold; text-transform: uppercase;" class="tooltip" data-tip="Delay per vehicle multiplied by the total daily traffic volume (VADT).">Total Daily Network Delay</div>
          <div id="srTotalHours" style="font-size: 1.6em; font-weight: bold; color: #c62828; margin-top: 4px;">-</div>
          <div style="font-size: 0.8em; color: #777; margin-top: 4px;">Lost hours per day</div>
        </div>
      </div>
    </div>

    <div class="card" id="workWindowCard" style="display: none; border: 2px solid #1f5e63;">
      <h2 style="display: flex; justify-content: space-between; align-items: center; border-bottom: none; margin-bottom: 0;">
        ‚è±Ô∏è Work Window Optimizer (Auto-Scheduler)
        <div style="font-size: 0.8em; font-weight: normal; display: flex; align-items: center; gap: 8px; background: #f0fdf4; padding: 6px 12px; border-radius: 8px; border: 1px solid #81c784;">
          <label style="margin:0; color:#2e7d32; font-weight: bold;" class="tooltip" data-tip="Maximum Volume-to-Capacity Ratio permitted during roadworks.">Max Allowable VCR:</label>
          <input type="number" id="wwMaxVcr" value="0.85" step="0.05" min="0.5" max="1.5" style="width: 70px; padding: 4px 8px; font-size:1em; border: 1px solid #4caf50; border-radius: 4px;" onchange="generateWorkWindow()" />
          <button type="button" class="print-toggle-btn" data-target-card="workWindowCard" aria-pressed="true">Include in Print: Yes</button>
        </div>
      </h2>
      <p style="font-size: 0.85em; color: #666; margin: 4px 0 16px 0;">
        Displays permitted working hours based on hourly traffic volumes. Calculates <strong>Single Lane Closure (SLC)</strong> for multi-lane roads, or <strong>Single Lane Reversible Flow (SLRF)</strong> for single-lane roads.
      </p>
      
      <div id="wwTimeline" style="display: flex; width: 100%; height: 50px; border-radius: 8px; overflow: hidden; border: 1px solid #ccc; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);">
        </div>
      
      <div style="display: flex; width: 100%; justify-content: space-between; font-size: 0.75em; color: #666; margin-top: 4px; padding: 0 4px;">
        <span>00:00</span><span>06:00</span><span>12:00</span><span>18:00</span><span>23:59</span>
      </div>

      <div id="wwSummary" style="margin-top: 12px; font-weight: bold; text-align: center; padding: 10px; border-radius: 6px; background: #f9f9f9; border: 1px dashed #ccc;">
        Waiting for calculation...
      </div>
    </div>

    <div class="card" id="stopGoCard" style="border: 2px solid #fb8c00;">
      <h2 style="display: flex; justify-content: space-between; align-items: center; border-bottom: none; margin-bottom: 0; color: #e65100;">
        üö¶ Stop/Go Shuttle Simulator
        <button type="button" class="print-toggle-btn" data-target-card="stopGoCard" aria-pressed="true">Include in Print: Yes</button>
      </h2>
      <p style="font-size: 0.85em; color: #666; margin: 4px 0 12px 0;">
        Calculates signal timings and queues for single-lane reversible flow operations (portable traffic lights or Stop/Go). Based on the peak hourly volume of your selected profile.
      </p>
      
      <div class="grid" style="margin-bottom: 12px;">
        <div style="background: #fff3e0; border: 1px solid #ffb74d; border-radius: 6px; padding: 10px;">
          <label style="color: #e65100;" class="tooltip" data-tip="Total distance between the two Stop/Go boards or portable traffic lights.">Work Zone Length (m)</label>
          <input type="number" id="sgLength" value="300" step="10" min="10" oninput="calculateStopGo()" style="border: 1px solid #ffb74d; background: #fff8e1;" />
        </div>
        <div style="background: #fff3e0; border: 1px solid #ffb74d; border-radius: 6px; padding: 10px;">
          <label style="color: #e65100;" class="tooltip" data-tip="Posted speed limit through the work zone during the closure.">Work Zone Speed (km/h)</label>
          <input type="number" id="sgSpeed" value="40" step="10" min="10" oninput="calculateStopGo()" style="border: 1px solid #ffb74d; background: #fff8e1;" />
        </div>
        <div style="background: #fff3e0; border: 1px solid #ffb74d; border-radius: 6px; padding: 10px;">
          <label style="color: #e65100;" class="tooltip" data-tip="Target maximum time for a full cycle (Green 1 + Clearance + Green 2 + Clearance). Usually 120s - 300s.">Max Cycle Time (sec)</label>
          <input type="number" id="sgCycle" value="240" step="10" min="60" oninput="calculateStopGo()" style="border: 1px solid #ffb74d; background: #fff8e1;" />
        </div>
      </div>

      <div id="sgResults" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; text-align: center;">
        <div style="background: #f1f8e9; border: 1px solid #8bc34a; border-radius: 8px; padding: 10px;">
          <div style="font-size: 0.8em; color: #33691e; font-weight: bold; text-transform: uppercase;">D1 Green Time</div>
          <div id="sgD1Green" style="font-size: 1.5em; font-weight: bold; color: #2e7d32;">-</div>
          <div id="sgD1Queue" style="font-size: 0.85em; color: #555; margin-top: 4px;">Max Queue: -</div>
        </div>
        <div style="background: #ffebee; border: 1px solid #ef5350; border-radius: 8px; padding: 10px;">
          <div style="font-size: 0.8em; color: #b71c1c; font-weight: bold; text-transform: uppercase;" class="tooltip" data-tip="Time required to safely clear the one-lane section before releasing the other side.">All-Red Clearance</div>
          <div id="sgClearance" style="font-size: 1.5em; font-weight: bold; color: #c30000;">-</div>
          <div style="font-size: 0.85em; color: #555; margin-top: 4px;">Applied twice per cycle</div>
        </div>
        <div style="background: #f1f8e9; border: 1px solid #8bc34a; border-radius: 8px; padding: 10px;">
          <div style="font-size: 0.8em; color: #33691e; font-weight: bold; text-transform: uppercase;">D2 Green Time</div>
          <div id="sgD2Green" style="font-size: 1.5em; font-weight: bold; color: #2e7d32;">-</div>
          <div id="sgD2Queue" style="font-size: 0.85em; color: #555; margin-top: 4px;">Max Queue: -</div>
        </div>
      </div>
      
      <div id="sgWarning" style="display: none; margin-top: 10px; padding: 8px; background: #fff3cd; color: #856404; border: 1px solid #ffeeba; border-radius: 6px; font-size: 0.9em; text-align: center; font-weight: bold;">
        ‚ö†Ô∏è Warning message here
      </div>
    </div>

    <div class="card" id="detourCard" style="border: 2px solid #8e24aa;">
      <h2 style="display: flex; justify-content: space-between; align-items: center; border-bottom: none; margin-bottom: 0; color: #6a1b9a;">
        üîÑ Detailed Detour Route Capacity
        <button type="button" class="print-toggle-btn" data-target-card="detourCard" aria-pressed="true">Include in Print: Yes</button>
      </h2>
      <p style="font-size: 0.85em; color: #666; margin: 4px 0 12px 0;">
        Merges the 24-hour hourly profile of the primary site with the detour site to identify specific peak-period failures.
      </p>
      
      <div style="display: flex; gap: 15px; flex-wrap: wrap; margin-bottom: 15px;">
        
        <div style="flex: 1; min-width: 300px; display: flex; flex-direction: column; gap: 12px;">
          <div style="background: #f3e5f5; border: 1px solid #ce93d8; border-radius: 6px; padding: 10px;">
            <label style="color: #6a1b9a; font-weight: bold;">Diversion Rate (%)</label>
            <input type="number" id="detourDiversionRate" value="80" step="5" min="0" max="100" oninput="calculateDetourOverlay()" style="border: 1px solid #ce93d8; background: #faf0e6; width: 100%;" />
          </div>
          
          <div style="background: #f3e5f5; border: 1px solid #ce93d8; border-radius: 6px; padding: 10px; flex-grow: 1; display: flex; flex-direction: column; height: 320px;">
            <label style="color: #6a1b9a; font-weight: bold; margin-bottom: 8px;">Select Detour Route (Auto-Scanned)</label>
            <div id="detourListContainer" style="overflow-y: auto; flex-grow: 1; display: flex; flex-direction: column; gap: 6px; padding-right: 4px;">
              <div style="padding: 10px; text-align: center; color: #666; font-style: italic;">-- Select a Primary Site First --</div>
            </div>
            <select id="detourSiteSelect" style="display: none;"></select>
          </div>
        </div>

        <div style="flex: 1.5; min-width: 300px;">
          <div id="detourMap" style="height: 100%; min-height: 400px; width: 100%; border: 2px solid #ce93d8; border-radius: 6px; z-index: 1;"></div>
        </div>
      </div>

      <div id="detourResults" style="display: none; margin-top: 15px; border-top: 2px dashed #ce93d8; padding-top: 15px;">
        <h4 style="margin: 0 0 10px 0; color: #333; text-align: center;" id="detourRouteName">-</h4>
        
        <div class="table-wrap">
          <table style="width: 100%;">
            <thead>
              <tr>
                <th style="background: #6a1b9a;">Period</th>
                <th style="background: #6a1b9a;">Base Detour VCR</th>
                <th style="background: #6a1b9a;">Added Diverted Vol</th>
                <th style="background: #6a1b9a;">New Detour VCR</th>
              </tr>
            </thead>
            <tbody id="detourDetailedBody"></tbody>
          </table>
        </div>
        <p style="font-size: 0.85em; color: #666; margin: 10px 0 0 0; text-align: center;" id="detourWarningText"></p>
      </div>
    </div>

    <div class="card" id="pedestrianCard" style="border: 2px solid #00897b; background: #e0f2f1;">
      <h2 style="display: flex; justify-content: space-between; align-items: center; border-bottom: none; margin-bottom: 0; color: #004d40;">
        üö∂ Pedestrian Detour Impact
        <button type="button" class="print-toggle-btn" data-target-card="pedestrianCard" aria-pressed="true">Include in Print: Yes</button>
      </h2>
      <p style="font-size: 0.85em; color: #555; margin: 4px 0 12px 0;">
        Calculates estimated maximum pedestrian delay using route distances, walking speed, and controlled/uncontrolled crossing delays.
      </p>

      <div class="grid" style="margin-bottom: 12px;">
        <div style="background: #ffffff; border: 1px solid #80cbc4; border-radius: 6px; padding: 10px;">
          <label style="color: #00695c;" class="tooltip" data-tip="Distance of the original uninterrupted pedestrian path.">Normal Path Length (m)</label>
          <input type="number" id="pedNormDist" value="100" step="10" min="0" oninput="calculatePedestrianDelay()" style="border: 1px solid #80cbc4;" />
        </div>
        <div style="background: #ffffff; border: 1px solid #80cbc4; border-radius: 6px; padding: 10px;">
          <label style="color: #00695c;" class="tooltip" data-tip="Total distance of the new detour path.">Detour Path Length (m)</label>
          <input type="number" id="pedDetourDist" value="250" step="10" min="0" oninput="calculatePedestrianDelay()" style="border: 1px solid #80cbc4;" />
        </div>
        <div style="background: #ffffff; border: 1px solid #80cbc4; border-radius: 6px; padding: 10px;">
          <label style="color: #00695c;" class="tooltip" data-tip="Number of controlled crossings in the detour path.">No. Controlled Crossings</label>
          <input type="number" id="pedControlledCount" value="2" step="1" min="0" oninput="calculatePedestrianDelay()" style="border: 1px solid #80cbc4;" />
        </div>
        <div style="background: #ffffff; border: 1px solid #80cbc4; border-radius: 6px; padding: 10px;">
          <label style="color: #00695c;" class="tooltip" data-tip="Number of uncontrolled crossings in the detour path.">No. Uncontrolled Crossings</label>
          <input type="number" id="pedUncontrolledCount" value="0" step="1" min="0" oninput="calculatePedestrianDelay()" style="border: 1px solid #80cbc4;" />
        </div>
        <div style="background: #ffffff; border: 1px solid #80cbc4; border-radius: 6px; padding: 10px;">
          <label style="color: #00695c;" class="tooltip" data-tip="Assumed pedestrian travel speed.">Pedestrian Speed (m/s)</label>
          <input type="number" id="pedWalkSpeed" value="1.2" step="0.1" min="0.1" oninput="calculatePedestrianDelay()" style="border: 1px solid #80cbc4;" />
        </div>
        <div style="background: #ffffff; border: 1px solid #80cbc4; border-radius: 6px; padding: 10px;">
          <label style="color: #00695c;" class="tooltip" data-tip="Expected delay at each controlled crossing (Hold and Release).">Controlled Crossing Delay (s)</label>
          <input type="number" id="pedControlledDelay" value="60" step="5" min="0" oninput="calculatePedestrianDelay()" style="border: 1px solid #80cbc4;" />
        </div>
        <div style="background: #ffffff; border: 1px solid #80cbc4; border-radius: 6px; padding: 10px;">
          <label style="color: #00695c;" class="tooltip" data-tip="Expected delay at each uncontrolled crossing.">Uncontrolled Crossing Delay (s)</label>
          <input type="number" id="pedUncontrolledDelay" value="10" step="5" min="0" oninput="calculatePedestrianDelay()" style="border: 1px solid #80cbc4;" />
        </div>
      </div>

      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px;">
        <div style="background: #ffffff; border-left: 5px solid #00897b; padding: 12px; border-radius: 6px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
          <div style="font-size: 0.8em; color: #666; font-weight: bold; text-transform: uppercase;">Estimated Maximum Added Delay</div>
          <div id="pedAddedDelay" style="font-size: 1.6em; font-weight: bold; color: #00695c; margin-top: 4px;">-</div>
          <div id="pedTransitText" style="font-size: 0.8em; color: #777; margin-top: 4px;">Existing time + detour time + crossing delay model</div>
        </div>
      </div>

      <div class="table-wrap" style="margin-top: 12px;">
        <table id="pedDetailTable">
          <thead>
            <tr>
              <th>Existing Route Time (s)</th>
              <th>Detoured Route Time (s)</th>
              <th>Crossing Delay (s)</th>
              <th>Added Delay (s)</th>
              <th>Added Delay (min)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td id="pedExistingTime">-</td>
              <td id="pedDetouredTime">-</td>
              <td id="pedCrossingDelay">-</td>
              <td id="pedAddedDelaySec">-</td>
              <td id="pedAddedDelayMin">-</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    </details>

    <details class="card" id="formulaTraceSection">
      <summary style="cursor: pointer; font-size: 1.2em; font-weight: 700; color: #1f5e63; margin-bottom: 10px;">Formula Trace (Click to Expand)</summary>
      <div id="assumptionsCard" style="margin-bottom: 12px;">
        <h3 style="margin: 0 0 10px 0; color: #1f5e63;">Analysis Assumptions</h3>
        <div class="assumptions-grid">
          <div class="assumption-item"><div class="assumption-key">DTCA Path</div><div class="assumption-value" id="assumptionDtca">-</div></div>
          <div class="assumption-item"><div class="assumption-key">HV Source</div><div class="assumption-value" id="assumptionHvSource">-</div></div>
          <div class="assumption-item"><div class="assumption-key">RT Source</div><div class="assumption-value" id="assumptionRtSource">-</div></div>
          <div class="assumption-item"><div class="assumption-key">Growth Source</div><div class="assumption-value" id="assumptionGrowthSource">-</div></div>
          <div class="assumption-item"><div class="assumption-key">Lane Source</div><div class="assumption-value" id="assumptionLaneSource">-</div></div>
          <div class="assumption-item"><div class="assumption-key">Profile Source</div><div class="assumption-value" id="assumptionProfileSource">-</div></div>
        </div>
      </div>
      <div class="table-wrap">
        <table id="traceTable">
          <thead>
            <tr><th>Trace Item</th><th>Applied Value / Rule</th></tr>
          </thead>
          <tbody id="traceBody"></tbody>
        </table>
      </div>
    </details>

    <details class="card" id="hourlyEstimateCard">
      <summary style="cursor: pointer; font-size: 1.2em; font-weight: 700; color: #1f5e63; margin-bottom: 10px;">HOURLY ESTIMATE (Click to Expand)</summary>
      <p style="margin: 6px 0 12px 0; font-size: 0.86em; color: #37474f; background: #f1f8ff; border: 1px solid #bbdefb; border-radius: 6px; padding: 8px 10px;">
        <strong>Bucket Definition:</strong> AM (07:00-09:00, MORNING PEAK), OP (09:00-16:00, MORNING OFF PEAK), PM (16:00-18:00, EVENING PEAK), EV (18:00-07:00, EVENING OFF PEAK).
      </p>

      <h3 style="margin: 10px 0 8px 0; color: #1f5e63; font-size: 1.0em;">1. QUEUE LENGTH (Hourly Basis)</h3>
      <div id="hourlyQueueTableView">
        <div class="table-wrap">
          <table id="hourlyQueueTable">
            <thead>
              <tr>
                <th>Hour</th>
                <th>Hour Type</th>
                <th>D1 Max Queue (m)</th>
                <th>D2 Max Queue (m)</th>
                <th>Network Max Queue (m)</th>
              </tr>
            </thead>
            <tbody id="hourlyQueueBody"></tbody>
          </table>
        </div>
      </div>
      <div id="hourlyQueueChartView" class="chart-panel" style="display:none; margin-bottom: 8px;">
        <canvas id="hourlyQueueChart" class="chart-canvas-360"></canvas>
      </div>

      <h3 style="margin: 18px 0 8px 0; color: #1f5e63; font-size: 1.0em;">2. VCR (Hourly Basis)</h3>
      <div id="hourlyVcrTableView">
        <div class="table-wrap">
          <table id="hourlyVcrTable">
            <thead>
              <tr>
                <th>Hour</th>
                <th>D1 Base VCR (LOS)</th>
                <th>D1 Work VCR (LOS)</th>
                <th>D2 Base VCR (LOS)</th>
                <th>D2 Work VCR (LOS)</th>
                <th>Worst Hourly VCR</th>
              </tr>
            </thead>
            <tbody id="hourlyVcrBody"></tbody>
          </table>
        </div>
      </div>
      <div id="hourlyVcrChartView" class="chart-panel" style="display:none; margin-bottom: 8px;">
        <canvas id="hourlyVcrChart" class="chart-canvas-360"></canvas>
      </div>
    </details>

    <!-- Data Visualization (Moved to report end) -->
    <details class="card" id="macroDataVizSection" style="display:none;">
      <summary id="macroDataVizSummaryText" style="cursor: pointer; font-size: 1.1em; font-weight: 700; color: #1f5e63; padding: 10px 0;">
        üìä Traffic Data Visualization (Click to Expand)
      </summary>
      <div style="margin-top: 15px;">
        <p id="macroDataVizSourceText" style="margin: 0 0 10px 0; font-size: 0.86em; color: #455a64; background: #f5f8fa; border: 1px solid #d7e2e8; border-radius: 6px; padding: 7px 10px;">
          Source: Selected traffic profile
        </p>
        <h3 style="color: #1f5e63; margin: 0 0 10px 0;">Hourly Traffic Profile</h3>
        <div class="chart-panel">
          <canvas id="macroHourlyChart" class="chart-canvas-350"></canvas>
        </div>
        
        <h3 style="color: #1f5e63; margin: 20px 0 10px 0;">Directional Distribution</h3>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
          <div>
            <h4 id="macroDataVizD1Heading" style="text-align: center; color: #2e7d32; margin: 0 0 10px 0;">Gazettal</h4>
            <canvas id="macroD1PieChart" class="chart-canvas-250"></canvas>
          </div>
          <div>
            <h4 id="macroDataVizD2Heading" style="text-align: center; color: #c30000; margin: 0 0 10px 0;">Against Gazettal</h4>
            <canvas id="macroD2PieChart" class="chart-canvas-250"></canvas>
          </div>
        </div>
        
        <h3 style="color: #1f5e63; margin: 20px 0 10px 0;">Peak Hour Analysis</h3>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
          <div style="background: #e8f5e9; border: 1px solid #4caf50; border-radius: 8px; padding: 12px;">
            <h4 id="macroDataVizD1PeakHeading" style="color: #2e7d32; margin: 0 0 8px 0;">Gazettal Peak Hours</h4>
            <div id="macroD1PeakHours" style="font-size: 0.9em;"></div>
          </div>
          <div style="background: #ffebee; border: 1px solid #ef5350; border-radius: 8px; padding: 12px;">
            <h4 id="macroDataVizD2PeakHeading" style="color: #c30000; margin: 0 0 8px 0;">Against Gazettal Peak Hours</h4>
            <div id="macroD2PeakHours" style="font-size: 0.9em;"></div>
          </div>
        </div>
      </div>
    </details>

    <details class="card diag-card" id="selfDiagnosticsCard" style="display:none;">
      <summary style="cursor: pointer; font-size: 1em; font-weight: 700; color: #1f5e63; margin-bottom: 10px;">üß™ Internal Diagnostics (Hidden)</summary>
      <div style="display:flex; justify-content: space-between; align-items: center; gap: 10px; margin-bottom: 8px; flex-wrap: wrap;">
        <p id="diagSummaryText" class="diag-summary">Run diagnostics to check formula consistency.</p>
        <button id="runDiagnosticsBtn" type="button" class="diag-btn">Run Deep Self-Check</button>
      </div>
      <div class="table-wrap">
        <table id="diagTable">
          <thead>
            <tr>
              <th>Check</th>
              <th>Status</th>
              <th>Details</th>
            </tr>
          </thead>
          <tbody id="diagBody"></tbody>
        </table>
      </div>
      <p class="diag-note">Hidden panel: open with Ctrl+Shift+D or add ?debug=1 to URL.</p>
    </details>

    <details class="card print-custom-card" id="printCustomizationCard">
      <summary style="cursor: pointer; font-size: 1em; font-weight: 700; color: #1f5e63; margin-bottom: 10px;">üñ®Ô∏è Print Customization (All Sections & Tables)</summary>
      <p style="margin: 0 0 10px 0; font-size: 0.85rem; color: #546e7a;">Toggle any section or table to fully customize what appears in the printed report.</p>
      <div class="print-custom-actions">
        <button type="button" id="printSelectAllBtn">All: Yes</button>
        <button type="button" id="printDeselectAllBtn">All: No</button>
        <button type="button" id="printSelectCardsBtn">Sections: Yes</button>
        <button type="button" id="printDeselectCardsBtn">Sections: No</button>
        <button type="button" id="printSelectTablesBtn">Tables: Yes</button>
        <button type="button" id="printDeselectTablesBtn">Tables: No</button>
      </div>
      <div class="print-custom-grid">
        <div>
          <h3 style="margin: 0 0 6px 0; font-size: 0.95rem; color: #1f5e63;">Sections <span class="print-scope-badge">Card/Details</span></h3>
          <div id="printCardToggleList" class="print-custom-list"></div>
        </div>
        <div>
          <h3 style="margin: 0 0 6px 0; font-size: 0.95rem; color: #1f5e63;">Tables <span class="print-scope-badge">Table/Table Wrap</span></h3>
          <div id="printTableToggleList" class="print-custom-list"></div>
        </div>
      </div>
    </details>

    <div class="report-actions">
      <button class="print-btn" onclick="printReport()">üñ®Ô∏è Print Report</button>
    </div>
  </div>

  <div class="copyright-footer" style="text-align: center; color: #7a7a7a; font-size: 0.85em; padding: 14px 0 18px 0;">Copyright@SANJU BHANDARI 2026</div>
</div>
</div>
</div>
<script>
  // ===== GITHUB CONFIG & DATA LOADING =====
  const GITHUB_TMR_URL = 'https://raw.githubusercontent.com/crsanju/Cromton_Traffic_Analysis/main/tmr.geojson';
  const GITHUB_GOLDCOAST_URL = 'https://raw.githubusercontent.com/crsanju/Crompton_TIA_QUEUE/refs/heads/main/goldcoast.geojson';
  const GITHUB_IPSWICH_URL = 'https://raw.githubusercontent.com/crsanju/Crompton_TIA_QUEUE/refs/heads/main/Ipswich.geojson';
  const GITHUB_LOGAN_URL = 'https://raw.githubusercontent.com/crsanju/Crompton_TIA_QUEUE/main/logan.geojson';
  const GITHUB_TOOWOOMBA_URL = 'https://raw.githubusercontent.com/crsanju/Crompton_TIA_QUEUE/refs/heads/main/toowoomba.geojson';

  let macroSitesData = {};
  let selectedMacroSite = null;
  let customDirectionContext = null;
  // store the most recent period profiles so auxiliary calculators can access them
  let lastD1Profile = null;
  let lastD2Profile = null;
  let macroMapInstance = null;
  let macroSiteLayer = null;
  let macroSearchMarkerLayer = null;
  let macroReferenceLinkLayer = null;
  let selectedMacroMarker = null;
  let detourLinkLayer = null;
  let detourMapInstance = null;
  let detourMapLayer = null;
  let detourRoadPreviewLayer = null;
  let macroSourceFilter = 'ALL';
  const macroMarkersById = {};

  function configureChartDefaults() {
    if (typeof Chart === 'undefined') return;
    Chart.defaults.font.family = 'Space Grotesk, Trebuchet MS, sans-serif';
    Chart.defaults.font.size = 12;
    Chart.defaults.color = '#395257';
    Chart.defaults.borderColor = 'rgba(78, 101, 108, 0.18)';
    Chart.defaults.plugins.legend.labels.usePointStyle = true;
    Chart.defaults.plugins.legend.labels.boxWidth = 10;
    Chart.defaults.plugins.legend.labels.boxHeight = 10;
    Chart.defaults.plugins.legend.labels.padding = 12;
    Chart.defaults.plugins.tooltip.backgroundColor = 'rgba(15, 47, 50, 0.92)';
    Chart.defaults.plugins.tooltip.titleFont = { family: 'Space Grotesk, Trebuchet MS, sans-serif', weight: '700' };
    Chart.defaults.plugins.tooltip.bodyFont = { family: 'Space Grotesk, Trebuchet MS, sans-serif' };
    Chart.defaults.plugins.tooltip.cornerRadius = 8;
  }
  configureChartDefaults();

  function addBaseLayerToMap(mapInstance) {
    if (!mapInstance || typeof L === 'undefined') return;
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '¬© OpenStreetMap contributors',
      maxZoom: 19
    }).addTo(mapInstance);
  }

  function getFilteredMacroSiteEntries() {
    const entries = Object.entries(macroSitesData);
    if (macroSourceFilter === 'ALL') return entries;
    return entries.filter(([, site]) => site && site.source && site.source === macroSourceFilter);
  }

  function initMacroMap() {
    if (macroMapInstance || !document.getElementById('macroMap') || typeof L === 'undefined') return;
    macroMapInstance = L.map('macroMap', {
      maxBounds: [[-29, 138], [-10, 154]], // Queensland bounds
      restrictBounds: true
    }).setView([-27.55, 152.95], 8);
    addBaseLayerToMap(macroMapInstance);
    macroSiteLayer = L.layerGroup().addTo(macroMapInstance);
  }

  function renderMacroMapSites() {
    if (!macroMapInstance || !macroSiteLayer || typeof L === 'undefined') return;
    macroSiteLayer.clearLayers();
    selectedMacroMarker = null;
    Object.keys(macroMarkersById).forEach(key => delete macroMarkersById[key]);

    const points = [];
    const filteredEntries = getFilteredMacroSiteEntries();
    filteredEntries.forEach(([siteId, site]) => {
      const lat = Number(site.latitude);
      const lon = Number(site.longitude);
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;

      const marker = L.circleMarker([lat, lon], {
        radius: 4,
        color: '#1f5e63',
        fillColor: '#1f5e63',
        fillOpacity: 0.75,
        weight: 1
      }).addTo(macroSiteLayer);

      marker.bindTooltip(`${siteId} - ${site.road_name || site.description || 'Site'}`);
      marker.on('click', () => selectMacroSite(siteId));
      macroMarkersById[siteId] = marker;
      points.push([lat, lon]);
    });

    if (points.length) {
      macroMapInstance.fitBounds(points, { padding: [24, 24] });
      const info = document.getElementById('macroMapInfo');
      if (info) {
        const label = macroSourceFilter === 'ALL' ? 'TMR + Gold Coast + Ipswich + Logan + Toowoomba' : macroSourceFilter;
        info.textContent = `${points.length} sites loaded for ${label}. Click a marker to select a site.`;
      }
    } else {
      const info = document.getElementById('macroMapInfo');
      if (info) {
        const label = macroSourceFilter === 'ALL' ? 'TMR + Gold Coast + Ipswich + Logan + Toowoomba' : macroSourceFilter;
        info.textContent = `No mappable sites found for ${label}.`;
      }
    }
  }

  function focusMacroSiteOnMap(siteId) {
    if (!macroMapInstance) return;
    const marker = macroMarkersById[siteId];
    if (!marker) return;

    if (selectedMacroMarker) {
      selectedMacroMarker.setStyle({ radius: 4, color: '#1f5e63', fillColor: '#1f5e63', fillOpacity: 0.75, weight: 1 });
    }

    marker.setStyle({ radius: 7, color: '#d36b2c', fillColor: '#d36b2c', fillOpacity: 0.95, weight: 2 });
    selectedMacroMarker = marker;
    const pos = marker.getLatLng();
    macroMapInstance.setView(pos, Math.max(macroMapInstance.getZoom(), 17));

    const info = document.getElementById('macroMapInfo');
    const site = macroSitesData[siteId];
    if (info && site) {
      info.textContent = `Selected ${siteId} (${site.road_name || site.description || 'Site'}) at ${pos.lat.toFixed(5)}, ${pos.lng.toFixed(5)}`;
    }
  }

  async function fetchGitHubData(url) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000);
      console.log(`Fetching: ${url}`);
      const response = await fetch(url, { signal: controller.signal });
      clearTimeout(timeoutId);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const data = await response.json();
      console.log(`Fetched from ${url}: ${data.features ? data.features.length : 0} features`);
      return data;
    } catch (err) {
      console.error(`Fetch failed for ${url}:`, err.message, err);
      return null;
    }
  }

  function parseMacroTrafficData(jsonData, sourceName = 'TMR') {
    const sites = {};
    const features = jsonData.features || [];
    const sourceUpper = String(sourceName || '').toUpperCase();
    const isIpswich = sourceUpper === 'IPSWICH';
    const isLogan = sourceUpper === 'LOGAN';
    const isToowoomba = sourceUpper === 'TOOWOOMBA';

    const normalizeDirectionKey = (rawDirection) => {
      if (!rawDirection) return null;
      const value = String(rawDirection).trim().toUpperCase();
      if (value === 'GAZETTAL' || value === 'D1' || value.includes('WITH GAZ') || value.includes('WITH_GAZ')) return 'GAZETTAL';
      if (value === 'AGAINST GAZETTAL' || value === 'D2' || value.includes('AGAINST')) return 'AGAINST GAZETTAL';
      return null;
    };

    const expandDirectionLabel = (rawDirection) => {
      const value = String(rawDirection || '').trim().toUpperCase();
      if (!value) return '';
      if (value === 'N' || value === 'NB' || value.includes('NORTH')) return 'Northbound';
      if (value === 'S' || value === 'SB' || value.includes('SOUTH')) return 'Southbound';
      if (value === 'E' || value === 'EB' || value.includes('EAST')) return 'Eastbound';
      if (value === 'W' || value === 'WB' || value.includes('WEST') || value === 'WE') return 'Westbound';
      return String(rawDirection).trim();
    };

    const extractDbDirectionText = (rawDirection) => {
      const raw = String(rawDirection || '').trim();
      if (!raw) return '';
      const match = raw.match(/(Northbound|Southbound|Eastbound|Westbound|North|South|East|West|NB|SB|EB|WB)/i);
      if (match) return match[0].trim();
      const cleaned = raw.replace(/[\d,().]/g, ' ').replace(/\s+/g, ' ').trim();
      return cleaned;
    };

    const parseYearFromAny = (...values) => {
      for (const value of values) {
        if (value === null || value === undefined || value === '') continue;
        const asNumber = Number(value);
        if (Number.isFinite(asNumber) && asNumber >= 1900 && asNumber <= 2100) return Math.round(asNumber);
        const match = String(value).match(/(19|20)\d{2}/);
        if (match) return Number(match[0]);
      }
      return 2024;
    };

    const calcLoganHvPercent = (props) => {
      const heavyFields = ['M3_5_PCENT', 'M4_5_PCENT', 'L3_PCENT', 'L4_PCENT', 'L5_PCENT', 'L6_PCENT', 'L7_8_PCENT'];
      const total = heavyFields.reduce((sum, field) => sum + (Number(props[field]) || 0), 0);
      return total > 0 ? Math.round(total * 10) / 10 : null;
    };

    const normalizePercentValue = (value) => {
      const n = Number(value);
      if (!Number.isFinite(n) || n <= 0) return null;
      // Some sources store percentages as fractions (e.g. 0.09 = 9%)
      const normalized = n <= 1 ? (n * 100) : n;
      return Math.round(normalized * 100) / 100;
    };

    const createIpswichSiteKey = (props) => {
      const road = String(props['Road Name'] || '').trim();
      const suburb = String(props['Suburb'] || '').trim();
      const siteDesc = String(props['Site Description'] || '').trim();
      const lat = Number(props['Latitude']);
      const lon = Number(props['Longitude']);
      const loc = (Number.isFinite(lat) && Number.isFinite(lon)) ? `${lat.toFixed(5)},${lon.toFixed(5)}` : '';
      const key = [road, suburb, siteDesc].filter(Boolean).join(' | ');
      return key || loc || String(props['Id'] || props['ID'] || props['id'] || '').trim();
    };

    features.forEach(feature => {
      const props = feature.properties;
      if (!props) return;

      const rawSiteId = isIpswich
        ? createIpswichSiteKey(props)
        : (props['SITE_ID'] || props['site_id'] || props['OBJECTID'] || props['ID'] || props['id'] || props['Id'] || props['SITE'] || props['Site'] || '');
      const siteId = String(rawSiteId || '').trim();
      if (!siteId) return;

      const suburb = props['SUBURB'] || props['Suburb'] || props['Suburb'] || '';
      const rawDescription = props['DESCRIPTION'] || props['LOCATION'] || props['COUNTER_LOCATION_BETWEEN'] || props['Site Description'] || props['Local_Road_Alias'] || '';
      const description = suburb ? `${suburb} - ${rawDescription}` : String(rawDescription).replace(/"/g, '').trim();
      const roadName = String(props['ROAD_NAME'] || props['STREET'] || props['STREET_NAME'] || props['Road Name'] || props['Road_Name'] || '').replace(/"/g, '').trim();
      const geomCoords = feature && feature.geometry && Array.isArray(feature.geometry.coordinates) ? feature.geometry.coordinates : [];

      let longitude = props['LONGITUDE'] || props['LON'] || props['LONG'] || props['Longitude'];
      let latitude = props['LATITUDE'] || props['LAT'] || props['Latitude'];

      if (!longitude || !latitude) {
        if (feature.geometry && feature.geometry.type === 'LineString' && geomCoords.length > 0) {
          const midIdx = Math.floor(geomCoords.length / 2);
          const midPoint = geomCoords[midIdx];
          if (Array.isArray(midPoint) && midPoint.length >= 2) {
            longitude = longitude || midPoint[0];
            latitude = latitude || midPoint[1];
          }
        } else if (feature.geometry && feature.geometry.type === 'MultiLineString' && geomCoords.length > 0 && Array.isArray(geomCoords[0])) {
          const firstLine = geomCoords[0];
          const midIdx = Math.floor(firstLine.length / 2);
          const midPoint = firstLine[midIdx];
          if (Array.isArray(midPoint) && midPoint.length >= 2) {
            longitude = longitude || midPoint[0];
            latitude = latitude || midPoint[1];
          }
        } else if (feature.geometry && feature.geometry.type === 'Point') {
          longitude = longitude || geomCoords[0];
          latitude = latitude || geomCoords[1];
        }
      }

      if (!Number.isFinite(Number(longitude)) || !Number.isFinite(Number(latitude))) return;

      const countYear = parseYearFromAny(
        props['COUNT_YEAR'], props['DATA_YEAR'], props['YEAR'], props['AADT_DATE'], props['SURVEY_DATE'], props['AAWT_DATE'], props['Start Day|Survey'], props['Finish_Date']
      );
      const growthRate = Number(props['GROWTH_RATE'] || props['GROWTH'] || '') || null;
      const hvPercentDirectRaw = props['HV_PERCENT'] || props['HVP'] || props['Percentage Commercial Vehicles'] || props['Percent_Commercial_Heavy_Vehicl'];
      const hvPercentDirect = normalizePercentValue(hvPercentDirectRaw);
      const hvPercent = hvPercentDirect !== null ? hvPercentDirect : normalizePercentValue(isLogan ? calcLoganHvPercent(props) : null);
      const totalVadtFromProps = Number(props['VADT'] || props['AADT'] || props['VPD'] || props['TOTAL_VADT'] || props['Average Daily Traffic Adt Vehicles Per Day'] || props['Average Weekday Traffic Awt Vehicles Per Day'] || props['ADT']) || null;

      let d1VadtFromProps = Number(props['D1_VADT'] || props['GAZETTAL_VADT'] || props['VADT_D1'] || props['VOL1'] || '') || null;
      let d2VadtFromProps = Number(props['D2_VADT'] || props['AGAINST_GAZETTAL_VADT'] || props['VADT_D2'] || props['VOL2'] || '') || null;
      if (!d1VadtFromProps && props['DIRECTION_1A']) {
        const m = String(props['DIRECTION_1A']).match(/(\d+)/);
        if (m) d1VadtFromProps = Number(m[1]);
      }
      if (!d2VadtFromProps && props['DIRECTION_2A']) {
        const m = String(props['DIRECTION_2A']).match(/(\d+)/);
        if (m) d2VadtFromProps = Number(m[1]);
      }

      let d1Lanes = Number(props['D1_LANES'] || props['GAZETTAL_LANES'] || props['LANES_D1'] || '') || null;
      let d2Lanes = Number(props['D2_LANES'] || props['AGAINST_GAZETTAL_LANES'] || props['LANES_D2'] || '') || null;
      let totalLanes = Number(props['LANES'] || props['NUM_LANES'] || props['TOTAL_LANES'] || '') || null;
      if (isLogan) {
        const laneNoAadt = Number(props['LANE_NO_AADT']) || null;
        if (laneNoAadt && laneNoAadt > 0) {
          totalLanes = totalLanes || laneNoAadt;
          if (!d1Lanes && !d2Lanes) {
            d1Lanes = Math.max(1, Math.ceil(laneNoAadt / 2));
            d2Lanes = Math.max(1, Math.floor(laneNoAadt / 2));
          }
        }
      }

      if (!sites[siteId]) {
        sites[siteId] = {
          id: siteId,
          source: sourceName,
          description,
          road_name: roadName,
          longitude: Number(longitude),
          latitude: Number(latitude),
          countYear,
          vadt: 0,
          growth_rate: growthRate,
          hv_percent: hvPercent,
          d1_lanes: d1Lanes,
          d2_lanes: d2Lanes,
          total_lanes: totalLanes,
          d1_vadt: 0,
          d2_vadt: 0,
          dtca_auto: false,
          d1_direction_label: 'Gazettal',
          d2_direction_label: 'Against Gazettal',
          directions_weekday: {
            'GAZETTAL': new Array(24).fill(0),
            'AGAINST GAZETTAL': new Array(24).fill(0)
          },
          directions: {
            'GAZETTAL': new Array(24).fill(0),
            'AGAINST GAZETTAL': new Array(24).fill(0)
          },
          hour_order: {
            'GAZETTAL': [],
            'AGAINST GAZETTAL': []
          },
          direction_descriptions: {
            'GAZETTAL': '',
            'AGAINST GAZETTAL': ''
          },
          direction_base_labels: {
            'GAZETTAL': 'Direction 1',
            'AGAINST GAZETTAL': 'Direction 2'
          },
          _directionMap: {}
        };
      }

      const site = sites[siteId];
      if (totalVadtFromProps && (!site.vadt || site.vadt <= 0 || countYear >= (site.countYear || 0))) {
        site.vadt = totalVadtFromProps;
      }
      if (d1VadtFromProps) site.d1_vadt = d1VadtFromProps;
      if (d2VadtFromProps) site.d2_vadt = d2VadtFromProps;
      if (!site.hv_percent && hvPercent) site.hv_percent = hvPercent;
      if (!site.growth_rate && growthRate) site.growth_rate = growthRate;
      if (!site.d1_lanes && d1Lanes) site.d1_lanes = d1Lanes;
      if (!site.d2_lanes && d2Lanes) site.d2_lanes = d2Lanes;
      if (!site.total_lanes && totalLanes) site.total_lanes = totalLanes;

      const ipswichDirection = props['Direction'];
      if (ipswichDirection && totalVadtFromProps) {
        const dirKey = String(ipswichDirection).trim();
        const dirText = extractDbDirectionText(dirKey);
        if (!site._directionMap[dirKey]) {
          const assignedDirs = Object.keys(site._directionMap);
          if (assignedDirs.length === 0) {
            site._directionMap[dirKey] = 'GAZETTAL';
            site.d1_vadt = totalVadtFromProps;
            site.direction_descriptions['GAZETTAL'] = expandDirectionLabel(dirKey);
            if (dirText) site.direction_base_labels['GAZETTAL'] = dirText;
          } else if (assignedDirs.length === 1) {
            site._directionMap[dirKey] = 'AGAINST GAZETTAL';
            site.d2_vadt = totalVadtFromProps;
            site.direction_descriptions['AGAINST GAZETTAL'] = expandDirectionLabel(dirKey);
            if (dirText) site.direction_base_labels['AGAINST GAZETTAL'] = dirText;
          }
        }
      }

      const dir1Label = props['DIRECTION_1A'] || props['DIR1'] || '';
      const dir2Label = props['DIRECTION_2A'] || props['DIR2'] || '';
      const dir1Base = extractDbDirectionText(dir1Label);
      const dir2Base = extractDbDirectionText(dir2Label);
      if (dir1Base) site.direction_base_labels['GAZETTAL'] = dir1Base;
      if (dir2Base) site.direction_base_labels['AGAINST GAZETTAL'] = dir2Base;
      if (dir1Label) {
        const match = String(dir1Label).match(/(North|South|East|West|Northbound|Southbound|Eastbound|Westbound|N|S|E|W|NB|SB|EB|WB)/i);
        if (match) site.direction_descriptions['GAZETTAL'] = expandDirectionLabel(match[0]);
      }
      if (dir2Label) {
        const match = String(dir2Label).match(/(North|South|East|West|Northbound|Southbound|Eastbound|Westbound|N|S|E|W|NB|SB|EB|WB)/i);
        if (match) site.direction_descriptions['AGAINST GAZETTAL'] = expandDirectionLabel(match[0]);
      }

      const hours = props['HOURS'];
      const hourMatch = hours ? String(hours).match(/^(\d+)\s+to\s+(\d+)$/) : null;
      const rawDirectionInput = props['GAZETTAL_DIRECTION'] || props['DIRECTION'] || props['direction'];
      const direction = normalizeDirectionKey(rawDirectionInput);

      if (direction && rawDirectionInput !== null && rawDirectionInput !== undefined) {
        const rawText = String(rawDirectionInput).trim();
        const upperRaw = rawText.toUpperCase();
        const isGeneric = (upperRaw === 'D1' || upperRaw === 'D2');
        if (rawText && !isGeneric) {
          site.direction_base_labels[direction] = rawText;
        }
      }

      if (direction && (description || roadName)) {
        const textToSearch = `${description} ${roadName}`;
        const dirMatch = textToSearch.match(/(Northbound|Southbound|Eastbound|Westbound|North|South|East|West|NB|SB|EB|WB)/i);
        if (dirMatch && !site.direction_descriptions[direction]) {
          site.direction_descriptions[direction] = expandDirectionLabel(dirMatch[0]);
        }
      }

      if (!direction && props['Direction']) {
        const ipswichDir = String(props['Direction']).trim();
        let amPeakStartHour = null;
        if (props['Weekday Avg AM Peak Start Hour']) {
          const m = String(props['Weekday Avg AM Peak Start Hour']).match(/^(\d+):/);
          amPeakStartHour = m ? parseInt(m[1], 10) : null;
        }
        let pmPeakStartHour = null;
        if (props['Weekday Avg PM Peak Start Hour']) {
          const m = String(props['Weekday Avg PM Peak Start Hour']).match(/^(\d+):/);
          pmPeakStartHour = m ? parseInt(m[1], 10) : null;
        }

        const amPeakFlow = Number(props['Weekday Avg AM Peak Flow Vehicles Per Hour']) || null;
        const pmPeakFlow = Number(props['Weekday Avg PM Peak Flow Vehicles Per Hour']) || null;
        const assignedDir = site._directionMap[ipswichDir];

        if (assignedDir) {
          if (amPeakStartHour !== null && amPeakFlow !== null && amPeakStartHour >= 0 && amPeakStartHour < 24) {
            site.directions_weekday[assignedDir][amPeakStartHour] = Math.ceil(amPeakFlow);
            site.directions[assignedDir][amPeakStartHour] = Math.ceil(amPeakFlow);
          }
          if (pmPeakStartHour !== null && pmPeakFlow !== null && pmPeakStartHour >= 0 && pmPeakStartHour < 24) {
            site.directions_weekday[assignedDir][pmPeakStartHour] = Math.ceil(pmPeakFlow);
            site.directions[assignedDir][pmPeakStartHour] = Math.ceil(pmPeakFlow);
          }
        }
      }

      if (hourMatch) {
        const hourIndex = parseInt(hourMatch[1], 10);
        if (hourIndex >= 0 && hourIndex < 24 && direction && site.directions_weekday[direction]) {
          const weekdayAvg = props['WEEKDAY_AVERAGE'] ? Math.ceil(parseFloat(props['WEEKDAY_AVERAGE'])) : 0;
          site.directions_weekday[direction][hourIndex] = weekdayAvg;
          site.directions[direction][hourIndex] = weekdayAvg;
        }
      }

      if (isLogan) {
        const amPeak = Number(props['AM_PEAK']) || 0;
        const pmPeak = Number(props['PM_PEAK']) || 0;
        const amHour = Number(props['AM_FROM_HUR']);
        const pmHour = Number(props['PM_FROM_HUR']);
        const amIdx = Number.isFinite(amHour) && amHour >= 0 && amHour < 24 ? amHour : 8;
        const pmIdx = Number.isFinite(pmHour) && pmHour >= 0 && pmHour < 24 ? pmHour : 17;

        if (amPeak > 0) {
          site.directions_weekday['GAZETTAL'][amIdx] = Math.max(site.directions_weekday['GAZETTAL'][amIdx], Math.round(amPeak * 0.5));
          site.directions_weekday['AGAINST GAZETTAL'][amIdx] = Math.max(site.directions_weekday['AGAINST GAZETTAL'][amIdx], Math.round(amPeak * 0.5));
        }
        if (pmPeak > 0) {
          site.directions_weekday['GAZETTAL'][pmIdx] = Math.max(site.directions_weekday['GAZETTAL'][pmIdx], Math.round(pmPeak * 0.5));
          site.directions_weekday['AGAINST GAZETTAL'][pmIdx] = Math.max(site.directions_weekday['AGAINST GAZETTAL'][pmIdx], Math.round(pmPeak * 0.5));
        }
      }

      if (isToowoomba) {
        const adt = Number(props['ADT']) || 0;
        if (adt > 0 && (!site.vadt || site.vadt <= 0)) site.vadt = adt;
      }
    });

    // Calculate D1 & D2 VADT from directional data and set labels
    const isGoldCoast = sourceUpper === 'GOLD COAST';
    Object.keys(sites).forEach(siteId => {
      const site = sites[siteId];
      const gazData = site.directions_weekday['GAZETTAL'] || new Array(24).fill(0);
      const agData = site.directions_weekday['AGAINST GAZETTAL'] || new Array(24).fill(0);
      
      const d1Total = gazData.reduce((a, b) => a + (Number(b) || 0), 0);
      const d2Total = agData.reduce((a, b) => a + (Number(b) || 0), 0);
      
      const computedD1 = Math.ceil(d1Total);
      const computedD2 = Math.ceil(d2Total);

      if (computedD1 > 0 || computedD2 > 0) {
        site.d1_vadt = computedD1;
        site.d2_vadt = computedD2;
      }

      if (site.d1_vadt <= 0 && site.d2_vadt <= 0) {
        const totalVadt = Number(site.vadt || 0);
        if (totalVadt > 0) {
          site.d1_vadt = Math.round(totalVadt * 0.5);
          site.d2_vadt = Math.round(totalVadt * 0.5);
        }
      } else if (!site.vadt || site.vadt <= 0) {
        // If we have d1/d2 but no total, calculate it (for Ipswich data)
        site.vadt = (site.d1_vadt || 0) + (site.d2_vadt || 0);
      }

      if (isGoldCoast) {
        let totalVadt = Number(site.vadt || 0);
        let d1Vadt = Number(site.d1_vadt || 0);
        let d2Vadt = Number(site.d2_vadt || 0);

        if (totalVadt > 0 && d1Vadt > 0 && d2Vadt > 0) {
          const dirSum = d1Vadt + d2Vadt;
          const diffRatio = Math.abs(dirSum - totalVadt) / totalVadt;
          if (dirSum > 0 && diffRatio > 0.35) {
            d1Vadt = Math.round(totalVadt * (d1Vadt / dirSum));
            d2Vadt = Math.max(0, totalVadt - d1Vadt);
          }
        }

        if (totalVadt > 0 && d1Vadt > 0 && d2Vadt <= 0) {
          d2Vadt = Math.max(0, totalVadt - d1Vadt);
        }
        if (totalVadt > 0 && d2Vadt > 0 && d1Vadt <= 0) {
          d1Vadt = Math.max(0, totalVadt - d2Vadt);
        }
        if (totalVadt <= 0 && d1Vadt > 0 && d2Vadt > 0) {
          totalVadt = d1Vadt + d2Vadt;
        }
        if (totalVadt > 0 && d1Vadt <= 0 && d2Vadt <= 0) {
          d1Vadt = Math.round(totalVadt * 0.5);
          d2Vadt = Math.max(0, totalVadt - d1Vadt);
        }

        site.vadt = Math.round(Math.max(0, totalVadt));
        site.d1_vadt = Math.round(Math.max(0, d1Vadt));
        site.d2_vadt = Math.round(Math.max(0, d2Vadt));
      }

      if (isGoldCoast && Number(site.vadt || 0) <= 0 && Number(site.d1_vadt || 0) <= 0 && Number(site.d2_vadt || 0) <= 0) {
        delete sites[siteId];
        return;
      }

      if (isToowoomba && Number(site.vadt || 0) <= 0 && Number(site.d1_vadt || 0) <= 0 && Number(site.d2_vadt || 0) <= 0) {
        delete sites[siteId];
        return;
      }

      site.dtca_auto = (d1Total > 0 && d2Total > 0);

      if (!site.dtca_auto && site.d1_vadt > 0 && site.d2_vadt > 0) {
        site.dtca_auto = true;
      }
      
      // Clean up helper property
      delete site._directionMap;
      
      // Smart direction labeling with opposite direction inference
      const gazLabel = site.direction_descriptions['GAZETTAL'];
      const agLabel = site.direction_descriptions['AGAINST GAZETTAL'];
      
      // If both have the same direction or one is missing, infer the opposite
      const getOppositeDir = (dir) => {
        if (!dir) return null;
        const d = dir.toLowerCase();
        if (d.includes('north') || d === 'nb') return 'Southbound';
        if (d.includes('south') || d === 'sb') return 'Northbound';
        if (d.includes('east') || d === 'eb') return 'Westbound';
        if (d.includes('west') || d === 'wb') return 'Eastbound';
        return null;
      };
      
      let finalGazLabel = gazLabel;
      let finalAgLabel = agLabel;
      
      // If both exist and are the same (error case), fix it
      if (gazLabel && agLabel && gazLabel.toLowerCase() === agLabel.toLowerCase()) {
        finalAgLabel = getOppositeDir(gazLabel);
      }
      // If only one exists, infer the other
      else if (gazLabel && !agLabel) {
        finalAgLabel = getOppositeDir(gazLabel);
      }
      else if (!gazLabel && agLabel) {
        finalGazLabel = getOppositeDir(agLabel);
      }
      
      const baseGazLabel = (site.direction_base_labels && site.direction_base_labels['GAZETTAL'])
        ? String(site.direction_base_labels['GAZETTAL']).trim()
        : 'Direction 1';
      const baseAgLabel = (site.direction_base_labels && site.direction_base_labels['AGAINST GAZETTAL'])
        ? String(site.direction_base_labels['AGAINST GAZETTAL']).trim()
        : 'Direction 2';

      const baseGazGeneric = /\bgazettal\b/i.test(baseGazLabel) || /^direction\s*1\b/i.test(baseGazLabel);
      const baseAgGeneric = /\bgazettal\b/i.test(baseAgLabel) || /^direction\s*2\b/i.test(baseAgLabel);

      site.d1_direction_label = (baseGazGeneric && finalGazLabel) ? `${baseGazLabel} (${finalGazLabel})` : baseGazLabel;
      site.d2_direction_label = (baseAgGeneric && finalAgLabel) ? `${baseAgLabel} (${finalAgLabel})` : baseAgLabel;
    });

    console.log(`${sourceName}: Processed ${features.length} features, created ${Object.keys(sites).length} unique sites`);
    return sites;
  }

  function mergeMacroSites(...siteMaps) {
    const merged = {};
    siteMaps.forEach(map => {
      Object.entries(map || {}).forEach(([siteId, site]) => {
        let uniqueKey = siteId;
        if (merged[uniqueKey]) {
          const src = site && site.source ? site.source : 'DATA';
          uniqueKey = `${siteId} (${src})`;
        }
        merged[uniqueKey] = {
          ...site,
          id: uniqueKey
        };
      });
    });
    return merged;
  }

  async function loadMacroSitesData() {
    console.log('Loading Macro sites from GitHub (TMR + Gold Coast + Ipswich + Logan + Toowoomba)...');
    const [tmrData, goldCoastData, ipswichData, loganData, toowoombaData] = await Promise.all([
      fetchGitHubData(GITHUB_TMR_URL),
      fetchGitHubData(GITHUB_GOLDCOAST_URL),
      fetchGitHubData(GITHUB_IPSWICH_URL),
      fetchGitHubData(GITHUB_LOGAN_URL),
      fetchGitHubData(GITHUB_TOOWOOMBA_URL)
    ]);

    const tmrSites = tmrData ? parseMacroTrafficData(tmrData, 'TMR') : {};
    const goldCoastSites = goldCoastData ? parseMacroTrafficData(goldCoastData, 'Gold Coast') : {};
    const ipswichSites = ipswichData ? parseMacroTrafficData(ipswichData, 'Ipswich') : (console.warn('ipswichData is null/falsy'), {});
    const loganSites = loganData ? parseMacroTrafficData(loganData, 'Logan') : {};
    const toowoomSites = toowoombaData ? parseMacroTrafficData(toowoombaData, 'Toowoomba') : {};

    macroSitesData = mergeMacroSites(tmrSites, goldCoastSites, ipswichSites, loganSites, toowoomSites);

    console.log(`Loaded ${Object.keys(macroSitesData).length} macro sites (TMR: ${Object.keys(tmrSites).length}, Gold Coast: ${Object.keys(goldCoastSites).length}, Ipswich: ${Object.keys(ipswichSites).length}, Logan: ${Object.keys(loganSites).length}, Toowoomba: ${Object.keys(toowoomSites).length})`);
    document.getElementById('sitesLoadedCount').textContent = Object.keys(macroSitesData).length;
    populateMacroSitesDatalist();
    initMacroMap();
    renderMacroMapSites();

    const mapInfo = document.getElementById('macroMapInfo');
    if (mapInfo) {
      mapInfo.textContent = `${Object.keys(macroSitesData).length} combined sites loaded (TMR + Gold Coast + Ipswich + Logan + Toowoomba). Click a marker to select a site.`;
    }
  }

  function populateMacroSitesDatalist() {
    const datalist = document.getElementById('macroSitesList');
    datalist.innerHTML = '';
    const filteredEntries = getFilteredMacroSiteEntries();
    filteredEntries.forEach(([id, data]) => {
      const option = document.createElement('option');
      option.value = id;
      const sourceTag = data.source ? ` [${data.source}]` : '';
      option.textContent = `${id} - ${data.description}${sourceTag}`;
      datalist.appendChild(option);
    });
  }

  function selectMacroSite(siteId) {
    const data = macroSitesData[siteId];
    if (!data) return;

    const hasDbHv = data.hv_percent !== null
      && data.hv_percent !== undefined
      && Number.isFinite(Number(data.hv_percent))
      && Number(data.hv_percent) > 0;

    selectedMacroSite = siteId;
  customDirectionContext = null;
    document.getElementById('macroSiteSearch').value = siteId;
    
    const detailsPanel = document.getElementById('macroSiteDetailsPanel');
    if (detailsPanel) detailsPanel.style.display = 'block';

    const setText = (id, value) => {
      const el = document.getElementById(id);
      if (el) el.textContent = value || '-';
    };

    const setSourceBadge = (sourceValue) => {
      const el = document.getElementById('macroDetailSource');
      if (!el) return;
      const source = String(sourceValue || 'N/A').trim();
      const classSuffix = source.toLowerCase().replace(/\s+/g, '-');
      el.innerHTML = `<span class="source-pill source-${classSuffix}">${source}</span>`;
    };

    const setQualityBadge = () => {
      const el = document.getElementById('macroDetailQuality');
      if (!el) return;
      const d1 = Number(data.d1_vadt) || 0;
      const d2 = Number(data.d2_vadt) || 0;
      const hourlyD1 = data && data.directions_weekday && Array.isArray(data.directions_weekday['GAZETTAL'])
        ? data.directions_weekday['GAZETTAL'].reduce((s, v) => s + (Number(v) || 0), 0)
        : 0;
      const hourlyD2 = data && data.directions_weekday && Array.isArray(data.directions_weekday['AGAINST GAZETTAL'])
        ? data.directions_weekday['AGAINST GAZETTAL'].reduce((s, v) => s + (Number(v) || 0), 0)
        : 0;

      let label = 'Estimated';
      let cls = 'quality-estimated';

      if (hourlyD1 + hourlyD2 > 0) {
        label = 'Measured (Hourly)';
        cls = 'quality-measured';
      } else if (d1 > 0 && d2 > 0) {
        label = 'Derived (Directional)';
        cls = 'quality-derived';
      } else if ((Number(data.vadt) || 0) > 0) {
        label = 'Estimated (Total only)';
        cls = 'quality-estimated';
      }

      el.innerHTML = `<span class="quality-pill ${cls}">${label}</span>`;
    };

    setText('macroDetailSiteId', siteId);
    setSourceBadge(data.source || 'N/A');
    setText('macroDetailRoadName', data.road_name || 'N/A');
    setText('macroDetailDescription', data.description || 'N/A');
    setText('macroDetailCountYear', data.countYear || data.count_year || 'N/A');
    setText('macroDetailGrowthRate', data.growth_rate ? `${data.growth_rate}% p.a.` : 'N/A');
    setText('macroDetailHV', hasDbHv ? `${data.hv_percent}%` : 'N/A');
    setQualityBadge();

    const d1 = Number(data.d1_vadt) || 0;
    const d2 = Number(data.d2_vadt) || 0;
    const vadt = d1 + d2;

    const d1RowLabel = String(data.d1_direction_label || 'Direction 1').trim();
    const d2RowLabel = String(data.d2_direction_label || 'Direction 2').trim();
    const d1LabelEl = document.getElementById('macroDetailD1Label');
    const d2LabelEl = document.getElementById('macroDetailD2Label');
    const d1InputLabelEl = document.getElementById('macroInputD1Label');
    const d2InputLabelEl = document.getElementById('macroInputD2Label');
    if (d1LabelEl) d1LabelEl.textContent = formatDirectionalVadtLabel('D1', d1RowLabel);
    if (d2LabelEl) d2LabelEl.textContent = formatDirectionalVadtLabel('D2', d2RowLabel);
    if (d1InputLabelEl) d1InputLabelEl.textContent = formatDirectionalVadtLabel('D1', d1RowLabel).replace(':', ' (from DB)');
    if (d2InputLabelEl) d2InputLabelEl.textContent = formatDirectionalVadtLabel('D2', d2RowLabel).replace(':', ' (from DB)');

    setText('macroDetailD1', d1.toLocaleString());
    setText('macroDetailD2', d2.toLocaleString());
    setText('macroDetailTotal', vadt.toLocaleString());

    if (Number.isFinite(Number(data.latitude)) && Number.isFinite(Number(data.longitude))) {
      const lat = Number(data.latitude);
      const lon = Number(data.longitude);
      setText('macroDetailCoords', `${lat.toFixed(6)}, ${lon.toFixed(6)}`);
      document.getElementById('macroMapLink').href = `https://www.google.com/maps?q=${lat},${lon}`;
    } else {
      setText('macroDetailCoords', 'N/A');
      document.getElementById('macroMapLink').href = 'javascript:void(0)';
    }

    // Auto-fill DATABASE fields (green)
    document.getElementById('macroSiteId').value = siteId;
    document.getElementById('baseYear').value = data.countYear || 2024;
    document.getElementById('baseHVPercent').value = hasDbHv ? Number(data.hv_percent) : '';
    document.getElementById('D1_VADT').value = d1;
    document.getElementById('D2_VADT').value = d2;
    
    // Auto-calculate VADT
    document.getElementById('VADT').value = Math.round(vadt);
    
    // Auto-detect DTCA based on directional data
    document.getElementById('DTCA').value = data.dtca_auto ? 'Yes' : 'No';
    
    // Auto-fill growth rate if available in DB and visually mark DB/manual mode
    const growthEl = document.getElementById('macroGrowthRate');
    const growthWrapper = growthEl ? growthEl.closest('div') : null;
    const growthLabel = growthWrapper ? growthWrapper.querySelector('label') : null;
    if (data.growth_rate !== null && data.growth_rate !== undefined && Number.isFinite(Number(data.growth_rate))) {
      growthEl.value = data.growth_rate;
      growthEl.readOnly = true;
      growthEl.style.border = '1px solid #81c784';
      growthEl.style.backgroundColor = '#f1f8f6';
      growthEl.style.color = '#1b5e20';
      if (growthWrapper) {
        growthWrapper.style.background = '#e8f5e9';
        growthWrapper.style.border = '1px solid #81c784';
      }
      if (growthLabel) {
        growthLabel.style.color = '#2e7d32';
        growthLabel.innerHTML = 'Growth Rate (% p.a.) (from DB)';
      }
    } else {
      growthEl.readOnly = false;
      growthEl.style.border = '1px solid #ffc107';
      growthEl.style.backgroundColor = '#fffbf0';
      growthEl.style.color = '#000';
      if (growthWrapper) {
        growthWrapper.style.background = '#fff3cd';
        growthWrapper.style.border = '1px solid #ffc107';
      }
      if (growthLabel) {
        growthLabel.style.color = '#c30000';
        growthLabel.innerHTML = 'Growth Rate (% p.a.) *';
      }
    }
    
    // Auto-fill HVP if available in DB and visually mark it as database-driven
    const hvpEl = document.getElementById('HVP');
    const hvpWrapper = hvpEl ? hvpEl.closest('div') : null;
    const hvpLabel = hvpWrapper ? hvpWrapper.querySelector('label') : null;
    if (hasDbHv) {
      hvpEl.value = data.hv_percent;
      hvpEl.readOnly = true;
      hvpEl.style.border = '1px solid #81c784';
      hvpEl.style.backgroundColor = '#f1f8f6';
      hvpEl.style.color = '#1b5e20';
      if (hvpWrapper) {
        hvpWrapper.style.background = '#e8f5e9';
        hvpWrapper.style.border = '1px solid #81c784';
      }
      if (hvpLabel) {
        hvpLabel.style.color = '#2e7d32';
        hvpLabel.innerHTML = 'HV (%) (from DB)';
      }
    } else {
      hvpEl.value = 5;
      hvpEl.readOnly = false;
      hvpEl.style.border = '1px solid #ffc107';
      hvpEl.style.backgroundColor = '#fffbf0';
      hvpEl.style.color = '#000';
      if (hvpWrapper) {
        hvpWrapper.style.background = '#fff3cd';
        hvpWrapper.style.border = '1px solid #ffc107';
      }
      if (hvpLabel) {
        hvpLabel.style.color = '#c30000';
        hvpLabel.innerHTML = 'HV (%) *';
      }
    }
    
    // Auto-fill lane counts if available in DB
    const d1LanesEl = document.getElementById('D1_Lanes');
    const d2LanesEl = document.getElementById('D2_Lanes');
    const d1LanesWrapper = d1LanesEl ? d1LanesEl.closest('div') : null;
    const d2LanesWrapper = d2LanesEl ? d2LanesEl.closest('div') : null;
    const d1LanesLabel = d1LanesWrapper ? d1LanesWrapper.querySelector('label') : null;
    const d2LanesLabel = d2LanesWrapper ? d2LanesWrapper.querySelector('label') : null;
    
    if (data.d1_lanes !== null && data.d1_lanes > 0) {
      d1LanesEl.value = data.d1_lanes;
      d1LanesEl.readOnly = true;
      d1LanesEl.style.border = '1px solid #81c784';
      d1LanesEl.style.backgroundColor = '#f1f8f6';
      d1LanesEl.style.color = '#1b5e20';
      if (d1LanesWrapper) {
        d1LanesWrapper.style.background = '#e8f5e9';
        d1LanesWrapper.style.border = '1px solid #81c784';
      }
      if (d1LanesLabel) {
        d1LanesLabel.style.color = '#2e7d32';
        d1LanesLabel.innerHTML = 'D1 Lanes (from DB)';
      }
    } else {
      d1LanesEl.value = 1;
      d1LanesEl.readOnly = false;
      d1LanesEl.style.border = '1px solid #ffc107';
      d1LanesEl.style.backgroundColor = '#fffbf0';
      d1LanesEl.style.color = '#000';
      if (d1LanesWrapper) {
        d1LanesWrapper.style.background = '#fff3cd';
        d1LanesWrapper.style.border = '1px solid #ffc107';
      }
      if (d1LanesLabel) {
        d1LanesLabel.style.color = '#c30000';
        d1LanesLabel.innerHTML = 'D1 Lanes *';
      }
    }
    
    if (data.d2_lanes !== null && data.d2_lanes > 0) {
      d2LanesEl.value = data.d2_lanes;
      d2LanesEl.readOnly = true;
      d2LanesEl.style.border = '1px solid #81c784';
      d2LanesEl.style.backgroundColor = '#f1f8f6';
      d2LanesEl.style.color = '#1b5e20';
      if (d2LanesWrapper) {
        d2LanesWrapper.style.background = '#e8f5e9';
        d2LanesWrapper.style.border = '1px solid #81c784';
      }
      if (d2LanesLabel) {
        d2LanesLabel.style.color = '#2e7d32';
        d2LanesLabel.innerHTML = 'D2 Lanes (from DB)';
      }
    } else {
      d2LanesEl.value = 1;
      d2LanesEl.readOnly = false;
      d2LanesEl.style.border = '1px solid #ffc107';
      d2LanesEl.style.backgroundColor = '#fffbf0';
      d2LanesEl.style.color = '#000';
      if (d2LanesWrapper) {
        d2LanesWrapper.style.background = '#fff3cd';
        d2LanesWrapper.style.border = '1px solid #ffc107';
      }
      if (d2LanesLabel) {
        d2LanesLabel.style.color = '#c30000';
        d2LanesLabel.innerHTML = 'D2 Lanes *';
      }
    }
    
    syncVisibility();
    focusMacroSiteOnMap(siteId);
    updateAssumptionsPanel(data);
    
    // Render charts with database data
    renderMacroCharts(data);
    // Trigger smart detour scan for the newly selected site
    populateDetourDropdown();
    
    console.log(`Selected site: ${siteId}, VADT: ${vadt}, DTCA: ${data.dtca_auto}, D1: ${data.d1_vadt}, D2: ${data.d2_vadt}`);
  }

  // ===== CHART RENDERING =====
  let macroHourlyChartInstance = null;
  let macroD1PieChartInstance = null;
  let macroD2PieChartInstance = null;
  let lastMacroChartPayload = null;

  function getCurrentGrowthProjectionContext() {
    const baseYearVal = Number(num('baseYear'));
    const openingYearVal = Number(num('macroOpeningYear'));
    const growthRatePct = Number(num('macroGrowthRate'));
    const effectiveYears = (Number.isFinite(baseYearVal) && Number.isFinite(openingYearVal))
      ? Math.max(0, openingYearVal - baseYearVal)
      : 0;
    const safeGrowthRatePct = Number.isFinite(growthRatePct) ? growthRatePct : 0;
    const growthFactorRaw = Math.pow(1 + (safeGrowthRatePct / 100), effectiveYears);
    const growthFactor = (Number.isFinite(growthFactorRaw) && growthFactorRaw > 0) ? growthFactorRaw : 1;
    return { growthFactor, effectiveYears, growthRatePct: safeGrowthRatePct };
  }

  function rerenderMacroChartsWithCurrentGrowth() {
    if (!lastMacroChartPayload || !lastMacroChartPayload.data) return;
    renderMacroCharts(lastMacroChartPayload.data, lastMacroChartPayload.options || {});
  }

  function renderMacroCharts(data, options = {}) {
    if (!data || !data.directions_weekday) return;
    lastMacroChartPayload = { data, options: { ...options } };

    const d1Label = String(options.d1Label || 'Gazettal').trim() || 'Gazettal';
    const d2Label = String(options.d2Label || 'Against Gazettal').trim() || 'Against Gazettal';
    const summaryText = String(options.summaryText || 'üìä Traffic Data Visualization (Click to Expand)').trim();
    const sourceText = String(options.sourceText || 'Source: Selected traffic profile').trim();
    
    // Show the visualization section
    const vizSection = document.getElementById('macroDataVizSection');
    if (vizSection) vizSection.style.display = 'block';

    const summaryEl = document.getElementById('macroDataVizSummaryText');
    if (summaryEl) summaryEl.textContent = summaryText;
    const sourceEl = document.getElementById('macroDataVizSourceText');
    if (sourceEl) sourceEl.textContent = sourceText;

    const d1HeadingEl = document.getElementById('macroDataVizD1Heading');
    const d2HeadingEl = document.getElementById('macroDataVizD2Heading');
    const d1PeakHeadingEl = document.getElementById('macroDataVizD1PeakHeading');
    const d2PeakHeadingEl = document.getElementById('macroDataVizD2PeakHeading');
    if (d1HeadingEl) d1HeadingEl.textContent = d1Label;
    if (d2HeadingEl) d2HeadingEl.textContent = d2Label;
    if (d1PeakHeadingEl) d1PeakHeadingEl.textContent = `${d1Label} Peak Hours`;
    if (d2PeakHeadingEl) d2PeakHeadingEl.textContent = `${d2Label} Peak Hours`;
    
    let gazData = data.directions_weekday['GAZETTAL'] || new Array(24).fill(0);
    let agData = data.directions_weekday['AGAINST GAZETTAL'] || new Array(24).fill(0);

    const gazTotal = gazData.reduce((sum, value) => sum + (Number(value) || 0), 0);
    const agTotal = agData.reduce((sum, value) => sum + (Number(value) || 0), 0);

    if (gazTotal <= 0 && Number(data.d1_vadt) > 0) {
      gazData = buildSyntheticHourlyFromDaily(data.d1_vadt);
    }
    if (agTotal <= 0 && Number(data.d2_vadt) > 0) {
      agData = buildSyntheticHourlyFromDaily(data.d2_vadt);
    }

    const { growthFactor, effectiveYears, growthRatePct } = getCurrentGrowthProjectionContext();
    const gazPredData = gazData.map(value => (Number(value) || 0) * growthFactor);
    const agPredData = agData.map(value => (Number(value) || 0) * growthFactor);
    
    // Hourly Profile Chart
    const ctx1 = document.getElementById('macroHourlyChart');
    if (ctx1) {
      if (macroHourlyChartInstance) macroHourlyChartInstance.destroy();
      
      macroHourlyChartInstance = new Chart(ctx1, {
        type: 'line',
        data: {
          labels: Array.from({length: 24}, (_, i) => `${i}:00`),
          datasets: [
            {
              label: `${d1Label} (Current)`,
              data: gazData,
              borderColor: '#4caf50',
              backgroundColor: 'rgba(76, 175, 80, 0.1)',
              tension: 0.3,
              fill: true
            },
            {
              label: `${d2Label} (Current)`,
              data: agData,
              borderColor: '#ef5350',
              backgroundColor: 'rgba(239, 83, 80, 0.1)',
              tension: 0.3,
              fill: true
            },
            {
              label: `${d1Label} (Predicted)` ,
              data: gazPredData,
              borderColor: '#2e7d32',
              backgroundColor: 'rgba(46, 125, 50, 0)',
              tension: 0.3,
              fill: false,
              borderDash: [8, 5],
              pointRadius: 0
            },
            {
              label: `${d2Label} (Predicted)` ,
              data: agPredData,
              borderColor: '#c62828',
              backgroundColor: 'rgba(198, 40, 40, 0)',
              tension: 0.3,
              fill: false,
              borderDash: [8, 5],
              pointRadius: 0
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          plugins: {
            title: {
              display: true,
              text: `Current vs Predicted @ ${numberRoundUp(growthRatePct, 3)}% p.a. over ${effectiveYears} year(s)`
            },
            legend: { position: 'top' }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: { display: true, text: 'Volume (vph)' }
            },
            x: {
              title: { display: true, text: 'Hour of Day' }
            }
          }
        }
      });
    }
    
    // Pie Charts (AM/OP/PM/EV breakdown using global bucket definitions)
    const aggregateByBucket = (hourlyData) => {
      const sums = { AM: 0, OP: 0, PM: 0, EV: 0 };
      for (let hour = 0; hour < 24; hour += 1) {
        const bucket = getTrafficBucket(hour);
        sums[bucket.key] += Number(hourlyData[hour]) || 0;
      }
      return sums;
    };

    const d1BucketTotals = aggregateByBucket(gazData);
    const d2BucketTotals = aggregateByBucket(agData);
    const pieLabels = ['AM (7-9)', 'OP (9-16)', 'PM (16-18)', 'EV (18-7)'];
    
    const ctx2 = document.getElementById('macroD1PieChart');
    if (ctx2) {
      if (macroD1PieChartInstance) macroD1PieChartInstance.destroy();
      
      macroD1PieChartInstance = new Chart(ctx2, {
        type: 'pie',
        data: {
          labels: pieLabels,
          datasets: [{
            data: [d1BucketTotals.AM, d1BucketTotals.OP, d1BucketTotals.PM, d1BucketTotals.EV],
            backgroundColor: ['#ff9800', '#2196f3', '#f44336', '#9c27b0']
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          plugins: {
            legend: { position: 'bottom' }
          }
        }
      });
    }
    
    const ctx3 = document.getElementById('macroD2PieChart');
    if (ctx3) {
      if (macroD2PieChartInstance) macroD2PieChartInstance.destroy();
      
      macroD2PieChartInstance = new Chart(ctx3, {
        type: 'pie',
        data: {
          labels: pieLabels,
          datasets: [{
            data: [d2BucketTotals.AM, d2BucketTotals.OP, d2BucketTotals.PM, d2BucketTotals.EV],
            backgroundColor: ['#ff9800', '#2196f3', '#f44336', '#9c27b0']
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          plugins: {
            legend: { position: 'bottom' }
          }
        }
      });
    }
    
    // Peak Hours Analysis
    const getPeakHours = (hourlyData) => {
      const indexed = hourlyData
        .map((val, idx) => ({ hour: idx, volume: Number(val) || 0 }))
        .filter(item => item.volume > 0);
      indexed.sort((a, b) => b.volume - a.volume);
      return indexed;
    };
    
    const d1Peaks = getPeakHours(gazData);
    const d2Peaks = getPeakHours(agData);
    
    const d1PeakEl = document.getElementById('macroD1PeakHours');
    if (d1PeakEl) {
      d1PeakEl.innerHTML = d1Peaks.length
        ? d1Peaks.map((p, i) => `<div><strong>${i + 1}.</strong> ${p.hour}:00-${p.hour + 1}:00 ‚Üí ${Math.round(p.volume).toLocaleString()} vph</div>`).join('')
        : '<div>No non-zero hourly profile available from source data.</div>';
    }
    
    const d2PeakEl = document.getElementById('macroD2PeakHours');
    if (d2PeakEl) {
      d2PeakEl.innerHTML = d2Peaks.length
        ? d2Peaks.map((p, i) => `<div><strong>${i + 1}.</strong> ${p.hour}:00-${p.hour + 1}:00 ‚Üí ${Math.round(p.volume).toLocaleString()} vph</div>`).join('')
        : '<div>No non-zero hourly profile available from source data.</div>';
    }
  }

  function renderCustomAddressCharts(customData) {
    if (!customData) return;

    const d1Total = Math.max(0, Number(customData.d1_vadt || customData.d1 || customData.avgD1) || 0);
    const d2Total = Math.max(0, Number(customData.d2_vadt || customData.d2 || customData.avgD2) || 0);
    const d1Label = String(customData.d1_direction_label || customData.avgD1Label || 'Direction 1').trim();
    const d2Label = String(customData.d2_direction_label || customData.avgD2Label || 'Direction 2').trim();

    let d1Hourly = null;
    let d2Hourly = null;
    if (customData.type === 'references') {
      d1Hourly = buildWeightedHourlyFromReferences(1, d1Total);
      d2Hourly = buildWeightedHourlyFromReferences(2, d2Total);
    }

    const dataForCharts = {
      d1_vadt: d1Total,
      d2_vadt: d2Total,
      directions_weekday: {
        'GAZETTAL': Array.isArray(d1Hourly) && d1Hourly.length === 24 ? d1Hourly : buildSyntheticHourlyFromDaily(d1Total),
        'AGAINST GAZETTAL': Array.isArray(d2Hourly) && d2Hourly.length === 24 ? d2Hourly : buildSyntheticHourlyFromDaily(d2Total)
      }
    };

    const sourceNote = customData.type === 'references'
      ? 'Source: Custom address estimate (weighted nearby references with hourly shaping)'
      : 'Source: Custom address estimate (synthetic hourly profile from directional daily totals)';

    renderMacroCharts(dataForCharts, {
      d1Label,
      d2Label,
      summaryText: 'üìä Traffic Data Visualization (Custom Address) (Click to Expand)',
      sourceText: sourceNote
    });
  }

  // ===== PRINT FUNCTIONALITY =====
  function printReport() {
    document.getElementById('printDate').textContent = new Date().toLocaleDateString('en-AU', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
    if (macroMapInstance) {
      if (selectedMacroSite && macroSitesData[selectedMacroSite]) {
        const site = macroSitesData[selectedMacroSite];
        const lat = Number(site.latitude);
        const lon = Number(site.longitude);
        if (Number.isFinite(lat) && Number.isFinite(lon)) {
          macroMapInstance.setView([lat, lon], Math.max(macroMapInstance.getZoom(), 17));
        }
      }
      macroMapInstance.invalidateSize();
    }

    setTimeout(() => window.print(), 250);
  }

  function updateAssumptionsPanel(siteData) {
    const site = siteData || (selectedMacroSite ? macroSitesData[selectedMacroSite] : null);
    const set = (id, value) => {
      const el = document.getElementById(id);
      if (el) el.textContent = value;
    };

    const dtcaYes = txt('DTCA').toUpperCase() === 'YES';
    const dhvpaYes = txt('DHVPA').toUpperCase() === 'YES';
    const drtpaYes = txt('DRTPA').toUpperCase() === 'YES';
    const hasDbHv = !!(site && Number(site.hv_percent) > 0);
    const hasDbGrowth = !!(site && Number(site.growth_rate) > 0);
    const hasDbLanes = !!(site && Number(site.d1_lanes) > 0 && Number(site.d2_lanes) > 0);
    const d1Hourly = site && site.directions_weekday && Array.isArray(site.directions_weekday['GAZETTAL'])
      ? site.directions_weekday['GAZETTAL'].reduce((s, v) => s + (Number(v) || 0), 0)
      : 0;
    const d2Hourly = site && site.directions_weekday && Array.isArray(site.directions_weekday['AGAINST GAZETTAL'])
      ? site.directions_weekday['AGAINST GAZETTAL'].reduce((s, v) => s + (Number(v) || 0), 0)
      : 0;
    const hasSourceHourly = (d1Hourly + d2Hourly) > 0;

    set('assumptionDtca', dtcaYes ? 'Directional VADT path' : '50/50 split from total VADT');
    set('assumptionHvSource', dhvpaYes ? 'Directional HV% inputs' : (hasDbHv ? 'Database HV% shared' : 'User HV% shared'));
    set('assumptionRtSource', drtpaYes ? 'Directional RT% inputs' : 'Overall RT% shared');
    set('assumptionGrowthSource', hasDbGrowth ? 'Database growth rate' : 'User-entered growth rate');
    set('assumptionLaneSource', hasDbLanes ? 'Database lane counts' : 'User-entered lane counts');
    set('assumptionProfileSource', hasSourceHourly ? 'Source hourly profile' : 'Derived profile from daily VADT');
  }

  function formatDirectionalVadtLabel(directionCode, directionLabel, prefix = '') {
    const code = String(directionCode || '').trim().toUpperCase();
    const raw = String(directionLabel || '').trim();
    const normalizedRaw = raw.toLowerCase();
    const codeNumber = code === 'D1' ? '1' : '2';
    const generic = !raw
      || normalizedRaw === code.toLowerCase()
      || normalizedRaw === `direction ${codeNumber}`
      || normalizedRaw === 'direction 1'
      || normalizedRaw === 'direction 2';
    return generic ? `${prefix}${code} VADT:` : `${prefix}${code} (${raw}) VADT:`;
  }

  function setDirectionalInputLabels(d1Label, d2Label, suffix = ' (from DB)') {
    const d1InputLabelEl = document.getElementById('macroInputD1Label');
    const d2InputLabelEl = document.getElementById('macroInputD2Label');
    const d1Text = formatDirectionalVadtLabel('D1', d1Label || 'Direction 1').replace(/:\s*$/, '');
    const d2Text = formatDirectionalVadtLabel('D2', d2Label || 'Direction 2').replace(/:\s*$/, '');
    if (d1InputLabelEl) d1InputLabelEl.textContent = `${d1Text}${suffix}`;
    if (d2InputLabelEl) d2InputLabelEl.textContent = `${d2Text}${suffix}`;
  }

  function applyManualEntryVisuals() {
    const setManualInput = (inputId, labelText, fallbackValue = null) => {
      const input = document.getElementById(inputId);
      if (!input) return;
      const wrapper = input.closest('div');
      const label = wrapper ? wrapper.querySelector('label') : null;

      input.readOnly = false;
      if (fallbackValue !== null && (input.value === '' || input.value === null || input.value === undefined)) {
        input.value = fallbackValue;
      }
      input.style.border = '1px solid #ffc107';
      input.style.backgroundColor = '#fffbf0';
      input.style.color = '#000';

      if (wrapper) {
        wrapper.style.background = '#fff3cd';
        wrapper.style.border = '1px solid #ffc107';
      }
      if (label) {
        label.style.color = '#c30000';
        label.textContent = labelText;
      }
    };

    setManualInput('macroGrowthRate', 'Growth Rate (% p.a.) *');
    setManualInput('HVP', 'HV (%) *', 5);
    setManualInput('D1_Lanes', 'D1 Lanes *', 1);
    setManualInput('D2_Lanes', 'D2 Lanes *', 1);

    const baseHvInput = document.getElementById('baseHVPercent');
    if (baseHvInput) baseHvInput.value = '';
  }

  function showCustomAddressDetails(detail = {}) {
    const panel = document.getElementById('macroSiteDetailsPanel');
    if (panel) panel.style.display = 'block';

    const setText = (id, value) => {
      const el = document.getElementById(id);
      if (el) el.textContent = value || '-';
    };

    const sourceEl = document.getElementById('macroDetailSource');
    if (sourceEl) {
      sourceEl.innerHTML = '<span class="source-pill source-custom-address">Custom Address</span>';
    }

    const qualityEl = document.getElementById('macroDetailQuality');
    if (qualityEl) {
      qualityEl.innerHTML = '<span class="quality-pill quality-estimated">Estimated (Reference-based)</span>';
    }

    const d1RowLabel = String(detail.d1Label || 'Direction 1').trim();
    const d2RowLabel = String(detail.d2Label || 'Direction 2').trim();
    const d1LabelEl = document.getElementById('macroDetailD1Label');
    const d2LabelEl = document.getElementById('macroDetailD2Label');
    if (d1LabelEl) d1LabelEl.textContent = formatDirectionalVadtLabel('D1', d1RowLabel);
    if (d2LabelEl) d2LabelEl.textContent = formatDirectionalVadtLabel('D2', d2RowLabel);

    const d1 = Math.max(0, Math.round(Number(detail.d1) || 0));
    const d2 = Math.max(0, Math.round(Number(detail.d2) || 0));
    const total = Math.max(0, Math.round(Number(detail.total) || (d1 + d2)));

    setText('macroDetailSiteId', detail.siteId || 'CUSTOM ADDRESS');
    setText('macroDetailRoadName', detail.roadName || detail.searchAddress || 'Custom Address');
    setText('macroDetailDescription', detail.description || 'Estimated from nearby reference counters');
    setText('macroDetailCountYear', detail.countYear || 'N/A');
    setText('macroDetailGrowthRate', 'N/A');
    setText('macroDetailHV', 'N/A');
    setText('macroDetailD1', d1.toLocaleString());
    setText('macroDetailD2', d2.toLocaleString());
    setText('macroDetailTotal', total.toLocaleString());

    const lat = Number(detail.lat);
    const lon = Number(detail.lon);
    const mapLink = document.getElementById('macroMapLink');
    if (Number.isFinite(lat) && Number.isFinite(lon)) {
      setText('macroDetailCoords', `${lat.toFixed(6)}, ${lon.toFixed(6)}`);
      if (mapLink) mapLink.href = `https://www.google.com/maps?q=${lat},${lon}`;
    } else {
      setText('macroDetailCoords', 'N/A');
      if (mapLink) mapLink.href = 'javascript:void(0)';
    }
  }

  document.getElementById('macroSiteSearch').addEventListener('input', (e) => {
    const value = e.target.value.trim();
    if (value && macroSitesData[value]) {
      selectMacroSite(value);
    }
  });

  document.getElementById('macroSiteSearch').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      const value = e.target.value.trim();
      if (value && macroSitesData[value]) {
        selectMacroSite(value);
        e.preventDefault();
      }
    }
  });

  const macroSourceFilterEl = document.getElementById('macroSourceFilter');
  if (macroSourceFilterEl) {
    macroSourceFilterEl.addEventListener('change', (e) => {
      macroSourceFilter = String((e.target && e.target.value) || 'ALL');
      const searchInput = document.getElementById('macroSiteSearch');
      if (searchInput) searchInput.value = '';
      populateMacroSitesDatalist();
      renderMacroMapSites();
    });
  }

  // Load sites on page load
  document.addEventListener('DOMContentLoaded', () => {
    const openingYearInput = document.getElementById('macroOpeningYear');
    if (openingYearInput) {
      openingYearInput.value = String(new Date().getFullYear());
    }
    initMacroMap();
    
    // --- ADD THIS NEW INITIALIZER ---
    if (!detourMapInstance && document.getElementById('detourMap') && typeof L !== 'undefined') {
      detourMapInstance = L.map('detourMap').setView([-27.55, 152.95], 8);
      addBaseLayerToMap(detourMapInstance);
      detourMapLayer = L.layerGroup().addTo(detourMapInstance);
      detourRoadPreviewLayer = L.layerGroup().addTo(detourMapInstance);
    }
    // --------------------------------

    loadMacroSitesData();

    // Global handler for any unhandled promise rejections (surface to UI)
    window.addEventListener('unhandledrejection', (ev) => {
      console.error('Unhandled promise rejection:', ev.reason);
      const errEl = document.getElementById('quickTiaError');
      if (errEl) { errEl.innerHTML = `<strong>‚ùå Unexpected error:</strong> ${String(ev.reason && ev.reason.message ? ev.reason.message : ev.reason)}`; errEl.style.display = 'block'; }
      try { ev.preventDefault(); } catch (_) {}
    });

    if (typeof window.performQuickTIASearch !== 'function') {
      window.performQuickTIASearch = async () => {
        const searchInputEl = document.getElementById('quickTiaInput');
        const searchInput = String((searchInputEl && searchInputEl.value) || '').trim();
        if (!searchInput) {
          alert('Please enter a road name or location');
          return;
        }

        const errEl = document.getElementById('quickTiaError');
        const panelEl = document.getElementById('quickTiaPanel');
        const geoSourceEl = document.getElementById('quickTiaGeoSource');
        const searchAddrEl = document.getElementById('quickTiaSearchAddress');
        const searchBtn = document.getElementById('quickTiaSearchBtn');
        let originalBtnText = null;
        if (searchBtn) {
          originalBtnText = searchBtn.innerHTML;
          searchBtn.innerHTML = '‚è≥ Searching...';
          searchBtn.disabled = true;
        }
        if (errEl) errEl.style.display = 'none';
        if (panelEl) panelEl.style.display = 'none';
        if (searchAddrEl) searchAddrEl.textContent = searchInput;
        if (geoSourceEl) geoSourceEl.textContent = 'Searching...';

        const toLocation = (item) => {
          if (!item) return null;
          const lat = Number(item.lat);
          const lon = Number(item.lon);
          if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
          return {
            lat,
            lon,
            displayName: item.display_name || item.name || searchInput,
            road: item.address ? (item.address.road || item.address.pedestrian || null) : null,
            provider: item.provider || 'Geocoder'
          };
        };

        const fetchJsonWithTimeout = async (url, timeoutMs = 9000) => {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
          try {
            const response = await fetch(url, { signal: controller.signal, headers: { 'Accept-Language': 'en-AU,en;q=0.9' } });
            if (!response.ok) return null;
            return await response.json();
          } catch (_err) {
            return null;
          } finally {
            clearTimeout(timeoutId);
          }
        };

        const geocodeOnline = async (address) => {
          const queries = [address, `${address}, Queensland, Australia`, `${address}, Australia`];
          for (const q of queries) {
            const nominatimAu = `https://nominatim.openstreetmap.org/search?format=jsonv2&limit=5&addressdetails=1&countrycodes=au&q=${encodeURIComponent(q)}`;
            const nominatimAny = `https://nominatim.openstreetmap.org/search?format=jsonv2&limit=5&addressdetails=1&q=${encodeURIComponent(q)}`;

            const responses = [
              { provider: 'Nominatim (AU)', data: await fetchJsonWithTimeout(nominatimAu) },
              { provider: 'Nominatim (Global)', data: await fetchJsonWithTimeout(nominatimAny) }
            ];

            for (const pack of responses) {
              const data = pack.data;
              if (!Array.isArray(data) || data.length === 0) continue;
              const preferredAu = data.find(item => String(item.display_name || '').toLowerCase().includes('australia'));
              const chosen = preferredAu || data[0];
              chosen.provider = pack.provider;
              const location = toLocation(chosen);
              if (location) return location;
            }
          }
          return null;
        };

        const haversine = (lat1, lon1, lat2, lon2) => {
          const R = 6371000;
          const p1 = lat1 * Math.PI / 180;
          const p2 = lat2 * Math.PI / 180;
          const dP = (lat2 - lat1) * Math.PI / 180;
          const dL = (lon2 - lon1) * Math.PI / 180;
          const a = Math.sin(dP / 2) * Math.sin(dP / 2) + Math.cos(p1) * Math.cos(p2) * Math.sin(dL / 2) * Math.sin(dL / 2);
          return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
        };

        const sameRoad = (a, b) => {
          const norm = (v) => String(v || '').toLowerCase().replace(/[.,'"-]/g, ' ').replace(/\b(st|street)\b/g, 'street').replace(/\b(rd|road)\b/g, 'road').replace(/\b(ave|avenue)\b/g, 'avenue').replace(/\b(dr|drive)\b/g, 'drive').replace(/\s+/g, ' ').trim();
          const r1 = norm(a);
          const r2 = norm(b);
          return !!(r1 && r2 && (r1 === r2 || (r1.length > 5 && r2.includes(r1)) || (r2.length > 5 && r1.includes(r2))));
        };

        try {
          const location = await geocodeOnline(searchInput);
          if (!location) {
            if (errEl) {
              errEl.innerHTML = '<strong>‚ùå Could not geocode that address.</strong><br><span style="font-size: 0.9em;">Try adding suburb/city/state.</span>';
              errEl.style.display = 'block';
            }
            return;
          }

          if (geoSourceEl) geoSourceEl.textContent = location.provider;
          if (typeof addSearchMarker === 'function') {
            try { addSearchMarker(location.lat, location.lon, searchInput); } catch (_) {}
          }

          const sites = Object.entries(macroSitesData || {})
            .filter(([, d]) => Number.isFinite(Number(d && d.latitude)) && Number.isFinite(Number(d && d.longitude)))
            .map(([id, data]) => {
              const dist = haversine(location.lat, location.lon, Number(data.latitude), Number(data.longitude));
              return { id, data, dist };
            })
            .sort((a, b) => a.dist - b.dist);

          if (!sites.length) {
            if (errEl) {
              errEl.innerHTML = '<strong>‚ùå Address found, but no traffic counter database loaded yet.</strong>';
              errEl.style.display = 'block';
            }
            return;
          }

          const targetRoad = location.road || searchInput;
          const sameRoadSites = sites.filter(s => sameRoad(targetRoad, s.data.road_name)).slice(0, 3);

          if (sameRoadSites.length === 1 && sameRoadSites[0].dist < 150 && typeof displayQuickTiaExactMatch === 'function') {
            displayQuickTiaExactMatch(sameRoadSites[0].id, sameRoadSites[0].data);
          } else if (sameRoadSites.length > 0 && typeof displayQuickTiaMultipleRefs === 'function') {
            const formatted = sameRoadSites.map(s => [s.id, s.data, s.dist, 'Nearby']);
            displayQuickTiaMultipleRefs(targetRoad, formatted, location.lat, location.lon, true);
          } else if (typeof displayQuickTiaMultipleRefs === 'function') {
            const nearest = sites.slice(0, 5).map(s => [s.id, s.data, s.dist, 'Nearby']);
            displayQuickTiaMultipleRefs(searchInput, nearest, location.lat, location.lon, false);
          } else {
            const nearest = sites[0];
            const d1 = Number(nearest.data.d1_vadt) || 0;
            const d2 = Number(nearest.data.d2_vadt) || 0;
            const vadt = Number(nearest.data.vadt) || (d1 + d2);
            const d1El = document.getElementById('D1_VADT');
            const d2El = document.getElementById('D2_VADT');
            const vadtEl = document.getElementById('VADT');
            if (d1El) d1El.value = d1;
            if (d2El) d2El.value = d2;
            if (vadtEl) vadtEl.value = vadt;
            if (typeof updateAssumptionsPanel === 'function') updateAssumptionsPanel(nearest.data);
          }
        } catch (err) {
          if (errEl) {
            errEl.innerHTML = `<strong>‚ùå Search failed:</strong> ${String(err && err.message ? err.message : err)}`;
            errEl.style.display = 'block';
          }
        } finally {
          if (searchBtn) {
            searchBtn.innerHTML = originalBtnText || 'üîç Search';
            searchBtn.disabled = false;
          }
        }
      };
    }

    // Attach quick-search handlers (make Search button clickable and support Enter)
    const runQuickTiaSearch = () => {
      const fn = window && window.performQuickTIASearch;
      if (typeof fn !== 'function') {
        console.error('performQuickTIASearch not available');
        const errEl = document.getElementById('quickTiaError');
        if (errEl) {
          errEl.innerHTML = '<strong>‚ùå Search function is not ready yet.</strong><br><span style="font-size: 0.9em;">Please refresh the page and try again.</span>';
          errEl.style.display = 'block';
        }
        return;
      }
      Promise.resolve(fn()).catch(err => {
        console.error(err);
        const errEl = document.getElementById('quickTiaError');
        if (errEl) {
          errEl.innerHTML = `<strong>‚ùå Search failed:</strong> ${String(err && err.message ? err.message : err)}`;
          errEl.style.display = 'block';
        }
      });
    };

    const quickBtn = document.getElementById('quickTiaSearchBtn');
    if (quickBtn) quickBtn.addEventListener('click', runQuickTiaSearch);

    const quickInput = document.getElementById('quickTiaInput');
    if (quickInput) quickInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') runQuickTiaSearch();
    });
    // Expose globally for any legacy inline references (guarded to avoid ReferenceError)
    if (typeof performQuickTIASearch === 'function') {
      window.performQuickTIASearch = performQuickTIASearch;
    }

    updateAssumptionsPanel();
  });

  // ===== EXISTING CALCULATION LOGIC =====

  const ids = [
    'RTR','DTCA','DHVPA','DRTPA','VADT','D1_VADT','D2_VADT','HVP','RTP','D1_HVP','D2_HVP','D1_RTP','D2_RTP','D1_Lanes','D2_Lanes',
    'macroOpeningYear','macroGrowthRate','macroTerrainType'
  ];
  function txt(id){
    const el = document.getElementById(id);
    return String((el && el.value) || '').trim();
  }
  function num(id){
    const el = document.getElementById(id);
    return Number((el && el.value) || 0) || 0;
  }
  function numberRoundUp(n, digits=0){
    const m = Math.pow(10,digits);
    return Math.ceil(((Number(n)||0) * m) - 1e-12) / m;
  }
  function ceilingVBA(n, sig){
    if (!sig) return 0;
    return Math.ceil((Number(n)||0)/sig)*sig;
  }

  function applyYesNoColor(selectId){
    const el = document.getElementById(selectId);
    if (!el) return;
    el.classList.remove('status-yes','status-no');
    if (el.value === 'Yes') el.classList.add('status-yes');
    if (el.value === 'No') el.classList.add('status-no');
  }

  function syncVisibility(){
    const shouldHideDirectional = txt('DTCA') !== 'Yes';
    const wrap = document.getElementById('dirVadtWrap');
    if (wrap) {
      wrap.classList.toggle('hidden', shouldHideDirectional);
      return;
    }

    const d1Card = (document.getElementById('D1_VADT') || {}).closest ? document.getElementById('D1_VADT').closest('div[style]') : null;
    const d2Card = (document.getElementById('D2_VADT') || {}).closest ? document.getElementById('D2_VADT').closest('div[style]') : null;
    [d1Card, d2Card].forEach(card => {
      if (card && card.classList) card.classList.toggle('hidden', shouldHideDirectional);
    });
  }

  function syncDirectionalRtFromOverall() {
    const rtrYes = txt('RTR').toUpperCase() === 'YES';
    const drtpaNo = txt('DRTPA').toUpperCase() === 'NO';
    if (!rtrYes || !drtpaNo) return;

    const rtp = num('RTP');
    const d1 = document.getElementById('D1_RTP');
    const d2 = document.getElementById('D2_RTP');
    if (d1) d1.value = String(rtp);
    if (d2) d2.value = String(rtp);
  }

  function getHVPercent(direction){
    const dhvpa = txt('DHVPA').toUpperCase();
    if (dhvpa === 'YES') return numberRoundUp(num(`D${direction}_HVP`) / 100, 12);
    return numberRoundUp((num('HVP') / 2) / 100, 12);
  }

  function getRTPercent(direction){
    const drtpa = txt('DRTPA').toUpperCase();
    if (drtpa === 'YES') return numberRoundUp(num(`D${direction}_RTP`) / 100, 12);
    return numberRoundUp((num('RTP') / 2) / 100, 12);
  }

  function baseDirectionalVolume(direction){
    const dtca = txt('DTCA').toUpperCase();
    const vadt = num('VADT');
    if (dtca === 'YES') return num(`D${direction}_VADT`) * 0.12 * 0.8;
    return vadt * 0.12 * 0.8 * 0.5;
  }

  function calcDirection(direction){
    const lanes = Math.max(1, num(`D${direction}_Lanes`));

    const peakHV = numberRoundUp(baseDirectionalVolume(direction) * getHVPercent(direction), 0);
    const peakRT = numberRoundUp(baseDirectionalVolume(direction) * getRTPercent(direction), 0);
    const peakLV = numberRoundUp(baseDirectionalVolume(direction) - peakHV - peakRT, 0);

    const offLV = numberRoundUp(peakLV * 0.42, 0);
    const offHV = numberRoundUp(peakHV * 0.42, 0);
    const offRT = numberRoundUp(peakRT * 0.42, 0);

    const peakLVPL = numberRoundUp(peakLV / lanes, 0);
    const peakHVPL = numberRoundUp(peakHV / lanes, 0);
    const peakRTPL = numberRoundUp(peakRT / lanes, 0);

    const offLVPL = numberRoundUp(offLV / lanes, 0);
    const offHVPL = numberRoundUp(offHV / lanes, 0);
    const offRTPL = numberRoundUp(offRT / lanes, 0);

    const lv5mp = numberRoundUp(peakLVPL * 5 / 60, 0);
    const hv5mp = numberRoundUp(peakHVPL * 5 / 60, 0);
    const rt5mp = numberRoundUp(peakRTPL * 5 / 60, 0);

    const lv5mop = numberRoundUp(offLVPL * 5 / 60, 0);
    const hv5mop = numberRoundUp(offHVPL * 5 / 60, 0);
    const rt5mop = numberRoundUp(offRTPL * 5 / 60, 0);

    let q2qp = lv5mp*2.4 + hv5mp*8 + rt5mp*25.2;
    let q5qp = lv5mp*6 + hv5mp*20 + rt5mp*63;
    let q2qop = lv5mop*2.4 + hv5mop*8 + rt5mop*25.2;
    let q5qop = lv5mop*6 + hv5mop*20 + rt5mop*63;

    const rtr = txt('RTR').toUpperCase();
    const roadTrainFactor = rtr === 'YES' ? 1.5 : 1;
    const minQ = rtr === 'YES' ? 89 : 26;
    q2qp = q2qp * roadTrainFactor;
    q5qp = q5qp * roadTrainFactor;
    q2qop = q2qop * roadTrainFactor;
    q5qop = q5qop * roadTrainFactor;
    q2qp = q2qp < minQ ? minQ : q2qp;
    q5qp = q5qp < minQ ? minQ : q5qp;
    q2qop = q2qop < minQ ? minQ : q2qop;
    q5qop = q5qop < minQ ? minQ : q5qop;

    q2qp = ceilingVBA(q2qp, 5);
    q5qp = ceilingVBA(q5qp, 5);
    q2qop = ceilingVBA(q2qop, 5);
    q5qop = ceilingVBA(q5qop, 5);

    return {
      lanes,
      peakLV, peakHV, peakRT,
      offLV, offHV, offRT,
      peakLVPL, peakHVPL, peakRTPL,
      offLVPL, offHVPL, offRTPL,
      lv5mp, hv5mp, rt5mp,
      lv5mop, hv5mop, rt5mop,
      q2qp, q2qop, q5qp, q5qop
    };
  }

  function calculateDV(){
    const totalLanes = Math.max(1, num('D1_Lanes') + num('D2_Lanes'));
    let dv = num('VADT') * 0.12 / totalLanes;
    if (dv < 500) dv = 500;
    return numberRoundUp(dv, 0);
  }

  function vcrColor(v){
    if (v === null || Number.isNaN(v) || v < 0) return '';
    if (v <= 0.6) return '#00eb00';
    if (v <= 0.7) return '#add8e6';
    if (v <= 0.9) return '#ffff00';
    if (v <= 0.95) return '#ffc896';
    if (v <= 1.0) return '#ffc000';
    return '#c00000';
  }

  function fmtVcr(v){ return (v === null || Number.isNaN(v) || v < 0) ? 'N/A' : v.toFixed(3); }
  function losLabel(v){
    if (v === null || Number.isNaN(v) || v < 0) return 'N/A';
    if (v <= 0.60) return 'LOS A';
    if (v <= 0.70) return 'LOS B';
    if (v <= 0.90) return 'LOS C';
    if (v <= 0.95) return 'LOS D';
    if (v <= 1.00) return 'LOS E';
    return 'LOS F';
  }

  function setVcrCell(td, value){
    td.textContent = fmtVcr(value);
    td.style.background = vcrColor(value);
    td.style.fontWeight = '700';
  }

  function setVcrLosCell(td, value){
    td.textContent = `${fmtVcr(value)} (${losLabel(value)})`;
    td.style.background = vcrColor(value);
    td.style.fontWeight = '700';
  }

  let vcrChartD1Instance = null;
  let vcrChartD2Instance = null;
  let lastVcrChartData = null;
  let queueChartD1Instance = null;
  let queueChartD2Instance = null;
  let lastQueueChartData = null;
  let hourlyQueueChartInstance = null;
  let hourlyVcrChartInstance = null;
  let lastHourlyQueueChartData = null;
  let lastHourlyVcrChartData = null;

  function setVcrView(mode) {
    const tableView = document.getElementById('vcrTableView');
    const chartView = document.getElementById('vcrChartView');
    const showChart = mode === 'chart';

    if (tableView) tableView.style.display = showChart ? 'none' : 'block';
    if (chartView) chartView.style.display = showChart ? 'block' : 'none';

    const tableBtns = document.querySelectorAll('.vcr-toggle-btn[data-view="table"]');
    const chartBtns = document.querySelectorAll('.vcr-toggle-btn[data-view="chart"]');

    tableBtns.forEach(btn => {
      btn.style.background = showChart ? '#f5f5f5' : '#e3f2fd';
      btn.style.color = showChart ? '#37474f' : '#0d47a1';
    });
    chartBtns.forEach(btn => {
      btn.style.background = showChart ? '#e3f2fd' : '#f5f5f5';
      btn.style.color = showChart ? '#0d47a1' : '#37474f';
    });

    if (showChart && lastVcrChartData) {
      renderVcrCharts(lastVcrChartData);
    }
  }

  function setQueueView(mode) {
    const tableView = document.getElementById('queueTableView');
    const chartView = document.getElementById('queueChartView');
    const showChart = mode === 'chart';

    if (tableView) tableView.style.display = showChart ? 'none' : 'block';
    if (chartView) chartView.style.display = showChart ? 'block' : 'none';

    const tableBtns = document.querySelectorAll('.queue-toggle-btn[data-view="table"]');
    const chartBtns = document.querySelectorAll('.queue-toggle-btn[data-view="chart"]');

    tableBtns.forEach(btn => {
      btn.style.background = showChart ? '#f5f5f5' : '#e3f2fd';
      btn.style.color = showChart ? '#37474f' : '#0d47a1';
    });
    chartBtns.forEach(btn => {
      btn.style.background = showChart ? '#e3f2fd' : '#f5f5f5';
      btn.style.color = showChart ? '#0d47a1' : '#37474f';
    });

    if (showChart && lastQueueChartData) {
      renderQueueCharts(lastQueueChartData);
    }
  }

  function setHourlyQueueView(mode) {
    const tableView = document.getElementById('hourlyQueueTableView');
    const chartView = document.getElementById('hourlyQueueChartView');
    const showChart = mode === 'chart';

    if (tableView) tableView.style.display = showChart ? 'none' : 'block';
    if (chartView) chartView.style.display = showChart ? 'block' : 'none';

    const tableBtns = document.querySelectorAll('.hourly-queue-toggle-btn[data-view="table"]');
    const chartBtns = document.querySelectorAll('.hourly-queue-toggle-btn[data-view="chart"]');

    tableBtns.forEach(btn => {
      btn.style.background = showChart ? '#f5f5f5' : '#e3f2fd';
      btn.style.color = showChart ? '#37474f' : '#0d47a1';
    });
    chartBtns.forEach(btn => {
      btn.style.background = showChart ? '#e3f2fd' : '#f5f5f5';
      btn.style.color = showChart ? '#0d47a1' : '#37474f';
    });

    if (showChart && lastHourlyQueueChartData) renderHourlyQueueChart(lastHourlyQueueChartData);
  }

  function setHourlyVcrView(mode) {
    const tableView = document.getElementById('hourlyVcrTableView');
    const chartView = document.getElementById('hourlyVcrChartView');
    const showChart = mode === 'chart';

    if (tableView) tableView.style.display = showChart ? 'none' : 'block';
    if (chartView) chartView.style.display = showChart ? 'block' : 'none';

    const tableBtns = document.querySelectorAll('.hourly-vcr-toggle-btn[data-view="table"]');
    const chartBtns = document.querySelectorAll('.hourly-vcr-toggle-btn[data-view="chart"]');

    tableBtns.forEach(btn => {
      btn.style.background = showChart ? '#f5f5f5' : '#e3f2fd';
      btn.style.color = showChart ? '#37474f' : '#0d47a1';
    });
    chartBtns.forEach(btn => {
      btn.style.background = showChart ? '#e3f2fd' : '#f5f5f5';
      btn.style.color = showChart ? '#0d47a1' : '#37474f';
    });

    if (showChart && lastHourlyVcrChartData) renderHourlyVcrChart(lastHourlyVcrChartData);
  }

  function renderVcrCharts({ labels, baseD1, slcD1, slrf, baseD2, slcD2, d1Label, d2Label }) {
    const buildSeries = (values) => labels.map(k => Number.isFinite(values[k]) ? Number(values[k]) : null);
    const computeMaxY = (...seriesList) => {
      const flat = seriesList.flat().filter(v => Number.isFinite(v));
      const maxVal = flat.length ? Math.max(...flat) : 1.2;
      return Math.max(1.2, Math.ceil((maxVal + 0.12) * 10) / 10);
    };

    const datasetsFor = (base, slc) => {
      const baseSeries = buildSeries(base);
      const slcSeries = buildSeries(slc);
      const slrfSeries = buildSeries(slrf);
      const maxY = computeMaxY(baseSeries, slcSeries, slrfSeries);
      return {
        maxY,
        datasets: [
          {
            type: 'bar',
            label: 'Base VCR',
            data: baseSeries,
            borderColor: '#1e88e5',
            backgroundColor: 'rgba(30,136,229,0.45)',
            borderWidth: 1,
            borderRadius: 4,
            barPercentage: 0.82,
            categoryPercentage: 0.72
          },
          {
            type: 'bar',
            label: 'Single Lane Closure',
            data: slcSeries,
            borderColor: '#fb8c00',
            backgroundColor: 'rgba(251,140,0,0.45)',
            borderWidth: 1,
            borderRadius: 4,
            barPercentage: 0.82,
            categoryPercentage: 0.72
          },
          {
            type: 'bar',
            label: 'Single Lane Reversible Flow',
            data: slrfSeries,
            borderColor: '#00897b',
            backgroundColor: 'rgba(0,137,123,0.45)',
            borderWidth: 1,
            borderRadius: 4,
            barPercentage: 0.82,
            categoryPercentage: 0.72
          },
          {
            type: 'line',
            label: 'Target 0.85',
            data: labels.map(() => 0.85),
            borderColor: '#7b1fa2',
            borderDash: [6, 4],
            pointRadius: 0,
            borderWidth: 2
          },
          {
            type: 'line',
            label: 'Capacity 1.00',
            data: labels.map(() => 1.0),
            borderColor: '#c62828',
            borderDash: [2, 3],
            pointRadius: 0,
            borderWidth: 2
          }
        ]
      };
    };

    const buildOptions = (maxY) => ({
      responsive: true,
      maintainAspectRatio: false,
      interaction: { mode: 'index', intersect: false },
      scales: {
        y: {
          beginAtZero: true,
          suggestedMax: maxY,
          ticks: { callback: (v) => Number(v).toFixed(2) },
          title: { display: true, text: 'V/C Ratio' }
        },
        x: {
          title: { display: true, text: 'Period' }
        }
      },
      plugins: {
        legend: { position: 'bottom' },
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const value = ctx.parsed.y;
              if (!Number.isFinite(value)) return `${ctx.dataset.label}: N/A`;
              if (ctx.dataset.label === 'Target 0.85' || ctx.dataset.label === 'Capacity 1.00') {
                return `${ctx.dataset.label}: ${value.toFixed(2)}`;
              }
              return `${ctx.dataset.label}: ${value.toFixed(3)} (${losLabel(value)})`;
            }
          }
        }
      }
    });

    const ctxD2 = document.getElementById('vcrChartD2');
    if (ctxD2) {
      const d2Chart = datasetsFor(baseD2, slcD2);
      if (vcrChartD2Instance) vcrChartD2Instance.destroy();
      vcrChartD2Instance = new Chart(ctxD2, {
        type: 'bar',
        data: { labels, datasets: d2Chart.datasets },
        options: buildOptions(d2Chart.maxY)
      });
    }

    const ctxD1 = document.getElementById('vcrChartD1');
    if (ctxD1) {
      const d1Chart = datasetsFor(baseD1, slcD1);
      if (vcrChartD1Instance) vcrChartD1Instance.destroy();
      vcrChartD1Instance = new Chart(ctxD1, {
        type: 'bar',
        data: { labels, datasets: d1Chart.datasets },
        options: buildOptions(d1Chart.maxY)
      });
    }
  }

  function renderQueueCharts({ labels, d1, d2, d1Label, d2Label }) {
    const buildSeries = (directionQueues, key) => labels.map(period => {
      const value = directionQueues && directionQueues[period] ? Number(directionQueues[period][key]) : null;
      return Number.isFinite(value) ? value : null;
    });

    const datasetsFor = (queues) => {
      const q2 = buildSeries(queues, 'q2');
      const q5 = buildSeries(queues, 'q5');
      const q10 = buildSeries(queues, 'q10');
      const q15 = buildSeries(queues, 'q15');
      const maxVal = Math.max(...[...q2, ...q5, ...q10, ...q15].filter(v => Number.isFinite(v)), 0);
      const maxY = Math.max(200, Math.ceil((maxVal + 40) / 20) * 20);
      return {
        maxY,
        datasets: [
          {
            type: 'bar',
            label: '2 min queue',
            data: q2,
            borderColor: '#1e88e5',
            backgroundColor: 'rgba(30,136,229,0.45)',
            borderRadius: 4,
            borderWidth: 1,
            barPercentage: 0.82,
            categoryPercentage: 0.72
          },
          {
            type: 'bar',
            label: '5 min queue',
            data: q5,
            borderColor: '#43a047',
            backgroundColor: 'rgba(67,160,71,0.45)',
            borderRadius: 4,
            borderWidth: 1,
            barPercentage: 0.82,
            categoryPercentage: 0.72
          },
          {
            type: 'bar',
            label: '10 min queue',
            data: q10,
            borderColor: '#fb8c00',
            backgroundColor: 'rgba(251,140,0,0.45)',
            borderRadius: 4,
            borderWidth: 1,
            barPercentage: 0.82,
            categoryPercentage: 0.72
          },
          {
            type: 'bar',
            label: '15 min queue',
            data: q15,
            borderColor: '#c62828',
            backgroundColor: 'rgba(198,40,40,0.45)',
            borderRadius: 4,
            borderWidth: 1,
            barPercentage: 0.82,
            categoryPercentage: 0.72
          },
          {
            type: 'line',
            label: 'Watch 200m',
            data: labels.map(() => 200),
            borderColor: '#6d4c41',
            borderDash: [6, 4],
            pointRadius: 0,
            borderWidth: 2
          },
          {
            type: 'line',
            label: 'High 400m',
            data: labels.map(() => 400),
            borderColor: '#ad1457',
            borderDash: [2, 3],
            pointRadius: 0,
            borderWidth: 2
          }
        ]
      };
    };

    const buildOptions = (titleText, maxY) => ({
      responsive: true,
      maintainAspectRatio: false,
      interaction: { mode: 'index', intersect: false },
      scales: {
        y: {
          beginAtZero: true,
          suggestedMax: maxY,
          title: { display: true, text: 'Queue Length (m)' }
        },
        x: {
          title: { display: true, text: 'Period' }
        }
      },
      plugins: {
        legend: { position: 'bottom' },
        title: { display: false, text: titleText },
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const value = ctx.parsed.y;
              if (!Number.isFinite(value)) return `${ctx.dataset.label}: N/A`;
              return `${ctx.dataset.label}: ${Math.round(value).toLocaleString()} m`;
            }
          }
        }
      }
    });

    const ctxD2 = document.getElementById('queueChartD2');
    if (ctxD2) {
      const d2Chart = datasetsFor(d2);
      if (queueChartD2Instance) queueChartD2Instance.destroy();
      queueChartD2Instance = new Chart(ctxD2, {
        type: 'bar',
        data: { labels, datasets: d2Chart.datasets },
        options: buildOptions(d2Label, d2Chart.maxY)
      });
    }

    const ctxD1 = document.getElementById('queueChartD1');
    if (ctxD1) {
      const d1Chart = datasetsFor(d1);
      if (queueChartD1Instance) queueChartD1Instance.destroy();
      queueChartD1Instance = new Chart(ctxD1, {
        type: 'bar',
        data: { labels, datasets: d1Chart.datasets },
        options: buildOptions(d1Label, d1Chart.maxY)
      });
    }
  }

  function renderHourlyQueueChart({ labels, d1Max, d2Max, networkMax }) {
    const maxVal = Math.max(...[...d1Max, ...d2Max, ...networkMax].filter(v => Number.isFinite(v)), 0);
    const maxY = Math.max(200, Math.ceil((maxVal + 40) / 20) * 20);
    const d1Colors = labels.map((_, idx) => isPeakTrafficHour(idx) ? 'rgba(255,143,0,0.45)' : 'rgba(46,125,50,0.35)');
    const d2Colors = labels.map((_, idx) => isPeakTrafficHour(idx) ? 'rgba(230,74,25,0.45)' : 'rgba(198,40,40,0.35)');
    const ctx = document.getElementById('hourlyQueueChart');
    if (!ctx) return;
    if (hourlyQueueChartInstance) hourlyQueueChartInstance.destroy();
    hourlyQueueChartInstance = new Chart(ctx, {
      type: 'bar',
      data: {
        labels,
        datasets: [
          { label: 'D1 Max Queue', data: d1Max, backgroundColor: d1Colors, borderColor: '#2e7d32', borderWidth: 1, borderRadius: 3 },
          { label: 'D2 Max Queue', data: d2Max, backgroundColor: d2Colors, borderColor: '#c62828', borderWidth: 1, borderRadius: 3 },
          { type: 'line', label: 'Network Max Queue', data: networkMax, borderColor: '#1565c0', pointRadius: 0, borderWidth: 2 },
          { type: 'line', label: 'Watch 200m', data: labels.map(() => 200), borderColor: '#6d4c41', borderDash: [6, 4], pointRadius: 0, borderWidth: 2 },
          { type: 'line', label: 'High 400m', data: labels.map(() => 400), borderColor: '#ad1457', borderDash: [2, 3], pointRadius: 0, borderWidth: 2 }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: 'index', intersect: false },
        scales: {
          y: { beginAtZero: true, suggestedMax: maxY, title: { display: true, text: 'Queue Length (m)' } },
          x: { title: { display: true, text: 'Hour' } }
        },
        plugins: { legend: { position: 'bottom' } }
      }
    });
  }

  function renderHourlyVcrChart({ labels, d1Work, d2Work, worst }) {
    const maxVal = Math.max(...[...d1Work, ...d2Work, ...worst].filter(v => Number.isFinite(v)), 0);
    const maxY = Math.max(1.2, Math.ceil((maxVal + 0.12) * 10) / 10);
    const ctx = document.getElementById('hourlyVcrChart');
    if (!ctx) return;
    if (hourlyVcrChartInstance) hourlyVcrChartInstance.destroy();
    hourlyVcrChartInstance = new Chart(ctx, {
      type: 'bar',
      data: {
        labels,
        datasets: [
          { label: 'D1 Work VCR', data: d1Work, backgroundColor: 'rgba(46,125,50,0.45)', borderColor: '#2e7d32', borderWidth: 1, borderRadius: 3 },
          { label: 'D2 Work VCR', data: d2Work, backgroundColor: 'rgba(198,40,40,0.45)', borderColor: '#c62828', borderWidth: 1, borderRadius: 3 },
          { type: 'line', label: 'Worst Work VCR', data: worst, borderColor: '#1565c0', pointRadius: 0, borderWidth: 2 },
          { type: 'line', label: 'Target 0.85', data: labels.map(() => 0.85), borderColor: '#7b1fa2', borderDash: [6, 4], pointRadius: 0, borderWidth: 2 },
          { type: 'line', label: 'Capacity 1.00', data: labels.map(() => 1.0), borderColor: '#c62828', borderDash: [2, 3], pointRadius: 0, borderWidth: 2 }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: 'index', intersect: false },
        scales: {
          y: { beginAtZero: true, suggestedMax: maxY, ticks: { callback: (v) => Number(v).toFixed(2) }, title: { display: true, text: 'V/C Ratio' } },
          x: { title: { display: true, text: 'Hour' } }
        },
        plugins: {
          legend: { position: 'bottom' },
          tooltip: {
            callbacks: {
              label: (ctx) => {
                const value = ctx.parsed.y;
                if (!Number.isFinite(value)) return `${ctx.dataset.label}: N/A`;
                if (ctx.dataset.label === 'Target 0.85' || ctx.dataset.label === 'Capacity 1.00') return `${ctx.dataset.label}: ${value.toFixed(2)}`;
                return `${ctx.dataset.label}: ${value.toFixed(3)} (${losLabel(value)})`;
              }
            }
          }
        }
      }
    });
  }

  const periods = [
    { key: 'AM', hours: [7, 8] },
    { key: 'OP', hours: [9, 10, 11, 12, 13, 14, 15] },
    { key: 'PM', hours: [16, 17] },
    { key: 'EV', hours: [18, 19, 20, 21, 22, 23, 0, 1, 2, 3, 4, 5, 6] }
  ];

  function queueFromFiveMinute(total5, hvPct, rtPct, isRtr){
    const hv = total5 * hvPct;
    const rt = total5 * rtPct;
    const lv = Math.max(0, total5 - hv - rt);

    let q2 = (lv * 2.4) + (hv * 8) + (rt * 25.2);
    let q5 = (lv * 6) + (hv * 20) + (rt * 63);
    let q10 = (lv * 12) + (hv * 40) + (rt * 126);
    let q15 = (lv * 18) + (hv * 60) + (rt * 189);

    const factor = isRtr ? 1.5 : 1;
    const minQ = isRtr ? 89 : 26;

    q2 = Math.max(q2 * factor, minQ);
    q5 = Math.max(q5 * factor, minQ);
    q10 = Math.max(q10 * factor, minQ);
    q15 = Math.max(q15 * factor, minQ);

    return {
      q2: ceilingVBA(q2, 5),
      q5: ceilingVBA(q5, 5),
      q10: ceilingVBA(q10, 5),
      q15: ceilingVBA(q15, 5)
    };
  }

  function buildPeriodProfile(direction, dailyTotal, hvPct, rtPct, laneCount, rtrYes){
    const profile = {};
    const site = selectedMacroSite ? macroSitesData[selectedMacroSite] : null;
    const directionKey = direction === 1 ? 'GAZETTAL' : 'AGAINST GAZETTAL';
    const hourly = site && site.directions_weekday && Array.isArray(site.directions_weekday[directionKey])
      ? site.directions_weekday[directionKey]
      : null;

    const fallbackShares = { AM: 0.2, OP: 0.4, PM: 0.2, EV: 0.2 };
    const baseByPeriod = { AM: 0, OP: 0, PM: 0, EV: 0 };

    const hourlyTotal = hourly
      ? hourly.reduce((sum, value) => sum + (Number(value) || 0), 0)
      : 0;

    if (hourly && hourlyTotal > 0) {
      periods.forEach(period => {
        baseByPeriod[period.key] = period.hours.reduce((sum, hour) => sum + (Number(hourly[hour]) || 0), 0);
      });
    } else {
      periods.forEach(period => {
        baseByPeriod[period.key] = (Number(dailyTotal) || 0) * fallbackShares[period.key];
      });
    }

    const baseTotal = periods.reduce((sum, period) => sum + baseByPeriod[period.key], 0);
    const scale = baseTotal > 0 ? (Number(dailyTotal) || 0) / baseTotal : 1;

    const allocateByWeights = (totalUnits, weights) => {
      const safeTotal = Math.max(0, Math.round(Number(totalUnits) || 0));
      const positiveWeights = weights.map(w => Math.max(0, Number(w) || 0));
      const weightSum = positiveWeights.reduce((sum, value) => sum + value, 0);
      if (safeTotal === 0) return new Array(weights.length).fill(0);

      if (weightSum <= 0) {
        const equal = Math.floor(safeTotal / weights.length);
        const out = new Array(weights.length).fill(equal);
        let remainder = safeTotal - (equal * weights.length);
        for (let i = 0; i < out.length && remainder > 0; i += 1) {
          out[i] += 1;
          remainder -= 1;
        }
        return out;
      }

      const raw = positiveWeights.map(w => (safeTotal * w) / weightSum);
      const base = raw.map(v => Math.floor(v));
      let remainder = safeTotal - base.reduce((sum, value) => sum + value, 0);

      const order = raw
        .map((v, idx) => ({ idx, frac: v - Math.floor(v) }))
        .sort((a, b) => b.frac - a.frac);

      let pos = 0;
      while (remainder > 0 && order.length > 0) {
        base[order[pos % order.length].idx] += 1;
        remainder -= 1;
        pos += 1;
      }

      return base;
    };

    const rawPeriodTotals = periods.map(period => Math.max(0, baseByPeriod[period.key] * scale));
    const dailyTotalInt = Math.max(0, Math.round(Number(dailyTotal) || 0));
    const periodTotals = allocateByWeights(dailyTotalInt, rawPeriodTotals);
    const hvTotal = Math.round(dailyTotalInt * Math.max(0, Number(hvPct) || 0));
    const rtTotal = Math.round(dailyTotalInt * Math.max(0, Number(rtPct) || 0));
    const hvByPeriod = allocateByWeights(hvTotal, periodTotals);
    const rtByPeriod = allocateByWeights(rtTotal, periodTotals);

    periods.forEach((period, idx) => {
      const total = periodTotals[idx];
      let hv = hvByPeriod[idx];
      let rt = rtByPeriod[idx];

      if (hv + rt > total) {
        const overflow = (hv + rt) - total;
        if (rt >= overflow) rt -= overflow;
        else {
          const remaining = overflow - rt;
          rt = 0;
          hv = Math.max(0, hv - remaining);
        }
      }

      const lv = Math.max(0, total - hv - rt);
      const hoursCount = period.hours.length;
      const hourlyAvg = hoursCount > 0 ? total / hoursCount : 0;
      const hourlyPerLane = laneCount > 0 ? hourlyAvg / laneCount : 0;
      const per5 = hourlyPerLane / 12;
      const queue = queueFromFiveMinute(per5, hvPct, rtPct, rtrYes);

      profile[period.key] = { total, lv, hv, rt, hourlyPerLane, per5, queue };
    });

    return profile;
  }

  function buildSyntheticHourlyFromDaily(dailyTotal) {
    const total = Math.max(0, Math.round(Number(dailyTotal) || 0));
    const hourly = new Array(24).fill(0);
    if (total <= 0) return hourly;

    const blocks = [
      { hours: [7, 8], share: 2 / 24 },
      { hours: [9, 10, 11, 12, 13, 14, 15], share: 7 / 24 },
      { hours: [16, 17], share: 2 / 24 },
      { hours: [18, 19, 20, 21, 22, 23, 0, 1, 2, 3, 4, 5, 6], share: 13 / 24 }
    ];

    let assigned = 0;
    blocks.forEach((block, index) => {
      const blockTotal = index === blocks.length - 1 ? (total - assigned) : Math.round(total * block.share);
      assigned += blockTotal;
      const perHour = Math.floor(blockTotal / block.hours.length);
      let remainder = blockTotal - (perHour * block.hours.length);
      block.hours.forEach((hour, idx) => {
        hourly[hour] = perHour + (idx < remainder ? 1 : 0);
      });
    });

    return hourly;
  }

  function getCurrentQuickReferenceWeights(refs) {
    const safeRefs = Array.isArray(refs) ? refs : [];
    if (!safeRefs.length) return [];

    const sliderInputs = Array.from(document.querySelectorAll('#quickTiaRefList .ref-weight'));
    const bySite = new Map();
    sliderInputs.forEach(input => {
      const siteId = String((input && input.dataset && input.dataset.siteid) || '').trim();
      if (!siteId) return;
      bySite.set(siteId, Math.max(0, Math.min(100, Number(input.value) || 0)) / 100);
    });

    let weights = safeRefs.map(ref => {
      const siteId = String((ref && ref.siteId) || '').trim();
      const sliderWeight = bySite.has(siteId) ? bySite.get(siteId) : (1 / safeRefs.length);
      const typeFactor = Math.max(0.3, Math.min(1.4, (Number(ref && ref.typePercent) || 100) / 100));
      return sliderWeight * typeFactor;
    });

    const total = weights.reduce((sum, value) => sum + value, 0);
    if (!(total > 0)) {
      return safeRefs.map(() => (1 / safeRefs.length));
    }
    return weights.map(value => value / total);
  }

  function buildWeightedHourlyFromReferences(direction, dailyTotal) {
    if (!window.selectedTiaData || window.selectedTiaData.type !== 'references') return null;
    const refs = Array.isArray(window.selectedTiaData.references) ? window.selectedTiaData.references : [];
    if (!refs.length) return null;

    const directionKey = direction === 1 ? 'GAZETTAL' : 'AGAINST GAZETTAL';
    const directionDailyKey = direction === 1 ? 'd1_vadt' : 'd2_vadt';
    const weights = getCurrentQuickReferenceWeights(refs);
    const shareTemplate = new Array(24).fill(0);

    refs.forEach((ref, index) => {
      const weight = Number(weights[index]) || 0;
      if (weight <= 0) return;

      const site = macroSitesData[ref.siteId] || null;
      let hourly = site && site.directions_weekday && Array.isArray(site.directions_weekday[directionKey])
        ? site.directions_weekday[directionKey].map(v => Math.max(0, Number(v) || 0))
        : null;

      if (!hourly || hourly.length !== 24) {
        const refDaily = Number(ref && ref[directionDailyKey]) || 0;
        hourly = buildSyntheticHourlyFromDaily(refDaily);
      }

      const total = hourly.reduce((sum, value) => sum + (Number(value) || 0), 0);
      if (!(total > 0)) return;

      for (let h = 0; h < 24; h += 1) {
        shareTemplate[h] += (hourly[h] / total) * weight;
      }
    });

    const shareTotal = shareTemplate.reduce((sum, value) => sum + value, 0);
    if (!(shareTotal > 0)) return null;

    const normalizedShares = shareTemplate.map(value => value / shareTotal);
    const targetDaily = Math.max(0, Number(dailyTotal) || 0);
    return normalizedShares.map(share => share * targetDaily);
  }

  function buildHourlyDirectionProfile(direction, dailyTotal, hvPct, rtPct, laneCount, rtrYes) {
    const directionKey = direction === 1 ? 'GAZETTAL' : 'AGAINST GAZETTAL';
    const site = selectedMacroSite ? macroSitesData[selectedMacroSite] : null;
    const sourceHourly = site && site.directions_weekday && Array.isArray(site.directions_weekday[directionKey])
      ? site.directions_weekday[directionKey].map(v => Number(v) || 0)
      : null;

    const weightedHourly = (!sourceHourly || sourceHourly.length !== 24)
      ? buildWeightedHourlyFromReferences(direction, dailyTotal)
      : null;

    let hourly = sourceHourly && sourceHourly.length === 24
      ? sourceHourly.slice(0, 24)
      : (weightedHourly && weightedHourly.length === 24 ? weightedHourly.slice(0, 24) : buildSyntheticHourlyFromDaily(dailyTotal));

    const sourceTotal = hourly.reduce((sum, value) => sum + (Number(value) || 0), 0);
    const targetTotal = Math.max(0, Number(dailyTotal) || 0);
    const scale = sourceTotal > 0 ? (targetTotal / sourceTotal) : 1;
    hourly = hourly.map(value => Math.max(0, value * scale));

    const profile = {};
    for (let hour = 0; hour < 24; hour += 1) {
      const total = Math.max(0, hourly[hour] || 0);
      const perLane = laneCount > 0 ? (total / laneCount) : 0;
      const per5 = perLane / 12;
      const queue = queueFromFiveMinute(per5, hvPct, rtPct, rtrYes);
      profile[hour] = {
        total,
        perLane,
        queue
      };
    }

    return profile;
  }

  function fmtVcrLos(v) {
    if (!Number.isFinite(v) || v < 0) return 'N/A';
    return `${v.toFixed(3)} (${losLabel(v)})`;
  }

  function getTrafficBucket(hour) {
    const h = Number(hour);
    if (h >= 7 && h < 9) return { key: 'AM', label: 'MORNING PEAK', peak: true };
    if (h >= 9 && h < 16) return { key: 'OP', label: 'MORNING OFF PEAK', peak: false };
    if (h >= 16 && h < 18) return { key: 'PM', label: 'EVENING PEAK', peak: true };
    return { key: 'EV', label: 'EVENING OFF PEAK', peak: false };
  }

  function isPeakTrafficHour(hour) {
    return getTrafficBucket(hour).peak;
  }

  function setHourlyVcrLosCell(td, value) {
    if (!td) return;
    td.textContent = fmtVcrLos(value);
    td.style.fontWeight = '700';
    if (Number.isFinite(value)) {
      td.style.background = vcrColor(value);
      td.style.color = '#1c1c1c';
    } else {
      td.style.background = '#f4f3f0';
      td.style.color = '#666';
    }
  }

  function tableToText(table){
    if (!table) return '';
    const rows = table.querySelectorAll('tr');
    const lines = [];

    rows.forEach(row => {
      const cells = row.querySelectorAll('th, td');
      const values = Array.from(cells).map(cell =>
        (cell.textContent || '').replace(/\s+/g, ' ').trim()
      );
      lines.push(values.join('\t'));
    });

    return lines.join('\n');
  }

  function tableToHtml(table){
    if (!table) return '';
    return table.outerHTML;
  }

  async function copyTableById(tableId, button){
    const table = document.getElementById(tableId);
    if (!table) return;

    const text = tableToText(table);
    const html = tableToHtml(table);
    if (!text && !html) return;

    const original = button ? button.textContent : '';
    try {
      if (navigator.clipboard && window.ClipboardItem && html) {
        const data = {
          'text/html': new Blob([html], { type: 'text/html' }),
          'text/plain': new Blob([text || ''], { type: 'text/plain' })
        };
        await navigator.clipboard.write([new ClipboardItem(data)]);
      } else {
        await navigator.clipboard.writeText(text);
      }
      if (button) {
        button.textContent = 'Copied';
        setTimeout(() => { button.textContent = original; }, 1100);
      }
    } catch (_error) {
      if (html && navigator.clipboard && window.ClipboardItem) {
        try {
          await navigator.clipboard.write([new ClipboardItem({
            'text/html': new Blob([html], { type: 'text/html' }),
            'text/plain': new Blob([text || ''], { type: 'text/plain' })
          })]);
        } catch (_innerErr) {
          const ta = document.createElement('textarea');
          ta.value = text;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          document.body.removeChild(ta);
        }
      } else {
        const ta = document.createElement('textarea');
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
      }
      if (button) {
        button.textContent = 'Copied';
        setTimeout(() => { button.textContent = original; }, 1100);
      }
    }
  }

  function setupTableCopyButtons(){
    const tables = document.querySelectorAll('table[id]');
    tables.forEach(table => {
      const tableId = table.id;
      const wrapper = table.closest('.table-wrap');
      const host = wrapper || table.parentElement;
      if (!host) return;

      const existing = host.previousElementSibling;
      if (existing && existing.classList && existing.classList.contains('table-actions')) return;

      const actions = document.createElement('div');
      actions.className = 'table-actions';

      const copyBtn = document.createElement('button');
      copyBtn.type = 'button';
      copyBtn.className = 'copy-table-btn';
      copyBtn.textContent = 'Copy Table';
      copyBtn.addEventListener('click', () => copyTableById(tableId, copyBtn));

      actions.appendChild(copyBtn);
      if (tableId === 'vcrGroupedTableD1' || tableId === 'vcrGroupedTableD2') {
        const existingGroup = actions.querySelector('.vcr-toggle-group');
        if (!existingGroup) {
          const toggleGroup = document.createElement('div');
          toggleGroup.className = 'vcr-toggle-group';
          toggleGroup.style.cssText = 'display: inline-flex; gap: 6px; align-items: center; margin-left: 8px;';

          const tableBtn = document.createElement('button');
          tableBtn.type = 'button';
          tableBtn.className = 'vcr-toggle-btn';
          tableBtn.dataset.view = 'table';
          tableBtn.textContent = 'Table';
          tableBtn.style.cssText = 'padding: 6px 10px; border-radius: 4px; border: 1px solid #c7d4db; background: #e3f2fd; color: #0d47a1; cursor: pointer; font-weight: 600;';
          tableBtn.addEventListener('click', () => setVcrView('table'));

          const chartBtn = document.createElement('button');
          chartBtn.type = 'button';
          chartBtn.className = 'vcr-toggle-btn';
          chartBtn.dataset.view = 'chart';
          chartBtn.textContent = 'Chart';
          chartBtn.style.cssText = 'padding: 6px 10px; border-radius: 4px; border: 1px solid #c7d4db; background: #f5f5f5; color: #37474f; cursor: pointer; font-weight: 600;';
          chartBtn.addEventListener('click', () => setVcrView('chart'));

          toggleGroup.appendChild(tableBtn);
          toggleGroup.appendChild(chartBtn);
          actions.appendChild(toggleGroup);
        }
      }
      if (tableId === 'queueGroupedTableD1' || tableId === 'queueGroupedTableD2') {
        const existingQueueGroup = actions.querySelector('.queue-toggle-group');
        if (!existingQueueGroup) {
          const queueToggleGroup = document.createElement('div');
          queueToggleGroup.className = 'queue-toggle-group';
          queueToggleGroup.style.cssText = 'display: inline-flex; gap: 6px; align-items: center; margin-left: 8px;';

          const queueTableBtn = document.createElement('button');
          queueTableBtn.type = 'button';
          queueTableBtn.className = 'queue-toggle-btn';
          queueTableBtn.dataset.view = 'table';
          queueTableBtn.textContent = 'Table';
          queueTableBtn.style.cssText = 'padding: 6px 10px; border-radius: 4px; border: 1px solid #c7d4db; background: #e3f2fd; color: #0d47a1; cursor: pointer; font-weight: 600;';
          queueTableBtn.addEventListener('click', () => setQueueView('table'));

          const queueChartBtn = document.createElement('button');
          queueChartBtn.type = 'button';
          queueChartBtn.className = 'queue-toggle-btn';
          queueChartBtn.dataset.view = 'chart';
          queueChartBtn.textContent = 'Chart';
          queueChartBtn.style.cssText = 'padding: 6px 10px; border-radius: 4px; border: 1px solid #c7d4db; background: #f5f5f5; color: #37474f; cursor: pointer; font-weight: 600;';
          queueChartBtn.addEventListener('click', () => setQueueView('chart'));

          queueToggleGroup.appendChild(queueTableBtn);
          queueToggleGroup.appendChild(queueChartBtn);
          actions.appendChild(queueToggleGroup);
        }
      }
      if (tableId === 'hourlyQueueTable') {
        const existingHourlyQueueGroup = actions.querySelector('.hourly-queue-toggle-group');
        if (!existingHourlyQueueGroup) {
          const hourlyQueueToggleGroup = document.createElement('div');
          hourlyQueueToggleGroup.className = 'hourly-queue-toggle-group';
          hourlyQueueToggleGroup.style.cssText = 'display: inline-flex; gap: 6px; align-items: center; margin-left: 8px;';

          const hourlyQueueTableBtn = document.createElement('button');
          hourlyQueueTableBtn.type = 'button';
          hourlyQueueTableBtn.className = 'hourly-queue-toggle-btn';
          hourlyQueueTableBtn.dataset.view = 'table';
          hourlyQueueTableBtn.textContent = 'Table';
          hourlyQueueTableBtn.style.cssText = 'padding: 6px 10px; border-radius: 4px; border: 1px solid #c7d4db; background: #e3f2fd; color: #0d47a1; cursor: pointer; font-weight: 600;';
          hourlyQueueTableBtn.addEventListener('click', () => setHourlyQueueView('table'));

          const hourlyQueueChartBtn = document.createElement('button');
          hourlyQueueChartBtn.type = 'button';
          hourlyQueueChartBtn.className = 'hourly-queue-toggle-btn';
          hourlyQueueChartBtn.dataset.view = 'chart';
          hourlyQueueChartBtn.textContent = 'Chart';
          hourlyQueueChartBtn.style.cssText = 'padding: 6px 10px; border-radius: 4px; border: 1px solid #c7d4db; background: #f5f5f5; color: #37474f; cursor: pointer; font-weight: 600;';
          hourlyQueueChartBtn.addEventListener('click', () => setHourlyQueueView('chart'));

          hourlyQueueToggleGroup.appendChild(hourlyQueueTableBtn);
          hourlyQueueToggleGroup.appendChild(hourlyQueueChartBtn);
          actions.appendChild(hourlyQueueToggleGroup);
        }
      }
      if (tableId === 'hourlyVcrTable') {
        const existingHourlyVcrGroup = actions.querySelector('.hourly-vcr-toggle-group');
        if (!existingHourlyVcrGroup) {
          const hourlyVcrToggleGroup = document.createElement('div');
          hourlyVcrToggleGroup.className = 'hourly-vcr-toggle-group';
          hourlyVcrToggleGroup.style.cssText = 'display: inline-flex; gap: 6px; align-items: center; margin-left: 8px;';

          const hourlyVcrTableBtn = document.createElement('button');
          hourlyVcrTableBtn.type = 'button';
          hourlyVcrTableBtn.className = 'hourly-vcr-toggle-btn';
          hourlyVcrTableBtn.dataset.view = 'table';
          hourlyVcrTableBtn.textContent = 'Table';
          hourlyVcrTableBtn.style.cssText = 'padding: 6px 10px; border-radius: 4px; border: 1px solid #c7d4db; background: #e3f2fd; color: #0d47a1; cursor: pointer; font-weight: 600;';
          hourlyVcrTableBtn.addEventListener('click', () => setHourlyVcrView('table'));

          const hourlyVcrChartBtn = document.createElement('button');
          hourlyVcrChartBtn.type = 'button';
          hourlyVcrChartBtn.className = 'hourly-vcr-toggle-btn';
          hourlyVcrChartBtn.dataset.view = 'chart';
          hourlyVcrChartBtn.textContent = 'Chart';
          hourlyVcrChartBtn.style.cssText = 'padding: 6px 10px; border-radius: 4px; border: 1px solid #c7d4db; background: #f5f5f5; color: #37474f; cursor: pointer; font-weight: 600;';
          hourlyVcrChartBtn.addEventListener('click', () => setHourlyVcrView('chart'));

          hourlyVcrToggleGroup.appendChild(hourlyVcrTableBtn);
          hourlyVcrToggleGroup.appendChild(hourlyVcrChartBtn);
          actions.appendChild(hourlyVcrToggleGroup);
        }
      }
      host.parentNode.insertBefore(actions, host);
    });
  }

  function setupOptionalFeaturePrintToggles() {
    const toggleButtons = Array.from(document.querySelectorAll('.print-toggle-btn[data-target-card]'));
    if (!toggleButtons.length) return;

    const setState = (cardEl, buttonEl, includeInPrint) => {
      if (!cardEl || !buttonEl) return;
      setPrintInclusion(cardEl, includeInPrint);
      buttonEl.classList.toggle('is-off', !includeInPrint);
      buttonEl.setAttribute('aria-pressed', includeInPrint ? 'true' : 'false');
      buttonEl.textContent = `Include in Print: ${includeInPrint ? 'Yes' : 'No'}`;
    };

    toggleButtons.forEach((btn) => {
      const targetId = String(btn.dataset.targetCard || '').trim();
      if (!targetId) return;
      const card = document.getElementById(targetId);
      if (!card) return;

      const initialInclude = !card.classList.contains('exclude-from-print');
      setState(card, btn, initialInclude);

      btn.addEventListener('click', () => {
        const currentlyIncluded = !card.classList.contains('exclude-from-print');
        setState(card, btn, !currentlyIncluded);
      });
    });
  }

  function setupInlineSectionPrintBadges() {
    const skipCardIds = new Set(['printCustomizationCard', 'selfDiagnosticsCard', 'optionalFeaturesSection']);
    const cards = Array.from(document.querySelectorAll('.container .card'));
    cards.forEach((card, idx) => {
      if (!(card instanceof HTMLElement)) return;
      if (skipCardIds.has(card.id)) return;

      if (!card.id) {
        card.id = `printSectionCard${idx + 1}`;
      }

      const targetId = card.id;
      if (!targetId) return;

      const existingStandardToggles = document.querySelectorAll(`.print-toggle-btn[data-target-card="${targetId}"]`);
      if (existingStandardToggles.length > 0) return;

      let badgeBtn = card.querySelector(':scope > .section-print-toggle.print-toggle-btn');
      let toggleRow = card.querySelector(':scope > .section-print-toggle-row');

      const headingEl = card.querySelector(':scope > h2, :scope > summary');
      if (!toggleRow) {
        toggleRow = document.createElement('div');
        toggleRow.className = 'section-print-toggle-row';
      }

      if (!badgeBtn) {
        badgeBtn = document.createElement('button');
        badgeBtn.type = 'button';
        badgeBtn.className = 'print-toggle-btn section-print-toggle';
        badgeBtn.dataset.targetCard = targetId;
        badgeBtn.textContent = 'Include in Print: Yes';
      }

      if (!toggleRow.contains(badgeBtn)) {
        toggleRow.appendChild(badgeBtn);
      }

      if (headingEl && headingEl.parentNode === card) {
        if (headingEl.nextSibling !== toggleRow) {
          card.insertBefore(toggleRow, headingEl.nextSibling);
        }
      } else if (!card.contains(toggleRow)) {
        card.insertBefore(toggleRow, card.firstChild);
      }

      const applyState = (includeInPrint) => {
        badgeBtn.classList.toggle('is-off', !includeInPrint);
        badgeBtn.setAttribute('aria-pressed', includeInPrint ? 'true' : 'false');
        badgeBtn.textContent = `Include in Print: ${includeInPrint ? 'Yes' : 'No'}`;
        badgeBtn.title = includeInPrint ? 'Included in print (click to exclude)' : 'Excluded from print (click to include)';
      };

      applyState(!card.classList.contains('exclude-from-print'));

      badgeBtn.onclick = () => {
        const includeNow = card.classList.contains('exclude-from-print');
        setPrintInclusion(card, includeNow);
      };
    });
  }

  function setPrintInclusion(targetEl, includeInPrint) {
    if (!targetEl) return;
    targetEl.classList.toggle('exclude-from-print', !includeInPrint);

    const cardId = targetEl.id;
    if (cardId) {
      const linkedButtons = document.querySelectorAll(`[data-target-card="${cardId}"]`);
      linkedButtons.forEach((btn) => {
        if (!(btn instanceof HTMLElement)) return;
        btn.classList.toggle('is-off', !includeInPrint);
        btn.setAttribute('aria-pressed', includeInPrint ? 'true' : 'false');

        if (btn.classList.contains('print-toggle-btn')) {
          btn.textContent = `Include in Print: ${includeInPrint ? 'Yes' : 'No'}`;
        }
      });
    }
  }

  let printCustomizationEntries = [];

  function buildPrintToggleRow(listEl, label, targetEl, scope, initialInclude = true) {
    if (!listEl || !targetEl) return;
    const row = document.createElement('div');
    row.className = 'print-custom-row';

    const name = document.createElement('div');
    name.className = 'print-custom-name';
    name.textContent = label;

    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'print-mini-toggle';

    const applyState = (include) => {
      setPrintInclusion(targetEl, include);
      btn.classList.toggle('is-off', !include);
      btn.setAttribute('aria-pressed', include ? 'true' : 'false');
      btn.textContent = include ? 'Yes' : 'No';
    };

    btn.addEventListener('click', () => {
      const includeNow = targetEl.classList.contains('exclude-from-print');
      applyState(includeNow);
    });

    applyState(initialInclude);
    printCustomizationEntries.push({ scope, applyState });
    row.appendChild(name);
    row.appendChild(btn);
    listEl.appendChild(row);
  }

  function setPrintCustomizationScope(scope, include) {
    const normalized = String(scope || 'all').toLowerCase();
    printCustomizationEntries.forEach((entry) => {
      if (!entry || typeof entry.applyState !== 'function') return;
      if (normalized !== 'all' && entry.scope !== normalized) return;
      entry.applyState(include);
    });
  }

  function setupGlobalPrintCustomization() {
    const cardList = document.getElementById('printCardToggleList');
    const tableList = document.getElementById('printTableToggleList');
    if (!cardList || !tableList) return;

    cardList.innerHTML = '';
    tableList.innerHTML = '';
    printCustomizationEntries = [];

    const skipCardIds = new Set(['printCustomizationCard', 'selfDiagnosticsCard']);
    const cards = Array.from(document.querySelectorAll('.container .card'));
    cards.forEach((card, idx) => {
      if (!(card instanceof HTMLElement)) return;
      if (skipCardIds.has(card.id)) return;
      if (card.closest('#printCustomizationCard')) return;
      const titleEl = card.querySelector('h2, summary');
      const title = titleEl ? titleEl.textContent.trim().replace(/\s+/g, ' ') : `Section ${idx + 1}`;
      const initialInclude = !card.classList.contains('exclude-from-print');
      buildPrintToggleRow(cardList, title || `Section ${idx + 1}`, card, 'cards', initialInclude);
    });

    const tables = Array.from(document.querySelectorAll('.container table'));
    const seenTableTargets = new Set();
    tables.forEach((table, idx) => {
      if (!(table instanceof HTMLTableElement)) return;
      if (table.id === 'diagTable') return;

      const target = table.closest('.table-wrap') || table;
      if (!target) return;
      if (!(target instanceof HTMLElement)) return;

      const targetKey = target.id
        ? `id:${target.id}`
        : `node:${target.tagName.toLowerCase()}-${idx}`;
      if (seenTableTargets.has(targetKey)) return;
      seenTableTargets.add(targetKey);

      const heading = target.closest('.card, details.card')?.querySelector('h2, summary');
      const headingText = heading ? heading.textContent.trim().replace(/\s+/g, ' ') : 'Report';
      const tableName = table.id ? table.id : `table-${idx + 1}`;
      const label = `${headingText} ‚Ä¢ ${tableName}`;
      const initialInclude = !target.classList.contains('exclude-from-print');
      buildPrintToggleRow(tableList, label, target, 'tables', initialInclude);
    });

    const bindBulkBtn = (id, scope, include) => {
      const btn = document.getElementById(id);
      if (!btn) return;
      btn.onclick = () => setPrintCustomizationScope(scope, include);
    };

    bindBulkBtn('printSelectAllBtn', 'all', true);
    bindBulkBtn('printDeselectAllBtn', 'all', false);
    bindBulkBtn('printSelectCardsBtn', 'cards', true);
    bindBulkBtn('printDeselectCardsBtn', 'cards', false);
    bindBulkBtn('printSelectTablesBtn', 'tables', true);
    bindBulkBtn('printDeselectTablesBtn', 'tables', false);
  }

  function runSelfDiagnostics() {
    const checks = [];
    const pushCheck = (name, ok, details) => checks.push({ name, ok: !!ok, details: String(details || '') });

    const periodShapeOk = Array.isArray(periods)
      && periods.length === 4
      && periods[0].key === 'AM' && String(periods[0].hours) === '7,8'
      && periods[1].key === 'OP' && String(periods[1].hours) === '9,10,11,12,13,14,15'
      && periods[2].key === 'PM' && String(periods[2].hours) === '16,17'
      && periods[3].key === 'EV' && String(periods[3].hours) === '18,19,20,21,22,23,0,1,2,3,4,5,6';
    pushCheck('AM/OP/PM/EV definitions', periodShapeOk, periodShapeOk ? 'Bucket hours match configured standard.' : 'Bucket hours are not aligned to expected standard.');

    const bucketSamplesOk = getTrafficBucket(7).key === 'AM'
      && getTrafficBucket(8).key === 'AM'
      && getTrafficBucket(9).key === 'OP'
      && getTrafficBucket(15).key === 'OP'
      && getTrafficBucket(16).key === 'PM'
      && getTrafficBucket(17).key === 'PM'
      && getTrafficBucket(18).key === 'EV'
      && getTrafficBucket(3).key === 'EV';
    pushCheck('Bucket classifier boundaries', bucketSamplesOk, bucketSamplesOk ? 'Boundary hours classify correctly.' : 'One or more bucket boundaries classify incorrectly.');

    const growthCtx = getCurrentGrowthProjectionContext();
    const baseVadt = Number(num('VADT')) || 0;
    const projectedVadt = Math.round(baseVadt * growthCtx.growthFactor);
    const predictedInput = Number(document.getElementById('predictedVADT') ? document.getElementById('predictedVADT').value : NaN);
    const growthOk = !Number.isFinite(predictedInput) || Math.abs(predictedInput - projectedVadt) <= 1;
    pushCheck('Growth projection consistency', growthOk, `Computed=${projectedVadt.toLocaleString()} / Field=${Number.isFinite(predictedInput) ? predictedInput.toLocaleString() : 'N/A'}`);

    const dv = calculateDV();
    const dvOk = Number.isFinite(dv) && dv >= 500;
    pushCheck('Design Volume floor check', dvOk, dvOk ? `DV=${Math.round(dv).toLocaleString()} (>=500)` : `Invalid DV=${dv}`);

    const monotonicQueue = (q) => q && q.q2 <= q.q5 && q.q5 <= q.q10 && q.q10 <= q.q15;
    let queueProfileOk = true;
    if (lastD1Profile && lastD2Profile) {
      ['AM','OP','PM','EV'].forEach(k => {
        if (!monotonicQueue(lastD1Profile[k] && lastD1Profile[k].queue)) queueProfileOk = false;
        if (!monotonicQueue(lastD2Profile[k] && lastD2Profile[k].queue)) queueProfileOk = false;
      });
    }
    pushCheck('Queue monotonic durations', queueProfileOk, queueProfileOk ? 'q2 ‚â§ q5 ‚â§ q10 ‚â§ q15 for all checked periods.' : 'Detected non-monotonic queue durations in one or more periods.');

    let compositionOk = true;
    if (lastD1Profile && lastD2Profile) {
      ['AM','OP','PM','EV'].forEach(k => {
        const p1 = lastD1Profile[k];
        const p2 = lastD2Profile[k];
        if (p1 && Math.round(p1.lv + p1.hv + p1.rt) !== Math.round(p1.total)) compositionOk = false;
        if (p2 && Math.round(p2.lv + p2.hv + p2.rt) !== Math.round(p2.total)) compositionOk = false;
      });
    }
    pushCheck('Volume composition check', compositionOk, compositionOk ? 'LV + HV + RT equals total for checked periods.' : 'Composition mismatch found (LV + HV + RT != total).');

    const diagBody = document.getElementById('diagBody');
    const summary = document.getElementById('diagSummaryText');
    if (diagBody) {
      diagBody.innerHTML = checks.map(item => `
        <tr>
          <td class="rowhead">${item.name}</td>
          <td class="${item.ok ? 'diag-pass' : 'diag-fail'}">${item.ok ? 'PASS' : 'FAIL'}</td>
          <td>${item.details}</td>
        </tr>
      `).join('');
    }
    if (summary) {
      const failed = checks.filter(c => !c.ok).length;
      summary.textContent = failed === 0
        ? 'Diagnostics complete: all checks passed.'
        : `Diagnostics complete: ${failed} check(s) failed.`;
      summary.className = failed === 0 ? 'diag-summary diag-pass' : 'diag-summary diag-fail';
    }
  }

  function setupDiagnosticsPanel() {
    const panel = document.getElementById('selfDiagnosticsCard');
    if (!panel) return;

    const showByQuery = new URLSearchParams(window.location.search).get('debug') === '1';
    if (showByQuery) panel.style.display = 'block';

    document.addEventListener('keydown', (event) => {
      if (event.ctrlKey && event.shiftKey && String(event.key || '').toLowerCase() === 'd') {
        panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
      }
    });

    const runBtn = document.getElementById('runDiagnosticsBtn');
    if (runBtn) runBtn.addEventListener('click', runSelfDiagnostics);
  }

  function maxValid(values){
    const nums = values.filter(v => Number.isFinite(v) && v >= 0);
    return nums.length ? Math.max(...nums) : null;
  }

  function updateSummaryKpis({ dv, d1, d2, rtr, slrfPeak, worstVcr }){
    const set = (id, value) => {
      const el = document.getElementById(id);
      if (el) el.textContent = value;
      return el;
    };

    set('kpiDV', `${dv}`);
    set('kpiD1PeakQueue', `${d1.q2qp} m`);
    set('kpiD2PeakQueue', `${d2.q2qp} m`);
    set('kpiRoadTrain', rtr === 'YES' ? 'Active' : 'Inactive');

    const slrfText = (slrfPeak === null || Number.isNaN(slrfPeak) || slrfPeak < 0) ? 'N/A' : slrfPeak.toFixed(3);
    const slrfEl = set('kpiSlrfPeak', slrfText);
    const worstText = (worstVcr === null || Number.isNaN(worstVcr) || worstVcr < 0) ? 'N/A' : worstVcr.toFixed(3);
    const worstEl = set('kpiWorstVcr', worstText);

    if (worstEl) {
      worstEl.style.background = vcrColor(worstVcr);
      worstEl.style.color = '#1c1c1c';
      worstEl.style.borderRadius = '6px';
      worstEl.style.padding = '2px 6px';
      worstEl.style.display = 'inline-block';
    }
    if (slrfEl) {
      slrfEl.style.background = vcrColor(slrfPeak);
      slrfEl.style.color = '#1c1c1c';
      slrfEl.style.borderRadius = '6px';
      slrfEl.style.padding = '2px 6px';
      slrfEl.style.display = 'inline-block';
    }
  }

  function calculateAll(){
    syncVisibility();
    syncDirectionalRtFromOverall();
    ['RTR','DTCA','DHVPA','DRTPA'].forEach(applyYesNoColor);
    updateAssumptionsPanel();

    const d1 = calcDirection(1);
    const d2 = calcDirection(2);
    const dv = calculateDV();
    
    // Get direction labels from selected site
    const d1Label = (selectedMacroSite && macroSitesData[selectedMacroSite])
      ? macroSitesData[selectedMacroSite].d1_direction_label
      : (customDirectionContext && customDirectionContext.d1Label ? customDirectionContext.d1Label : 'Direction 1 (D1)');
    const d2Label = (selectedMacroSite && macroSitesData[selectedMacroSite])
      ? macroSitesData[selectedMacroSite].d2_direction_label
      : (customDirectionContext && customDirectionContext.d2Label ? customDirectionContext.d2Label : 'Direction 2 (D2)');
    const dtca = txt('DTCA').toUpperCase();
    const dhvpa = txt('DHVPA').toUpperCase();
    const drtpa = txt('DRTPA').toUpperCase();
    const rtr = txt('RTR').toUpperCase();

    const d1Daily = dtca === 'YES' ? num('D1_VADT') : num('VADT') / 2;
    const d2Daily = dtca === 'YES' ? num('D2_VADT') : num('VADT') / 2;
    const growthProjectionContext = getCurrentGrowthProjectionContext();
    const growthRatePct = growthProjectionContext.growthRatePct;
    const effectiveYears = growthProjectionContext.effectiveYears;
    const growthFactor = growthProjectionContext.growthFactor;

    const projectedTotal = Math.round((num('VADT') || 0) * growthFactor);
    const projectedD1 = Math.round((num('D1_VADT') || 0) * growthFactor);
    const projectedD2 = Math.round((num('D2_VADT') || 0) * growthFactor);

    const predictedVadtInput = document.getElementById('predictedVADT');
    const predictedD1Input = document.getElementById('predictedD1VADT');
    const predictedD2Input = document.getElementById('predictedD2VADT');
    if (predictedVadtInput) predictedVadtInput.value = Number.isFinite(projectedTotal) ? projectedTotal : '';
    if (predictedD1Input) predictedD1Input.value = Number.isFinite(projectedD1) ? projectedD1 : '';
    if (predictedD2Input) predictedD2Input.value = Number.isFinite(projectedD2) ? projectedD2 : '';
    rerenderMacroChartsWithCurrentGrowth();

    const predictedD1LabelEl = document.getElementById('predictedD1Label');
    const predictedD2LabelEl = document.getElementById('predictedD2Label');
    if (predictedD1LabelEl) predictedD1LabelEl.textContent = formatDirectionalVadtLabel('D1', d1Label, 'Predicted ').replace(':', ' @ Opening Year');
    if (predictedD2LabelEl) predictedD2LabelEl.textContent = formatDirectionalVadtLabel('D2', d2Label, 'Predicted ').replace(':', ' @ Opening Year');

    const d1HvPct = getHVPercent(1);
    const d2HvPct = getHVPercent(2);
    const d1RtPct = getRTPercent(1);
    const d2RtPct = getRTPercent(2);
    const d1Profile = buildPeriodProfile(1, d1Daily, d1HvPct, d1RtPct, d1.lanes, rtr === 'YES');
    const d2Profile = buildPeriodProfile(2, d2Daily, d2HvPct, d2RtPct, d2.lanes, rtr === 'YES');
    const d1HourlyProfile = buildHourlyDirectionProfile(1, d1Daily, d1HvPct, d1RtPct, d1.lanes, rtr === 'YES');
    const d2HourlyProfile = buildHourlyDirectionProfile(2, d2Daily, d2HvPct, d2RtPct, d2.lanes, rtr === 'YES');
    // persist for other routines
    lastD1Profile = d1Profile;
    lastD2Profile = d2Profile;

    const base1Peak = (d1.peakLVPL + d1.peakHVPL + d1.peakRTPL) / dv;
    const base1Off  = (d1.offLVPL + d1.offHVPL + d1.offRTPL) / dv;
    const base2Peak = (d2.peakLVPL + d2.peakHVPL + d2.peakRTPL) / dv;
    const base2Off  = (d2.offLVPL + d2.offHVPL + d2.offRTPL) / dv;

    let slc1Peak = null, slc1Off = null, slc2Peak = null, slc2Off = null;
    if (d1.lanes === 2) {
      slc1Peak = ((d1.peakLVPL + d1.peakHVPL + d1.peakRTPL) * 2) / dv;
      slc1Off = ((d1.offLVPL + d1.offHVPL + d1.offRTPL) * 2) / dv;
    } else if (d1.lanes > 2) {
      slc1Peak = (((d1.peakLVPL + d1.peakHVPL + d1.peakRTPL) * d1.lanes) / (d1.lanes - 1)) / dv;
      slc1Off = (((d1.offLVPL + d1.offHVPL + d1.offRTPL) * d1.lanes) / (d1.lanes - 1)) / dv;
    }

    if (d2.lanes === 2) {
      slc2Peak = ((d2.peakLVPL + d2.peakHVPL + d2.peakRTPL) * 2) / dv;
      slc2Off = ((d2.offLVPL + d2.offHVPL + d2.offRTPL) * 2) / dv;
    } else if (d2.lanes > 2) {
      slc2Peak = (((d2.peakLVPL + d2.peakHVPL + d2.peakRTPL) * d2.lanes) / (d2.lanes - 1)) / dv;
      slc2Off = (((d2.offLVPL + d2.offHVPL + d2.offRTPL) * d2.lanes) / (d2.lanes - 1)) / dv;
    }

    let slrfPeak = null, slrfOff = null;
    if (d1.lanes === 1 && d2.lanes === 1) {
      slrfPeak = (d1.peakLVPL + d1.peakHVPL + d1.peakRTPL + d2.peakLVPL + d2.peakHVPL + d2.peakRTPL) / dv;
      slrfOff = (d1.offLVPL + d1.offHVPL + d1.offRTPL + d2.offLVPL + d2.offHVPL + d2.offRTPL) / dv;
    }

    // Update section headers with intelligent direction labels
    const setHeader = (id, emoji, label) => {
      const el = document.getElementById(id);
      if (el) el.innerHTML = `${emoji} ${label}`;
    };
    
    setHeader('groupedHeaderD2', 'üî¥', d2Label);
    setHeader('groupedHeaderD1', 'üü¢', d1Label);
    setHeader('queueHeaderD2', 'üî¥', d2Label);
    setHeader('queueHeaderD1', 'üü¢', d1Label);
    setHeader('queueHeaderD2Chart', 'üî¥', d2Label);
    setHeader('queueHeaderD1Chart', 'üü¢', d1Label);
    setHeader('vcrHeaderD2', 'üî¥', d2Label);
    setHeader('vcrHeaderD1', 'üü¢', d1Label);
    setHeader('vcrHeaderD2Chart', 'üî¥', d2Label);
    setHeader('vcrHeaderD1Chart', 'üü¢', d1Label);
    
    const groupedBodyD2 = document.getElementById('groupedBodyD2');
    if (groupedBodyD2) {
      groupedBodyD2.innerHTML = `
        <tr>
          <td class="rowhead">LV Volume</td>
          <td>${d2Profile.AM.lv.toLocaleString()}</td>
          <td>${d2Profile.OP.lv.toLocaleString()}</td>
          <td>${d2Profile.PM.lv.toLocaleString()}</td>
          <td>${d2Profile.EV.lv.toLocaleString()}</td>
          <td>${Math.round(d2Profile.AM.lv + d2Profile.OP.lv + d2Profile.PM.lv + d2Profile.EV.lv).toLocaleString()}</td>
        </tr>
        <tr>
          <td class="rowhead">HV Volume</td>
          <td>${d2Profile.AM.hv.toLocaleString()}</td>
          <td>${d2Profile.OP.hv.toLocaleString()}</td>
          <td>${d2Profile.PM.hv.toLocaleString()}</td>
          <td>${d2Profile.EV.hv.toLocaleString()}</td>
          <td>${Math.round(d2Profile.AM.hv + d2Profile.OP.hv + d2Profile.PM.hv + d2Profile.EV.hv).toLocaleString()}</td>
        </tr>
        <tr>
          <td class="rowhead">Hrly Avg / lane</td>
          <td>${Math.round(d2Profile.AM.hourlyPerLane).toLocaleString()}</td>
          <td>${Math.round(d2Profile.OP.hourlyPerLane).toLocaleString()}</td>
          <td>${Math.round(d2Profile.PM.hourlyPerLane).toLocaleString()}</td>
          <td>${Math.round(d2Profile.EV.hourlyPerLane).toLocaleString()}</td>
          <td>-</td>
        </tr>
      `;
    }

    const groupedBodyD1 = document.getElementById('groupedBodyD1');
    if (groupedBodyD1) {
      groupedBodyD1.innerHTML = `
        <tr>
          <td class="rowhead">LV Volume</td>
          <td>${d1Profile.AM.lv.toLocaleString()}</td>
          <td>${d1Profile.OP.lv.toLocaleString()}</td>
          <td>${d1Profile.PM.lv.toLocaleString()}</td>
          <td>${d1Profile.EV.lv.toLocaleString()}</td>
          <td>${Math.round(d1Profile.AM.lv + d1Profile.OP.lv + d1Profile.PM.lv + d1Profile.EV.lv).toLocaleString()}</td>
        </tr>
        <tr>
          <td class="rowhead">HV Volume</td>
          <td>${d1Profile.AM.hv.toLocaleString()}</td>
          <td>${d1Profile.OP.hv.toLocaleString()}</td>
          <td>${d1Profile.PM.hv.toLocaleString()}</td>
          <td>${d1Profile.EV.hv.toLocaleString()}</td>
          <td>${Math.round(d1Profile.AM.hv + d1Profile.OP.hv + d1Profile.PM.hv + d1Profile.EV.hv).toLocaleString()}</td>
        </tr>
        <tr>
          <td class="rowhead">Hrly Avg / lane</td>
          <td>${Math.round(d1Profile.AM.hourlyPerLane).toLocaleString()}</td>
          <td>${Math.round(d1Profile.OP.hourlyPerLane).toLocaleString()}</td>
          <td>${Math.round(d1Profile.PM.hourlyPerLane).toLocaleString()}</td>
          <td>${Math.round(d1Profile.EV.hourlyPerLane).toLocaleString()}</td>
          <td>-</td>
        </tr>
      `;
    }

    const queueGroupedBodyD2 = document.getElementById('queueGroupedBodyD2');
    if (queueGroupedBodyD2) {
      const queueRowsD2 = [
        { label: 'Per 2 minutes', values: ['AM','OP','PM','EV'].map(k => d2Profile[k].queue.q2) },
        { label: 'Per 5 minutes', values: ['AM','OP','PM','EV'].map(k => d2Profile[k].queue.q5) },
        { label: 'Per 10 minutes', values: ['AM','OP','PM','EV'].map(k => d2Profile[k].queue.q10) },
        { label: 'Per 15 minutes', values: ['AM','OP','PM','EV'].map(k => d2Profile[k].queue.q15) }
      ];

      queueGroupedBodyD2.innerHTML = queueRowsD2.map(row => {
        const maxQueue = Math.max(...row.values);
        return `
          <tr>
            <td class="rowhead">${row.label} Length (m)</td>
            <td>${Math.round(row.values[0]).toLocaleString()}</td>
            <td>${Math.round(row.values[1]).toLocaleString()}</td>
            <td>${Math.round(row.values[2]).toLocaleString()}</td>
            <td>${Math.round(row.values[3]).toLocaleString()}</td>
            <td><strong>${Math.round(maxQueue).toLocaleString()}</strong></td>
          </tr>
        `;
      }).join('');
    }

    const queueGroupedBodyD1 = document.getElementById('queueGroupedBodyD1');
    if (queueGroupedBodyD1) {
      const queueRowsD1 = [
        { label: 'Per 2 minutes', values: ['AM','OP','PM','EV'].map(k => d1Profile[k].queue.q2) },
        { label: 'Per 5 minutes', values: ['AM','OP','PM','EV'].map(k => d1Profile[k].queue.q5) },
        { label: 'Per 10 minutes', values: ['AM','OP','PM','EV'].map(k => d1Profile[k].queue.q10) },
        { label: 'Per 15 minutes', values: ['AM','OP','PM','EV'].map(k => d1Profile[k].queue.q15) }
      ];

      queueGroupedBodyD1.innerHTML = queueRowsD1.map(row => {
        const maxQueue = Math.max(...row.values);
        return `
          <tr>
            <td class="rowhead">${row.label} Length (m)</td>
            <td>${Math.round(row.values[0]).toLocaleString()}</td>
            <td>${Math.round(row.values[1]).toLocaleString()}</td>
            <td>${Math.round(row.values[2]).toLocaleString()}</td>
            <td>${Math.round(row.values[3]).toLocaleString()}</td>
            <td><strong>${Math.round(maxQueue).toLocaleString()}</strong></td>
          </tr>
        `;
      }).join('');
    }

    const queueKeys = ['AM', 'OP', 'PM', 'EV'];
    const queueSeriesD1 = Object.fromEntries(queueKeys.map(k => [k, {
      q2: d1Profile[k].queue.q2,
      q5: d1Profile[k].queue.q5,
      q10: d1Profile[k].queue.q10,
      q15: d1Profile[k].queue.q15
    }]));
    const queueSeriesD2 = Object.fromEntries(queueKeys.map(k => [k, {
      q2: d2Profile[k].queue.q2,
      q5: d2Profile[k].queue.q5,
      q10: d2Profile[k].queue.q10,
      q15: d2Profile[k].queue.q15
    }]));

    lastQueueChartData = {
      labels: queueKeys,
      d1: queueSeriesD1,
      d2: queueSeriesD2,
      d1Label,
      d2Label
    };
    renderQueueCharts(lastQueueChartData);

    const periodKeys = ['AM','OP','PM','EV'];
    const baseD1 = Object.fromEntries(periodKeys.map(k => [k, d1Profile[k].hourlyPerLane / dv]));
    const baseD2 = Object.fromEntries(periodKeys.map(k => [k, d2Profile[k].hourlyPerLane / dv]));

    const slcFromBase = (baseMap, laneCount) => {
      const out = {};
      periodKeys.forEach(k => {
        if (laneCount === 2) out[k] = baseMap[k] * 2;
        else if (laneCount > 2) out[k] = (baseMap[k] * laneCount) / (laneCount - 1);
        else out[k] = null;
      });
      return out;
    };

    const slcD1 = slcFromBase(baseD1, d1.lanes);
    const slcD2 = slcFromBase(baseD2, d2.lanes);
    const slrf = {};
    periodKeys.forEach(k => {
      if (d1.lanes === 1 && d2.lanes === 1) slrf[k] = (d1Profile[k].hourlyPerLane + d2Profile[k].hourlyPerLane) / dv;
      else slrf[k] = null;
    });

    const vcrGroupedBodyD2 = document.getElementById('vcrGroupedBodyD2');
    if (vcrGroupedBodyD2) {
      const rowsD2 = [
        { label: `Design Volume (Capacity) * = ${Math.round(dv).toLocaleString()}`, values: null },
        { label: 'Base VCR', values: baseD2 },
        { label: 'Single Lane Closure', values: slcD2 },
        { label: 'Single Lane Reversible Flow', values: slrf }
      ];

      vcrGroupedBodyD2.innerHTML = '';
      rowsD2.forEach(row => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td class="rowhead">${row.label}</td>
          <td class="vcr-cell"></td>
          <td class="vcr-cell"></td>
          <td class="vcr-cell"></td>
          <td class="vcr-cell"></td>
        `;
        const cells = tr.querySelectorAll('.vcr-cell');
        if (!row.values) {
          cells.forEach(cell => {
            cell.textContent = '-';
            cell.style.background = '#f4f3f0';
          });
        } else {
          setVcrLosCell(cells[0], row.values.AM);
          setVcrLosCell(cells[1], row.values.OP);
          setVcrLosCell(cells[2], row.values.PM);
          setVcrLosCell(cells[3], row.values.EV);
        }
        vcrGroupedBodyD2.appendChild(tr);
      });
    }

    const vcrGroupedBodyD1 = document.getElementById('vcrGroupedBodyD1');
    if (vcrGroupedBodyD1) {
      const rowsD1 = [
        { label: `Design Volume (Capacity) * = ${Math.round(dv).toLocaleString()}`, values: null },
        { label: 'Base VCR', values: baseD1 },
        { label: 'Single Lane Closure', values: slcD1 },
        { label: 'Single Lane Reversible Flow', values: slrf }
      ];

      vcrGroupedBodyD1.innerHTML = '';
      rowsD1.forEach(row => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td class="rowhead">${row.label}</td>
          <td class="vcr-cell"></td>
          <td class="vcr-cell"></td>
          <td class="vcr-cell"></td>
          <td class="vcr-cell"></td>
        `;
        const cells = tr.querySelectorAll('.vcr-cell');
        if (!row.values) {
          cells.forEach(cell => {
            cell.textContent = '-';
            cell.style.background = '#f4f3f0';
          });
        } else {
          setVcrLosCell(cells[0], row.values.AM);
          setVcrLosCell(cells[1], row.values.OP);
          setVcrLosCell(cells[2], row.values.PM);
          setVcrLosCell(cells[3], row.values.EV);
        }
        vcrGroupedBodyD1.appendChild(tr);
      });
    }

    lastVcrChartData = {
      labels: periodKeys,
      baseD1,
      slcD1,
      slrf,
      baseD2,
      slcD2,
      d1Label,
      d2Label
    };
    renderVcrCharts(lastVcrChartData);

    const hourlyQueueBody = document.getElementById('hourlyQueueBody');
    const hourlyVcrBody = document.getElementById('hourlyVcrBody');
    const hourlyLabels = [];
    const hourlyD1MaxQueue = [];
    const hourlyD2MaxQueue = [];
    const hourlyNetworkMaxQueue = [];
    const hourlyD1WorkVcr = [];
    const hourlyD2WorkVcr = [];
    const hourlyWorstWorkVcr = [];

    let worstQueueHour = null;
    let worstQueueValue = -1;
    let worstVcrHour = null;
    let worstVcrValue = -1;

    if (hourlyQueueBody) {
      hourlyQueueBody.innerHTML = '';
      for (let hour = 0; hour < 24; hour += 1) {
        const d1Hour = d1HourlyProfile[hour] || { queue: { q2: 0, q5: 0, q10: 0, q15: 0 } };
        const d2Hour = d2HourlyProfile[hour] || { queue: { q2: 0, q5: 0, q10: 0, q15: 0 } };
        const d1MaxQueue = Math.max(d1Hour.queue.q2, d1Hour.queue.q5, d1Hour.queue.q10, d1Hour.queue.q15);
        const d2MaxQueue = Math.max(d2Hour.queue.q2, d2Hour.queue.q5, d2Hour.queue.q10, d2Hour.queue.q15);
        const networkMax = Math.max(d1MaxQueue, d2MaxQueue);

        if (networkMax > worstQueueValue) {
          worstQueueValue = networkMax;
          worstQueueHour = hour;
        }

        const hourLabel = `${String(hour).padStart(2, '0')}:00-${String((hour + 1) % 24).padStart(2, '0')}:00`;
        const hourBucket = getTrafficBucket(hour);
        const peakHour = hourBucket.peak;
        const hourTypeText = `${hourBucket.key} - ${hourBucket.label}`;
        hourlyLabels.push(hourLabel);
        hourlyD1MaxQueue.push(Number(d1MaxQueue) || 0);
        hourlyD2MaxQueue.push(Number(d2MaxQueue) || 0);
        hourlyNetworkMaxQueue.push(Number(networkMax) || 0);
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td class="rowhead">${hourLabel}</td>
          <td><strong>${hourTypeText}</strong></td>
          <td>${Math.round(d1MaxQueue).toLocaleString()}</td>
          <td>${Math.round(d2MaxQueue).toLocaleString()}</td>
          <td><strong>${Math.round(networkMax).toLocaleString()}</strong></td>
        `;
        const cells = tr.querySelectorAll('td');
        const hourTypeCell = cells[1];
        if (hourTypeCell) {
          hourTypeCell.style.background = peakHour ? '#ffe0b2' : '#e3f2fd';
          hourTypeCell.style.color = peakHour ? '#e65100' : '#0d47a1';
          hourTypeCell.style.fontWeight = '700';
        }
        const queueCells = [cells[2], cells[3], cells[4]];
        queueCells.forEach(cell => {
          if (!cell) return;
          cell.style.background = peakHour ? '#fff8e1' : '#f5fbff';
        });
        hourlyQueueBody.appendChild(tr);
      }
    }

    if (hourlyVcrBody) {
      hourlyVcrBody.innerHTML = '';
      for (let hour = 0; hour < 24; hour += 1) {
        const d1PerLane = (d1HourlyProfile[hour] && Number(d1HourlyProfile[hour].perLane)) || 0;
        const d2PerLane = (d2HourlyProfile[hour] && Number(d2HourlyProfile[hour].perLane)) || 0;

        const d1BaseVcr = dv > 0 ? (d1PerLane / dv) : null;
        const d2BaseVcr = dv > 0 ? (d2PerLane / dv) : null;

        let d1WorkVcr = null;
        let d2WorkVcr = null;

        if (d1.lanes === 2) d1WorkVcr = d1BaseVcr * 2;
        else if (d1.lanes > 2) d1WorkVcr = (d1BaseVcr * d1.lanes) / (d1.lanes - 1);

        if (d2.lanes === 2) d2WorkVcr = d2BaseVcr * 2;
        else if (d2.lanes > 2) d2WorkVcr = (d2BaseVcr * d2.lanes) / (d2.lanes - 1);

        if (d1.lanes === 1 && d2.lanes === 1) {
          const slrfHourly = dv > 0 ? ((d1PerLane + d2PerLane) / dv) : null;
          d1WorkVcr = slrfHourly;
          d2WorkVcr = slrfHourly;
        }

        const rowValues = [d1BaseVcr, d1WorkVcr, d2BaseVcr, d2WorkVcr].filter(v => Number.isFinite(v));
        const rowWorst = rowValues.length ? Math.max(...rowValues) : null;

        if (Number.isFinite(rowWorst) && Number(rowWorst) > worstVcrValue) {
          worstVcrValue = rowWorst;
          worstVcrHour = hour;
        }

        const hourLabel = `${String(hour).padStart(2, '0')}:00-${String((hour + 1) % 24).padStart(2, '0')}:00`;
        hourlyD1WorkVcr.push(Number.isFinite(d1WorkVcr) ? Number(d1WorkVcr) : null);
        hourlyD2WorkVcr.push(Number.isFinite(d2WorkVcr) ? Number(d2WorkVcr) : null);
        hourlyWorstWorkVcr.push(Number.isFinite(rowWorst) ? Number(rowWorst) : null);
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td class="rowhead">${hourLabel}</td>
          <td class="hourly-vcr-cell"></td>
          <td class="hourly-vcr-cell"></td>
          <td class="hourly-vcr-cell"></td>
          <td class="hourly-vcr-cell"></td>
          <td class="hourly-vcr-cell"></td>
        `;
        const vcrCells = tr.querySelectorAll('.hourly-vcr-cell');
        setHourlyVcrLosCell(vcrCells[0], d1BaseVcr);
        setHourlyVcrLosCell(vcrCells[1], d1WorkVcr);
        setHourlyVcrLosCell(vcrCells[2], d2BaseVcr);
        setHourlyVcrLosCell(vcrCells[3], d2WorkVcr);
        setHourlyVcrLosCell(vcrCells[4], rowWorst);
        hourlyVcrBody.appendChild(tr);
      }
    }

    lastHourlyQueueChartData = {
      labels: hourlyLabels,
      d1Max: hourlyD1MaxQueue,
      d2Max: hourlyD2MaxQueue,
      networkMax: hourlyNetworkMaxQueue
    };
    renderHourlyQueueChart(lastHourlyQueueChartData);

    lastHourlyVcrChartData = {
      labels: hourlyLabels,
      d1Work: hourlyD1WorkVcr,
      d2Work: hourlyD2WorkVcr,
      worst: hourlyWorstWorkVcr
    };
    renderHourlyVcrChart(lastHourlyVcrChartData);

    const periodName = {
      AM: 'AM',
      OP: 'OP',
      PM: 'PM',
      EV: 'EV'
    };

    const queueRiskBadge = document.getElementById('queueRiskBadge');
    if (queueRiskBadge) {
      let worstPeriodKey = null;
      let worstPeriodQueue = -1;
      ['AM', 'OP', 'PM', 'EV'].forEach(period => {
        const values = [
          d1Profile[period].queue.q2, d1Profile[period].queue.q5, d1Profile[period].queue.q10, d1Profile[period].queue.q15,
          d2Profile[period].queue.q2, d2Profile[period].queue.q5, d2Profile[period].queue.q10, d2Profile[period].queue.q15
        ].map(v => Number(v) || 0);
        const periodMax = Math.max(...values);
        if (periodMax > worstPeriodQueue) {
          worstPeriodQueue = periodMax;
          worstPeriodKey = period;
        }
      });

      if (worstPeriodKey !== null) {
        queueRiskBadge.textContent = `High Risk Period: ${periodName[worstPeriodKey]} ‚Ä¢ Network Max Queue ‚âà ${Math.round(worstPeriodQueue).toLocaleString()} m`;
        queueRiskBadge.style.display = 'block';
      } else {
        queueRiskBadge.style.display = 'none';
      }
    }

    const vcrRiskBadge = document.getElementById('vcrRiskBadge');
    if (vcrRiskBadge) {
      let worstPeriodKey = null;
      let worstPeriodVcr = -1;
      ['AM', 'OP', 'PM', 'EV'].forEach(period => {
        const values = [baseD1[period], baseD2[period], slcD1[period], slcD2[period], slrf[period]]
          .filter(v => Number.isFinite(v));
        const periodMax = values.length ? Math.max(...values) : -1;
        if (periodMax > worstPeriodVcr) {
          worstPeriodVcr = periodMax;
          worstPeriodKey = period;
        }
      });

      if (worstPeriodKey !== null && Number.isFinite(worstPeriodVcr) && worstPeriodVcr >= 0) {
        vcrRiskBadge.textContent = `High Risk Period: ${periodName[worstPeriodKey]} ‚Ä¢ Worst VCR = ${worstPeriodVcr.toFixed(3)} (${losLabel(worstPeriodVcr)})`;
        vcrRiskBadge.style.display = 'block';
      } else {
        vcrRiskBadge.style.display = 'none';
      }
    }

    const worstVcr = maxValid([
      base1Peak, base1Off, base2Peak, base2Off,
      slc1Peak, slc1Off, slc2Peak, slc2Off,
      slrfPeak, slrfOff
    ]);

    updateSummaryKpis({ dv, d1, d2, rtr, slrfPeak, worstVcr });

    const traceRows = [
      ['DTCA Path', dtca === 'YES' ? 'Directional VADT (D1_VADT / D2_VADT)' : '50/50 split from VADT'],
      ['Growth Application', `Projected VADT = ${num('VADT').toLocaleString()} √ó (1 + ${numberRoundUp(growthRatePct, 3)}% )^${effectiveYears} = ${projectedTotal.toLocaleString()}`],
      ['DHVPA Path', dhvpa === 'YES' ? 'Directional HV% (D1_HVP / D2_HVP)' : 'HVP/2 applied per direction'],
      ['DRTPA Path', drtpa === 'YES' ? 'Directional RT% (D1_RTP / D2_RTP)' : 'RTP/2 applied per direction'],
      ['RTR Queue Rule', rtr === 'YES' ? 'Road Train: queue √ó1.5, then min 89 m, then ceiling-to-5' : 'No Road Train: min 26 m, then ceiling-to-5'],
      ['DV Formula', `max(500, VADT√ó0.12/(D1_Lanes+D2_Lanes)) = ${dv}`],
      ['D1 Base Peak Volume', `VADT branch result = ${numberRoundUp(baseDirectionalVolume(1), 3)}`],
      ['D2 Base Peak Volume', `VADT branch result = ${numberRoundUp(baseDirectionalVolume(2), 3)}`],
      ['D1 HV% Used', `${numberRoundUp(getHVPercent(1) * 100, 3)}%`],
      ['D2 HV% Used', `${numberRoundUp(getHVPercent(2) * 100, 3)}%`],
      ['D1 RT% Used', `${numberRoundUp(getRTPercent(1) * 100, 3)}%`],
      ['D2 RT% Used', `${numberRoundUp(getRTPercent(2) * 100, 3)}%`],
      ['SLC Applied', 'Only when lane count is 2 or >2 per direction'],
      ['SLRF Applied', (d1.lanes === 1 && d2.lanes === 1) ? 'Yes (both directions single lane)' : 'No (requires D1=1 and D2=1 lanes)']
    ];

    const traceBody = document.getElementById('traceBody');
    if (traceBody) {
      traceBody.innerHTML = '';
      traceRows.forEach(([k,v]) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td class="rowhead">${k}</td><td>${v}</td>`;
        traceBody.appendChild(tr);
      });
    }

    // Trigger Work Window Optimizer
    generateWorkWindow();
    // Trigger Stop/Go Simulator
    calculateStopGo();
    // Trigger Detour Overlay Simulator
    calculateDetourOverlay();
    // Trigger Speed Reduction Impact
    calculateSpeedDelay();
    // Trigger Pedestrian Delay Calculator
    calculatePedestrianDelay();
  }

  // ===== STOP/GO SHUTTLE SIMULATOR LOGIC =====
  function calculateStopGo() {
    const site = selectedMacroSite ? macroSitesData[selectedMacroSite] : null;
    
    const length = Number(document.getElementById('sgLength').value) || 300;
    const speedKmh = Number(document.getElementById('sgSpeed').value) || 40;
    const cycleTime = Number(document.getElementById('sgCycle').value) || 240;
    
    // Convert speed to m/s to find clearance time
    const speedMs = speedKmh / 3.6;
    const clearanceTime = Math.ceil(length / speedMs);
    
    // We need 2 clearance phases per cycle (one for each direction to clear)
    const totalClearance = clearanceTime * 2;
    const availableGreen = cycleTime - totalClearance;
    
    const warningEl = document.getElementById('sgWarning');
    
    if (availableGreen < 20) {
      document.getElementById('sgClearance').textContent = `${clearanceTime}s`;
      document.getElementById('sgD1Green').textContent = 'Error';
      document.getElementById('sgD2Green').textContent = 'Error';
      warningEl.textContent = `‚ö†Ô∏è Cycle time too short! Clearance alone takes ${totalClearance}s. Increase Max Cycle Time or reduce Work Zone Length.`;
      warningEl.style.display = 'block';
      return;
    } else {
      warningEl.style.display = 'none';
    }

    // Find the absolute Peak Hour Volume for D1 and D2 to stress-test the signals
    let v1 = 0; let v2 = 0;
    if (site && site.directions_weekday) {
      const gaz = site.directions_weekday['GAZETTAL'] || [];
      const ag = site.directions_weekday['AGAINST GAZETTAL'] || [];
      v1 = gaz.length ? Math.max(...gaz.map(v => Number(v)||0)) : num('D1_VADT') * 0.09;
      v2 = ag.length ? Math.max(...ag.map(v => Number(v)||0)) : num('D2_VADT') * 0.09;
    } else {
      v1 = num('D1_VADT') * 0.09; // Fallback to 9% of daily volume if no profile
      v2 = num('D2_VADT') * 0.09;
    }
    
    // Prevent divide by zero
    if (v1 + v2 === 0) { v1 = 1; v2 = 1; }
    
    // Proportionally split the green time
    let g1 = Math.round(availableGreen * (v1 / (v1 + v2)));
    let g2 = availableGreen - g1;
    
    // Enforce minimum green times (10 seconds)
    if (g1 < 10) { g1 = 10; g2 = availableGreen - 10; }
    if (g2 < 10) { g2 = 10; g1 = availableGreen - 10; }

    // Calculate maximum queue during the red phase
    // Red phase duration for D1 = D2 Green + 2x Clearance
    const red1 = g2 + totalClearance;
    const red2 = g1 + totalClearance;
    
    // Vehicles arriving during the red phase (Arrival rate per second * Red seconds)
    const vehQ1 = (v1 / 3600) * red1;
    const vehQ2 = (v2 / 3600) * red2;
    
    // Calculate blended vehicle length based on your inputs
    const hv1 = getHVPercent(1); const rt1 = getRTPercent(1); const lv1 = Math.max(0, 1 - hv1 - rt1);
    const hv2 = getHVPercent(2); const rt2 = getRTPercent(2); const lv2 = Math.max(0, 1 - hv2 - rt2);
    
    // Using your existing queue lengths: LV=6m, HV=20m, RT=63m
    const space1 = (lv1 * 6) + (hv1 * 20) + (rt1 * 63);
    const space2 = (lv2 * 6) + (hv2 * 20) + (rt2 * 63);
    
    // Factor in Road Train Route multiplier if active
    const rtrFactor = txt('RTR').toUpperCase() === 'YES' ? 1.5 : 1;
    
    const q1 = Math.ceil(vehQ1 * space1 * rtrFactor);
    const q2 = Math.ceil(vehQ2 * space2 * rtrFactor);

    // Update the UI
    document.getElementById('sgClearance').textContent = `${clearanceTime}s`;
    document.getElementById('sgD1Green').textContent = `${g1}s`;
    document.getElementById('sgD2Green').textContent = `${g2}s`;
    
    document.getElementById('sgD1Queue').textContent = `Max Queue: ${q1}m`;
    document.getElementById('sgD2Queue').textContent = `Max Queue: ${q2}m`;
  }

  // ===== SMART DETOUR SCANNER LOGIC =====
  async function populateDetourDropdown() {
    const listEl = document.getElementById('detourListContainer');
    if (!listEl) return;

    let pLat, pLon, primaryRoadStd, primaryIdToSkip = null;

    if (selectedMacroSite && macroSitesData[selectedMacroSite]) {
      const primarySite = macroSitesData[selectedMacroSite];
      pLat = Number(primarySite.latitude);
      pLon = Number(primarySite.longitude);
      primaryRoadStd = standardizeRoadName(primarySite.road_name || primarySite.description);
      primaryIdToSkip = selectedMacroSite;
    } else if (window.selectedTiaData && window.selectedTiaData.lat) {
      pLat = Number(window.selectedTiaData.lat);
      pLon = Number(window.selectedTiaData.lon);
      primaryRoadStd = standardizeRoadName(window.selectedTiaData.road);
      primaryIdToSkip = window.selectedTiaData.siteId || null;
    } else {
      listEl.innerHTML = '<div style="padding: 10px; text-align: center; color: #666; font-style: italic;">-- Select a Primary Site or Search Address --</div>';
      return;
    }

    if (!pLat || !pLon) {
      listEl.innerHTML = '<div style="padding: 10px; text-align: center; color: #c30000;">-- Location lacks coordinates --</div>';
      return;
    }

    const selectDetourOption = (detourId) => {
      if (!detourId || !macroSitesData[detourId]) return;
      document.querySelectorAll('.detour-list-item').forEach(el => el.classList.remove('selected'));
      const matched = listEl.querySelector(`.detour-list-item[data-detour-id="${detourId}"]`);
      if (matched) matched.classList.add('selected');
      const detourSelectEl = document.getElementById('detourSiteSelect');
      if (detourSelectEl) detourSelectEl.value = detourId;
      window.selectedDetourSiteId = detourId;
      calculateDetourOverlay();
    };

    const renderRoadPreviewOnMap = (items) => {
      if (!detourMapInstance || !detourMapLayer || typeof L === 'undefined') return;
      detourMapLayer.clearLayers();
      if (detourRoadPreviewLayer) detourRoadPreviewLayer.clearLayers();

      const activePreviewLayer = detourRoadPreviewLayer || detourMapLayer;
      const boundsPoints = [[pLat, pLon]];
      L.circleMarker([pLat, pLon], { radius: 8, color: '#1f5e63', fillColor: '#1f5e63', fillOpacity: 1 })
        .bindTooltip('Primary Location')
        .addTo(detourMapLayer);

      items.forEach(itemData => {
        if (!itemData) return;
        const canSelect = !!(itemData.id && macroSitesData[itemData.id]);
        const style = canSelect
          ? { color: '#8e24aa', weight: 4, opacity: 0.85 }
          : { color: '#9e9e9e', weight: 3, opacity: 0.5, dashArray: '4,6' };

        let clickableLayer = null;
        if (Array.isArray(itemData.geometry) && itemData.geometry.length > 1) {
          clickableLayer = L.polyline(itemData.geometry, style).addTo(activePreviewLayer);
          itemData.geometry.forEach(pt => boundsPoints.push(pt));
        } else if (Number.isFinite(itemData.roadLat) && Number.isFinite(itemData.roadLon)) {
          clickableLayer = L.circleMarker([itemData.roadLat, itemData.roadLon], {
            radius: canSelect ? 6 : 5,
            color: style.color,
            fillColor: style.color,
            fillOpacity: canSelect ? 0.85 : 0.5,
            weight: 2
          }).addTo(activePreviewLayer);
          boundsPoints.push([itemData.roadLat, itemData.roadLon]);
        }

        if (!clickableLayer) return;
        const tip = canSelect ? `${itemData.label} (Click to select detour)` : `${itemData.label} (No counter mapping)`;
        clickableLayer.bindTooltip(tip);

        if (canSelect) {
          clickableLayer.on('click', () => selectDetourOption(itemData.id));
          if (clickableLayer.getElement) {
            const el = clickableLayer.getElement();
            if (el) el.style.cursor = 'pointer';
          }
        }
      });

      if (boundsPoints.length > 1) {
        detourMapInstance.fitBounds(boundsPoints, { padding: [28, 28], maxZoom: 15 });
      } else {
        detourMapInstance.setView([pLat, pLon], 14);
      }
      setTimeout(() => detourMapInstance.invalidateSize(), 100);
    };

    // Immediately Center the Detour Map on the Primary Site
    if (detourMapInstance && detourMapLayer) {
      detourMapLayer.clearLayers();
      if (detourRoadPreviewLayer) detourRoadPreviewLayer.clearLayers();
      L.circleMarker([pLat, pLon], { radius: 8, color: '#1f5e63', fillColor: '#1f5e63', fillOpacity: 1 }).bindTooltip(`Primary Location`).addTo(detourMapLayer);
      detourMapInstance.setView([pLat, pLon], 14);
      setTimeout(() => detourMapInstance.invalidateSize(), 100);
    }

    const bearingDeg = (lat1, lon1, lat2, lon2) => {
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const l1 = lat1 * Math.PI / 180;
      const l2 = lat2 * Math.PI / 180;
      const y = Math.sin(dLon) * Math.cos(l2);
      const x = Math.cos(l1) * Math.sin(l2) - Math.sin(l1) * Math.cos(l2) * Math.cos(dLon);
      return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
    };

    const classifySide = (bearing) => {
      if (bearing >= 225 && bearing <= 315) return 'west';
      if (bearing >= 45 && bearing <= 135) return 'east';
      return 'other';
    };

    const dbCandidates = Object.entries(macroSitesData).map(([id, s]) => ({
      id,
      data: s,
      lat: Number(s.latitude),
      lon: Number(s.longitude),
      roadName: String(s.road_name || s.description || '').trim(),
      roadStd: standardizeRoadName(s.road_name || s.description)
    })).filter(s => Number.isFinite(s.lat) && Number.isFinite(s.lon) && s.roadStd && (!primaryIdToSkip || s.id !== primaryIdToSkip));

    const pickBestCounterForRoad = (roadName, roadLat, roadLon) => {
      const target = String(roadName || '').trim();
      if (!target) return null;
      let best = null;
      let bestScore = 0;
      dbCandidates.forEach(c => {
        if (primaryRoadStd && c.roadStd === primaryRoadStd) return;
        const overlap = tokenOverlapScore(target, c.roadName || c.roadStd || '');
        if (overlap < 0.22) return;
        const distToPrimary = haversineDistance(pLat, pLon, c.lat, c.lon);
        const distToRoad = (Number.isFinite(roadLat) && Number.isFinite(roadLon)) ? haversineDistance(roadLat, roadLon, c.lat, c.lon) : distToPrimary;
        const distanceScore = Math.max(0, 1 - (Math.min(distToRoad, 6000) / 6000));
        const score = (overlap * 0.75) + (distanceScore * 0.25);
        if (score > bestScore) {
          bestScore = score;
          best = { ...c, dist: distToPrimary, matchScore: score };
        }
      });
      return best;
    };

    const renderGroupedList = (groups) => {
      listEl.innerHTML = '';
      const hasAny = groups.some(g => g.items.length > 0);
      if (!hasAny) {
        listEl.innerHTML = '<div style="padding: 10px; text-align: center; color: #666;">-- No distinct nearby data points found --</div>';
        return;
      }

      groups.forEach(group => {
        if (!group.items.length) return;
        const head = document.createElement('div');
        head.style.cssText = 'padding: 6px 4px 2px; font-weight: 700; color: #6a1b9a; font-size: 0.85em;';
        head.textContent = group.title;
        listEl.appendChild(head);

        group.items.forEach(itemData => {
          const distKm = (itemData.dist / 1000).toFixed(2);
          const vadtLabel = itemData.data && itemData.data.vadt ? `${itemData.data.vadt.toLocaleString()} vpd` : 'No counter data';
          const sourceLabel = itemData.data && itemData.data.source ? itemData.data.source : 'OSM road';

          const item = document.createElement('div');
          item.className = 'detour-list-item';
          if (itemData.id) item.dataset.detourId = itemData.id;
          if (!itemData.id) item.style.opacity = '0.7';
          item.innerHTML = `
            <div style="font-weight: bold; color: #4a148c; font-size: 0.95em; margin-bottom: 2px;">${itemData.label}</div>
            <div style="font-size: 0.8em; color: #666; display: flex; justify-content: space-between; gap: 8px;">
              <span>üöó ${distKm}km away ‚Ä¢ ${sourceLabel}</span>
              <span style="background: #eee; padding: 1px 6px; border-radius: 10px; font-size: 0.9em;">${vadtLabel}</span>
            </div>
          `;

          item.onclick = () => {
            if (!itemData.id) return;
            selectDetourOption(itemData.id);
          };

          listEl.appendChild(item);
        });
      });
    };

    try {
      const overpassQuery = `[out:json][timeout:15];way(around:3500,${pLat},${pLon})[highway][name];out tags center geom 300;`;
      const overpassUrl = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(overpassQuery)}`;
      const response = await fetch(overpassUrl);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const data = await response.json();
      const elements = Array.isArray(data && data.elements) ? data.elements : [];

      const seenNames = new Set();
      const roads = [];
      elements.forEach(e => {
        const name = e && e.tags && e.tags.name;
        const lat = e && e.center && Number(e.center.lat);
        const lon = e && e.center && Number(e.center.lon);
        if (!name || !Number.isFinite(lat) || !Number.isFinite(lon)) return;
        const std = standardizeRoadName(name);
        if (!std || (primaryRoadStd && std === primaryRoadStd) || seenNames.has(std)) return;
        seenNames.add(std);
        const dist = haversineDistance(pLat, pLon, lat, lon);
        if (dist > 5000) return;
        const side = classifySide(bearingDeg(pLat, pLon, lat, lon));
        const geometry = Array.isArray(e && e.geometry)
          ? e.geometry
              .map(pt => [Number(pt.lat), Number(pt.lon)])
              .filter(pair => Number.isFinite(pair[0]) && Number.isFinite(pair[1]))
          : [];
        roads.push({ name, std, lat, lon, dist, side, geometry });
      });

      const usedCounterIds = new Set();
      const toListItem = (road) => {
        const best = pickBestCounterForRoad(road.name, road.lat, road.lon);
        if (best && usedCounterIds.has(best.id)) {
          return { id: null, data: null, label: road.name, dist: road.dist };
        }
        if (best) usedCounterIds.add(best.id);
        return {
          id: best ? best.id : null,
          data: best ? best.data : null,
          label: road.name,
          dist: road.dist,
          roadLat: road.lat,
          roadLon: road.lon,
          geometry: road.geometry
        };
      };

      const westItems = roads.filter(r => r.side === 'west').sort((a, b) => a.dist - b.dist).slice(0, 10).map(toListItem);
      const eastItems = roads.filter(r => r.side === 'east').sort((a, b) => a.dist - b.dist).slice(0, 10).map(toListItem);
      const otherItems = roads.filter(r => r.side === 'other').sort((a, b) => a.dist - b.dist).slice(0, 6).map(toListItem);
      const allItems = [...westItems, ...eastItems, ...otherItems];

      renderGroupedList([
        { title: 'Southbound (West Travel)', items: westItems },
        { title: 'Northbound (East Travel)', items: eastItems },
        { title: 'Other Nearby Options', items: otherItems }
      ]);
      renderRoadPreviewOnMap(allItems);

      const hasMapped = allItems.some(i => !!i.id);
      if (!hasMapped) throw new Error('No mapped counters from OSM road scan');
      return;
    } catch (_err) {
      // fallback to local database-only grouped nearest roads
      const local = dbCandidates.map(c => {
        const dist = haversineDistance(pLat, pLon, c.lat, c.lon);
        const side = classifySide(bearingDeg(pLat, pLon, c.lat, c.lon));
        return { id: c.id, data: c.data, label: c.roadName, dist, side };
      }).filter(r => r.dist <= 5000)
        .sort((a, b) => a.dist - b.dist);

      const seenRoads = new Set();
      const compact = [];
      local.forEach(r => {
        const std = standardizeRoadName(r.label);
        if (!std || seenRoads.has(std) || (primaryRoadStd && std === primaryRoadStd)) return;
        seenRoads.add(std);
        compact.push(r);
      });

      const westItems = compact.filter(r => r.side === 'west').slice(0, 10);
      const eastItems = compact.filter(r => r.side === 'east').slice(0, 10);
      const otherItems = compact.filter(r => r.side === 'other').slice(0, 6);

      renderGroupedList([
        { title: 'Southbound (West Travel)', items: westItems },
        { title: 'Northbound (East Travel)', items: eastItems },
        { title: 'Other Nearby Options', items: otherItems }
      ]);

      const localMapItems = [...westItems, ...eastItems, ...otherItems].map(item => {
        const site = item.id ? macroSitesData[item.id] : null;
        return {
          ...item,
          roadLat: site ? Number(site.latitude) : null,
          roadLon: site ? Number(site.longitude) : null,
          geometry: []
        };
      });
      renderRoadPreviewOnMap(localMapItems);
    }
  }

  // ===== DETAILED DETOUR ROUTE CAPACITY LOGIC =====
  function calculateDetourOverlay() {
    const detourSiteId = window.selectedDetourSiteId; // Uses the global variable set by the list click
    const diversionRate = (Number(document.getElementById('detourDiversionRate').value) || 80) / 100;
    const resultsPanel = document.getElementById('detourResults');
    
    if (!detourSiteId || !macroSitesData[detourSiteId]) {
      if (resultsPanel) resultsPanel.style.display = 'none';
      return; // Silently exit if no detour is selected yet
    }

    const detourSite = macroSitesData[detourSiteId];
    if (resultsPanel) resultsPanel.style.display = 'block';
    document.getElementById('detourRouteName').textContent = `Evaluating Detour: ${detourSite.road_name || detourSite.description}`;
    
    // Get Primary Coordinates
    let pLat, pLon;
    const primarySiteId = document.getElementById('macroSiteSearch').value.trim() || selectedMacroSite;
    const primarySite = macroSitesData[primarySiteId];

    if (primarySite && primarySite.latitude) {
      pLat = Number(primarySite.latitude);
      pLon = Number(primarySite.longitude);
    } else if (window.selectedTiaData && window.selectedTiaData.lat) {
      pLat = Number(window.selectedTiaData.lat);
      pLon = Number(window.selectedTiaData.lon);
    }

    // --- MAP VISUALIZATION ---
    if (detourMapInstance && detourMapLayer) {
      detourMapLayer.clearLayers();
      const dLat = Number(detourSite.latitude);
      const dLon = Number(detourSite.longitude);

      if (pLat && pLon && dLat && dLon) {
        // Draw Primary Site
        L.circleMarker([pLat, pLon], { radius: 8, color: '#1f5e63', fillColor: '#1f5e63', fillOpacity: 1 }).bindTooltip(`Primary Location`).addTo(detourMapLayer);
        // Draw Detour Site
        L.circleMarker([dLat, dLon], { radius: 8, color: '#6a1b9a', fillColor: '#ce93d8', fillOpacity: 0.9, weight: 2 }).bindTooltip(`Detour: ${detourSite.road_name}`).addTo(detourMapLayer);
        // Draw Dashed Connecting Line
        const detourLine = L.polyline([[pLat, pLon], [dLat, dLon]], { color: '#8e24aa', weight: 3, opacity: 0.8, dashArray: '8, 8' }).addTo(detourMapLayer);
        
        detourMapInstance.fitBounds(detourLine.getBounds(), { padding: [40, 40], maxZoom: 16 });
        setTimeout(() => detourMapInstance.invalidateSize(), 50);
      }
    }
    
    // Calculate Volumes
    const getCombinedProfile = (site, fallbackVadt) => {
      let combined = new Array(24).fill(0);
      if (site && site.directions_weekday) {
        const gaz = site.directions_weekday['GAZETTAL'] || new Array(24).fill(0);
        const ag = site.directions_weekday['AGAINST GAZETTAL'] || new Array(24).fill(0);
        for(let i=0; i<24; i++) combined[i] = (Number(gaz[i])||0) + (Number(ag[i])||0);
      }
      if (combined.reduce((a,b)=>a+b, 0) === 0 && fallbackVadt > 0) {
        const hrVol = fallbackVadt / 24;
        combined = new Array(24).fill(hrVol);
      }
      return combined;
    };

    const primaryProfile = getCombinedProfile(primarySite, num('VADT'));
    const detourProfile = getCombinedProfile(detourSite, Number(detourSite.vadt)||0);
    
    const detourLanes = Math.max(1, (detourSite.d1_lanes || 1) + (detourSite.d2_lanes || 1));
    let detourCapacity = (Number(detourSite.vadt || 5000) * 0.12) / detourLanes;
    if (detourCapacity < 500) detourCapacity = 500; 
    const totalDetourCapacity = detourCapacity * detourLanes;

    const periods = [
      { key: 'AM (7-9)', hours: [7, 8] },
      { key: 'OP (9-16)', hours: [9, 10, 11, 12, 13, 14, 15] },
      { key: 'PM (16-18)', hours: [16, 17] },
      { key: 'EV (18-7)', hours: [18, 19, 20, 21, 22, 23, 0, 1, 2, 3, 4, 5, 6] }
    ];

    const tbody = document.getElementById('detourDetailedBody');
    tbody.innerHTML = '';
    let maxNewVcr = 0;

    periods.forEach(p => {
      let maxBaseVol = 0;
      let maxPrimaryVol = 0;
      
      p.hours.forEach(h => {
        if (detourProfile[h] > maxBaseVol) maxBaseVol = detourProfile[h];
        if (primaryProfile[h] > maxPrimaryVol) maxPrimaryVol = primaryProfile[h];
      });

      const divertedVol = maxPrimaryVol * diversionRate;
      const newVol = maxBaseVol + divertedVol;

      const baseVcr = maxBaseVol / totalDetourCapacity;
      const newVcr = newVol / totalDetourCapacity;
      if (newVcr > maxNewVcr) maxNewVcr = newVcr;

      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td class="rowhead">${p.key}</td>
        <td style="background: ${vcrColor(baseVcr)}; font-weight: bold;">${baseVcr.toFixed(2)} (${losLabel(baseVcr)})</td>
        <td style="color: #6a1b9a;">+${Math.round(divertedVol).toLocaleString()} vph</td>
        <td style="background: ${vcrColor(newVcr)}; font-weight: bold;">${newVcr.toFixed(2)} (${losLabel(newVcr)})</td>
      `;
      tbody.appendChild(tr);
    });

    const warningText = document.getElementById('detourWarningText');
    if (maxNewVcr > 1.0) {
      warningText.innerHTML = `‚ö†Ô∏è <strong>Warning:</strong> The detour route will operate over capacity during at least one period.`;
      warningText.style.color = '#c30000';
    } else if (maxNewVcr > 0.85) {
      warningText.innerHTML = `‚ö†Ô∏è <strong>Caution:</strong> The detour route will experience heavy congestion.`;
      warningText.style.color = '#e65100';
    } else {
      warningText.innerHTML = `‚úÖ The detour route has sufficient capacity across all periods.`;
      warningText.style.color = '#2e7d32';
    }
  }

  // ===== SPEED REDUCTION TRAVEL TIME IMPACT LOGIC =====
  function calculateSpeedDelay() {
    const vadt = Number(document.getElementById('VADT').value) || 0;
    const length = Number(document.getElementById('srLength').value) || 1000;
    const normSpeedKmh = Number(document.getElementById('srNormSpeed').value) || 80;
    const workSpeedKmh = Number(document.getElementById('srWorkSpeed').value) || 40;

    const perVehicleEl = document.getElementById('srPerVehicle');
    const totalHoursEl = document.getElementById('srTotalHours');
    const transitTextEl = document.getElementById('srTransitText');

    // Handle invalid inputs or no speed reduction
    if (workSpeedKmh >= normSpeedKmh || workSpeedKmh <= 0 || normSpeedKmh <= 0) {
      perVehicleEl.textContent = '0s';
      totalHoursEl.textContent = '0 hrs';
      transitTextEl.textContent = 'No delay from speed reduction.';
      return;
    }

    // Convert speeds from km/h to m/s
    const normSpeedMs = normSpeedKmh / 3.6;
    const workSpeedMs = workSpeedKmh / 3.6;

    // Calculate transit times in seconds
    const normTimeSec = length / normSpeedMs;
    const workTimeSec = length / workSpeedMs;

    // Delay is the difference
    const delaySec = workTimeSec - normTimeSec;

    // Format per-vehicle delay
    if (delaySec < 60) {
      perVehicleEl.textContent = `+${Math.round(delaySec)}s`;
    } else {
      const m = Math.floor(delaySec / 60);
      const s = Math.round(delaySec % 60);
      perVehicleEl.textContent = `+${m}m ${s}s`;
    }

    // Details text
    transitTextEl.textContent = `Transit time increases from ${Math.round(normTimeSec)}s to ${Math.round(workTimeSec)}s`;

    // Calculate total daily delay in hours
    const totalDelayHours = (delaySec * vadt) / 3600;
    totalHoursEl.textContent = totalDelayHours > 0 ? `${Math.round(totalDelayHours).toLocaleString()} hrs` : '0 hrs';
  }

  // ===== PEDESTRIAN DETOUR DELAY LOGIC =====
  function calculatePedestrianDelay() {
    const normDist = Number(document.getElementById('pedNormDist').value) || 0;
    const detourDist = Number(document.getElementById('pedDetourDist').value) || 0;
    const controlledCount = Math.max(0, Number(document.getElementById('pedControlledCount').value) || 0);
    const uncontrolledCount = Math.max(0, Number(document.getElementById('pedUncontrolledCount').value) || 0);
    const walkSpeed = Math.max(0.1, Number(document.getElementById('pedWalkSpeed').value) || 1.2);
    const controlledDelay = Math.max(0, Number(document.getElementById('pedControlledDelay').value) || 60);
    const uncontrolledDelay = Math.max(0, Number(document.getElementById('pedUncontrolledDelay').value) || 10);

    const existingRouteTimeSec = numberRoundUp(normDist / walkSpeed, 0);
    const detouredRouteTimeSec = numberRoundUp(detourDist / walkSpeed, 0);
    const addedDelaySecRaw = (detouredRouteTimeSec + (controlledCount * controlledDelay) + (uncontrolledCount * uncontrolledDelay)) - existingRouteTimeSec;
    const addedDelaySec = Math.max(0, numberRoundUp(addedDelaySecRaw, 0));
    const addedDelayMin = numberRoundUp(addedDelaySec / 60, 2);

    const delayEl = document.getElementById('pedAddedDelay');
    const textEl = document.getElementById('pedTransitText');
    const existingTimeEl = document.getElementById('pedExistingTime');
    const detouredTimeEl = document.getElementById('pedDetouredTime');
    const crossingDelayEl = document.getElementById('pedCrossingDelay');
    const addedSecEl = document.getElementById('pedAddedDelaySec');
    const addedMinEl = document.getElementById('pedAddedDelayMin');

    const crossingDelayTotal = (controlledCount * controlledDelay) + (uncontrolledCount * uncontrolledDelay);

    delayEl.textContent = `+${addedDelaySec.toLocaleString()}s (${addedDelayMin} min)`;

    textEl.textContent = `Existing route ${existingRouteTimeSec}s, detoured route ${detouredRouteTimeSec}s, crossing delay ${crossingDelayTotal}s`;

    if (existingTimeEl) existingTimeEl.textContent = String(existingRouteTimeSec);
    if (detouredTimeEl) detouredTimeEl.textContent = String(detouredRouteTimeSec);
    if (crossingDelayEl) crossingDelayEl.textContent = String(crossingDelayTotal);
    if (addedSecEl) addedSecEl.textContent = String(addedDelaySec);
    if (addedMinEl) addedMinEl.textContent = String(addedDelayMin);
  }

  // Auto-calculation removed: user must click "Calculate All" button
  // ids.forEach(id => {
  //   const el = document.getElementById(id);
  //   if (!el) return;
  //   el.addEventListener('change', calculateAll);
  //   el.addEventListener('input', calculateAll);
  // });
  
  // detour inputs also update overlay
  ['detourSiteSearch','detourDiversionRate'].forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('change', calculateDetourOverlay);
    el.addEventListener('input', calculateDetourOverlay);
  });

  ['RTR', 'DRTPA', 'RTP'].forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('change', syncDirectionalRtFromOverall);
    el.addEventListener('input', syncDirectionalRtFromOverall);
  });

  ['DTCA', 'DHVPA', 'DRTPA', 'HVP', 'D1_HVP', 'D2_HVP', 'RTP', 'D1_RTP', 'D2_RTP', 'D1_Lanes', 'D2_Lanes', 'macroGrowthRate'].forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('change', () => updateAssumptionsPanel());
    el.addEventListener('input', () => updateAssumptionsPanel());
  });

  ['macroGrowthRate', 'macroOpeningYear'].forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('change', rerenderMacroChartsWithCurrentGrowth);
    el.addEventListener('input', rerenderMacroChartsWithCurrentGrowth);
  });

  const calcBtn = document.getElementById('calcBtn');
  if (calcBtn) {
    calcBtn.addEventListener('click', calculateAll);
  }
  setupTableCopyButtons();
  setupOptionalFeaturePrintToggles();
  setupInlineSectionPrintBadges();
  setupDiagnosticsPanel();
  setupGlobalPrintCustomization();
  setVcrView('table');
  setQueueView('table');
  setHourlyQueueView('table');
  setHourlyVcrView('table');
  // Initial calculation removed: calculateAll();

  // ===== TIA ANALYSIS TOOL FUNCTIONS =====
  // ===== WORK WINDOW OPTIMIZER LOGIC =====
  function generateWorkWindow() {
    const site = selectedMacroSite ? macroSitesData[selectedMacroSite] : null;
    if (!site) return;

    const workWindowCard = document.getElementById('workWindowCard');
    if (workWindowCard) workWindowCard.style.display = 'block';

    const maxVcr = Number(document.getElementById('wwMaxVcr').value) || 0.85;
    const dv = calculateDV(); // Uses your existing DV formula
    const d1Lanes = Math.max(1, num('D1_Lanes'));
    const d2Lanes = Math.max(1, num('D2_Lanes'));
    
    // Grab or build 24h profiles
    let gazData = site.directions_weekday['GAZETTAL'] || new Array(24).fill(0);
    let agData = site.directions_weekday['AGAINST GAZETTAL'] || new Array(24).fill(0);
    if (gazData.reduce((a,b)=>a+(Number(b)||0),0) <= 0) gazData = buildSyntheticHourlyFromDaily(num('D1_VADT'));
    if (agData.reduce((a,b)=>a+(Number(b)||0),0) <= 0) agData = buildSyntheticHourlyFromDaily(num('D2_VADT'));

    const timelineEl = document.getElementById('wwTimeline');
    timelineEl.innerHTML = '';
    let permittedHoursCount = 0;
    let permittedBlocks = [];

    // Loop through 24 hours
    for (let h = 0; h < 24; h++) {
      const vol1 = Number(gazData[h]) || 0;
      const vol2 = Number(agData[h]) || 0;
      let worstVcr = 0;

      // Match your SLRF vs SLC logic
      if (d1Lanes === 1 && d2Lanes === 1) {
        // SLRF: Both directions share 1 lane
        worstVcr = (vol1 + vol2) / dv;
      } else {
        // SLC: Close 1 lane in whichever direction
        const d1SlcVcr = d1Lanes > 1 ? (vol1 / (d1Lanes - 1)) / dv : vol1 / dv;
        const d2SlcVcr = d2Lanes > 1 ? (vol2 / (d2Lanes - 1)) / dv : vol2 / dv;
        worstVcr = Math.max(d1SlcVcr, d2SlcVcr);
      }

      const isPermitted = worstVcr <= maxVcr;
      if (isPermitted) permittedHoursCount++;

      // Create the visual block
      const block = document.createElement('div');
      block.style.flex = '1';
      block.style.display = 'flex';
      block.style.flexDirection = 'column';
      block.style.justifyContent = 'center';
      block.style.alignItems = 'center';
      block.style.borderRight = h === 23 ? 'none' : '1px solid rgba(255,255,255,0.4)';
      block.style.transition = 'opacity 0.2s';
      block.style.cursor = 'help';
      block.title = `Hour: ${h}:00 - ${h+1}:00\nWorst VCR: ${worstVcr.toFixed(2)}\nStatus: ${isPermitted ? 'Permitted' : 'Restricted'}`;
      
      if (isPermitted) {
        block.style.backgroundColor = worstVcr > (maxVcr - 0.1) ? '#ffb300' : '#4caf50'; // Yellow if close to limit, Green if safe
        block.style.color = '#fff';
        block.innerHTML = `<span style="font-size: 10px; opacity: 0.8;">${h}</span>`;
        permittedBlocks.push(h);
      } else {
        block.style.backgroundColor = '#ef5350'; // Red
        block.style.color = 'rgba(255,255,255,0.5)';
        block.innerHTML = `<span style="font-size: 10px;">${h}</span>`;
      }

      timelineEl.appendChild(block);
    }

    // Generate smart text summary
    const summaryEl = document.getElementById('wwSummary');
    if (permittedHoursCount === 24) {
      summaryEl.innerHTML = `<span style="color: #2e7d32;">‚úÖ Permitted 24 hours a day (Max VCR does not exceed ${maxVcr})</span>`;
    } else if (permittedHoursCount === 0) {
      summaryEl.innerHTML = `<span style="color: #c30000;">‚ùå Not permitted at any time (VCR exceeds ${maxVcr} all day)</span>`;
    } else {
      // Group consecutive hours for a clean text output
      let windows = [];
      let start = permittedBlocks[0];
      for (let i = 1; i <= permittedBlocks.length; i++) {
        if (permittedBlocks[i] !== permittedBlocks[i - 1] + 1) {
          windows.push(`${start}:00 to ${permittedBlocks[i - 1] + 1}:00`);
          start = permittedBlocks[i];
        }
      }
      summaryEl.innerHTML = `<span style="color: #1f5e63;">üïí Permitted Work Windows: <strong>${windows.join(' & ')}</strong></span>`;
    }
  }

  
  // Haversine distance calculation (meters)
  function haversineDistance(lat1, lon1, lat2, lon2) {
    const R = 6371000; // Earth radius in meters
    const œÜ1 = lat1 * Math.PI / 180;
    const œÜ2 = lat2 * Math.PI / 180;
    const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
    const ŒîŒª = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
              Math.cos(œÜ1) * Math.cos(œÜ2) *
              Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  // Find best matching site (exact road match or closest distance)
  function findBestMatchSite(searchTerm) {
    const searchLower = searchTerm.toLowerCase().trim();
    const sites = Object.entries(macroSitesData);
    
    // First, try exact road name match
    const roadMatches = sites.filter(([, data]) => 
      data.road_name && data.road_name.toLowerCase().includes(searchLower)
    );
    
    if (roadMatches.length > 0) {
      return { sites: roadMatches, matchType: 'exact_road' };
    }
    
    // Try description/suburb match
    const descMatches = sites.filter(([, data]) => 
      (data.description && data.description.toLowerCase().includes(searchLower)) ||
      (data.source && data.source.toLowerCase().includes(searchLower))
    );
    
    if (descMatches.length > 0) {
      return { sites: descMatches, matchType: 'description' };
    }
    
    // Return closest 3 sites as fallback
    if (sites.length > 0) {
      return { sites: sites.slice(0, 3), matchType: 'nearby' };
    }
    
    return null;
  }

  // Queue modeling using M/M/c (Erlang C)
  function calculateQueueMetrics(peakVolume, lanes, serviceDuration = 2.5) {
    const serviceRate = 3600 / serviceDuration; // vehicles per hour per lane
    const rho = peakVolume / (lanes * serviceRate); // utilization
    
    if (rho >= 1.0) {
      return {
        avgQueue: Infinity,
        p95Queue: Infinity,
        los: 'F',
        capacity: peakVolume + (peakVolume * 0.1)
      };
    }
    
    // Erlang C formula for average queue
    const erlangNum = Math.pow(rho * lanes, lanes) / factorial(lanes) * (1 / (1 - rho));
    const erlangDen = sum(Array.from({length: lanes}, (_, n) => 
                        Math.pow(rho * lanes, n) / factorial(n))) +
                      (Math.pow(rho * lanes, lanes) / factorial(lanes) * (1 / (1 - rho)));
    const pw = erlangNum / erlangDen; // Probability of waiting
    
    // Average queue length (vehicles waiting)
    const avgQueue = (pw * rho) / (1 - rho) * lanes;
    
    // 95th percentile queue
    const p95Queue = avgQueue + Math.sqrt(avgQueue * 2);
    
    // Level of Service based on utilization
    let los = 'A';
    if (rho >= 0.85) los = 'E';
    else if (rho >= 0.70) los = 'D';
    else if (rho >= 0.50) los = 'C';
    else if (rho >= 0.30) los = 'B';
    
    return {
      avgQueue: Math.round(avgQueue * 10) / 10,
      p95Queue: Math.round(p95Queue * 10) / 10,
      los: los,
      utilization: Math.round(rho * 1000) / 10
    };
  }

  // Helper: Factorial
  function factorial(n) {
    if (n <= 1) return 1;
    let result = 1;
    for (let i = 2; i <= n; i++) result *= i;
    return result;
  }

  // Helper: Sum array
  function sum(arr) {
    return arr.reduce((a, b) => a + b, 0);
  }

  // Main TIA search function
  function performTIASearch() {
    const searchInput = document.getElementById('tiaSearchInput').value.trim();
    if (!searchInput) {
      alert('Please enter a road name or location');
      return;
    }

    const matchResult = findBestMatchSite(searchInput);
    if (!matchResult || !matchResult.sites.length) {
      document.getElementById('tiaResultsPanel').style.display = 'none';
      document.getElementById('tiaNoResultsPanel').style.display = 'block';
      return;
    }

    // Use the first matched site
    const [siteId, siteData] = matchResult.sites[0];
    const d1Lanes = siteData.d1_lanes || 1;
    const d2Lanes = siteData.d2_lanes || 1;
    
    // Calculate peak hour volumes (assume 9% of VADT occurs in peak hour)
    const peakHourPercent = 0.09;
    const d1PeakAM = Math.round(siteData.d1_vadt * peakHourPercent);
    const d2PeakAM = Math.round(siteData.d2_vadt * peakHourPercent);
    const d1PeakPM = d1PeakAM;
    const d2PeakPM = d2PeakAM;

    // Calculate queue metrics
    const d1Queue = calculateQueueMetrics(d1PeakAM, d1Lanes);
    const d2Queue = calculateQueueMetrics(d2PeakAM, d2Lanes);

    // Display source info
    document.getElementById('tiaSourceType').textContent = matchResult.matchType === 'exact_road' ? '‚úì Exact Road Match' : 
                                                           matchResult.matchType === 'description' ? '‚äô Location Match' : 
                                                           '‚äó Nearby Reference';
    document.getElementById('tiaSourceRoad').textContent = siteData.road_name || siteData.description || siteId;
    document.getElementById('tiaSourceDistance').textContent = matchResult.matchType === 'exact_road' ? 'Same Road' : 'Reference data';
    document.getElementById('tiaSourceVADT').textContent = siteData.vadt.toLocaleString() + ' vehicles/day';

    // Display peak hour info
    document.getElementById('tiaPeakAMD1').textContent = d1PeakAM;
    document.getElementById('tiaPeakAMD2').textContent = d2PeakAM;
    document.getElementById('tiaPeakPMD1').textContent = d1PeakPM;
    document.getElementById('tiaPeakPMD2').textContent = d2PeakPM;

    // Display queue results
    document.getElementById('tiaD1Lanes').textContent = d1Lanes;
    document.getElementById('tiaD1AvgQueue').textContent = isFinite(d1Queue.avgQueue) ? d1Queue.avgQueue.toFixed(1) : 'Breakdown';
    document.getElementById('tiaD1P95Queue').textContent = isFinite(d1Queue.p95Queue) ? d1Queue.p95Queue.toFixed(0) : 'Breakdown';
    document.getElementById('tiaD1LOS').textContent = d1Queue.los;
    document.getElementById('tiaD1Util').textContent = d1Queue.utilization.toFixed(1);

    document.getElementById('tiaD2Lanes').textContent = d2Lanes;
    document.getElementById('tiaD2AvgQueue').textContent = isFinite(d2Queue.avgQueue) ? d2Queue.avgQueue.toFixed(1) : 'Breakdown';
    document.getElementById('tiaD2P95Queue').textContent = isFinite(d2Queue.p95Queue) ? d2Queue.p95Queue.toFixed(0) : 'Breakdown';
    document.getElementById('tiaD2LOS').textContent = d2Queue.los;
    document.getElementById('tiaD2Util').textContent = d2Queue.utilization.toFixed(1);

    // Update note
    const note = matchResult.matchType === 'exact_road' ? 
                 '‚úì Data sourced from exact road match: ' + siteData.source :
                 matchResult.matchType === 'description' ?
                 '‚äô Data interpolated from nearby location match' :
                 '! Using nearest reference site for estimate';
    document.getElementById('tiaMatchNote').textContent = note;

    document.getElementById('tiaNoResultsPanel').style.display = 'none';
    document.getElementById('tiaResultsPanel').style.display = 'block';
  }

  // Allow Enter key to trigger search
  const tiaSearchInputEl = document.getElementById('tiaSearchInput');
  if (tiaSearchInputEl) {
    tiaSearchInputEl.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') performTIASearch();
    });
  }

  // ===== QUICK TIA SEARCH FUNCTIONS =====
  
  function normalizeRoadTokens(text) {
    const raw = String(text || '').toLowerCase();
    const drop = new Set(['road','rd','street','st','avenue','ave','drive','dr','lane','ln','highway','hwy','motorway','mtwy','the','and']);
    return raw
      .replace(/[^a-z0-9\s]/g, ' ')
      .split(/\s+/)
      .filter(token => token && token.length > 1 && !drop.has(token));
  }

  function tokenOverlapScore(searchText, roadText) {
    const a = new Set(normalizeRoadTokens(searchText));
    const b = new Set(normalizeRoadTokens(roadText));
    if (!a.size || !b.size) return 0;
    const intersection = Array.from(a).filter(token => b.has(token)).length;
    const union = new Set([...a, ...b]).size;
    return union > 0 ? (intersection / union) : 0;
  }

  function inferRoutePossibility(searchText, roadText, descriptionText, distanceMeters) {
    const overlap = tokenOverlapScore(searchText, `${roadText || ''} ${descriptionText || ''}`);
    const distanceScore = Math.max(0, 1 - (Math.min(Number(distanceMeters) || 0, 3000) / 3000));
    const sameRoadBoost = overlap > 0.45 ? 1 : 0;
    const blended = (overlap * 0.55) + (distanceScore * 0.35) + (sameRoadBoost * 0.10);
    return Math.max(0, Math.min(100, Math.round(blended * 100)));
  }

  // --- NEW SMART HELPERS ---
  function standardizeRoadName(name) {
    if (!name) return '';
    return name.toLowerCase().replace(/[.,'"]/g, '').trim()
      .replace(/\b(st|street)\b/g, 'street')
      .replace(/\b(rd|road)\b/g, 'road')
      .replace(/\b(ave|avenue)\b/g, 'avenue')
      .replace(/\b(dr|drive)\b/g, 'drive')
      .replace(/\b(hwy|highway|mwy|motorway)\b/g, 'highway');
  }

  function isSameRoad(road1, road2) {
    if (!road1 || !road2) return false;
    const r1 = standardizeRoadName(road1);
    const r2 = standardizeRoadName(road2);
    return r1 === r2 || (r1.length > 5 && r2.includes(r1)) || (r2.length > 5 && r1.includes(r2));
  }

  function getBearingDirection(lat1, lon1, lat2, lon2) {
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const l1 = lat1 * Math.PI / 180;
    const l2 = lat2 * Math.PI / 180;
    const y = Math.sin(dLon) * Math.cos(l2);
    const x = Math.cos(l1) * Math.sin(l2) - Math.sin(l1) * Math.cos(l2) * Math.cos(dLon);
    let brng = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
    const dirs = ["North", "Northeast", "East", "Southeast", "South", "Southwest", "West", "Northwest"];
    return dirs[Math.round(brng / 45) % 8];
  }

  function inferRoadTypeFromText(text) {
    const value = String(text || '').toLowerCase();
    if (!value) return 'unknown';
    if (/(motorway|freeway|highway|arterial|bypass|expressway|state route|m\d+|a\d+)/.test(value)) return 'busy';
    if (/(close|court|crescent|place|cul de sac|lane|way|parade|terrace)/.test(value)) return 'residential';
    if (/(street|st\b|road|rd\b|avenue|ave\b|boulevard|blvd|drive|dr\b)/.test(value)) return 'mixed';
    return 'unknown';
  }

  function getRoadTypeSensitivitySettings() {
    const read = (id, fallback) => {
      const el = document.getElementById(id);
      const n = Number(el && el.value);
      return Number.isFinite(n) ? n : fallback;
    };

    const residentialMaxVadt = Math.max(500, read('rtResidentialMaxVadt', 4500));
    const busyMinVadt = Math.max(residentialMaxVadt + 500, read('rtBusyMinVadt', 14000));
    const residentialFactor = Math.max(30, Math.min(100, read('rtResidentialFactor', 50)));
    const mixedFactor = Math.max(50, Math.min(120, read('rtMixedFactor', 80)));
    const busyFactor = Math.max(70, Math.min(130, read('rtBusyFactor', 100)));

    return {
      residentialMaxVadt,
      busyMinVadt,
      residentialFactor,
      mixedFactor,
      busyFactor
    };
  }

  function detectAreaProfile(searchRoad, references) {
    const refs = Array.isArray(references) ? references : [];
    const searchType = inferRoadTypeFromText(searchRoad);
    const cfg = getRoadTypeSensitivitySettings();
    const avgVadt = refs.length
      ? refs.reduce((sum, r) => sum + (Number(r && r.vadt) || 0), 0) / refs.length
      : 0;

    if (searchType === 'residential' || (avgVadt > 0 && avgVadt < cfg.residentialMaxVadt)) {
      return { type: 'Residential', factorPercent: cfg.residentialFactor };
    }
    if (searchType === 'busy' || avgVadt >= cfg.busyMinVadt) {
      return { type: 'Busy Road/Street', factorPercent: cfg.busyFactor };
    }
    return { type: 'Mixed Urban Street', factorPercent: cfg.mixedFactor };
  }

  function calcReferenceTypePercent(areaType, siteVadt) {
    const vadt = Number(siteVadt) || 0;
    if (areaType === 'Residential') {
      if (vadt < 3000) return 100;
      if (vadt < 8000) return 75;
      return 50;
    }
    if (areaType === 'Busy Road/Street') {
      if (vadt < 3000) return 60;
      if (vadt < 8000) return 85;
      return 100;
    }
    if (vadt < 3000) return 80;
    if (vadt < 8000) return 95;
    return 90;
  }

  // --- NEW GEOCODING HELPER FUNCTION ---
  // Converts the user's typed address into exact latitude and longitude
  async function geocodeAddress(address) {
    const toLocation = (item) => {
      if (!item) return null;
      const lat = Number(item.lat);
      const lon = Number(item.lon);
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
      return {
        lat,
        lon,
        displayName: item.display_name || item.name || address,
        road: item.address ? (item.address.road || item.address.pedestrian || null) : null,
        provider: item.provider || 'Geocoder'
      };
    };

    const fetchJsonWithTimeout = async (url, timeoutMs = 9000) => {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
      try {
        const response = await fetch(url, { signal: controller.signal, headers: { 'Accept-Language': 'en-AU,en;q=0.9' }});
        if (!response.ok) return null;
        return await response.json();
      } catch (_err) {
        return null;
      } finally { clearTimeout(timeoutId); }
    };

    const queries = [address, `${address}, Queensland, Australia`, `${address}, Australia`];
    for (const q of queries) {
      const nominatimAu = `https://nominatim.openstreetmap.org/search?format=jsonv2&limit=5&addressdetails=1&countrycodes=au&q=${encodeURIComponent(q)}`;
      const nominatimAny = `https://nominatim.openstreetmap.org/search?format=jsonv2&limit=5&addressdetails=1&q=${encodeURIComponent(q)}`;

      const responses = [
        { provider: 'Nominatim (AU)', data: await fetchJsonWithTimeout(nominatimAu) },
        { provider: 'Nominatim (Global)', data: await fetchJsonWithTimeout(nominatimAny) }
      ];

      for (const responsePack of responses) {
        const data = responsePack.data;
        if (!Array.isArray(data) || data.length === 0) continue;

        const preferredAu = data.find(item => String(item.display_name || '').toLowerCase().includes('australia'));
        const chosen = preferredAu || data[0];
        chosen.provider = responsePack.provider;
        const location = toLocation(chosen);
        if (location) return location;
      }
    }
    return null;
  }

  // --- UPDATED MAIN SEARCH FUNCTION ---
  async function performQuickTIASearch() {
    try {
      const searchInputEl = document.getElementById('quickTiaInput');
      const searchInput = (searchInputEl && searchInputEl.value || '').trim();
      if (!searchInput) return alert('Please enter a road name or location');

      const searchBtn = document.getElementById('quickTiaSearchBtn') || document.querySelector('button[onclick="performQuickTIASearch()"]');
      let originalBtnText = null;
      if (searchBtn) { originalBtnText = searchBtn.innerHTML; searchBtn.innerHTML = '‚è≥ Searching...'; searchBtn.disabled = true; }

      document.getElementById('quickTiaError').style.display = 'none';
      document.getElementById('quickTiaPanel').style.display = 'none';
      document.getElementById('quickTiaSearchAddress').textContent = searchInput;
      const geoSourceEl = document.getElementById('quickTiaGeoSource');
      if (geoSourceEl) geoSourceEl.textContent = 'Searching...';

      // 1. Geocode
      let location = await geocodeAddress(searchInput);

    if (!location) {
      const fallbackMatch = findBestMatchSite(searchInput);
      if (fallbackMatch && fallbackMatch.sites.length) {
        const [id, data] = fallbackMatch.sites[0];
        if (Number.isFinite(Number(data.latitude))) {
          location = {
            lat: Number(data.latitude),
            lon: Number(data.longitude),
            displayName: data.road_name,
            road: data.road_name,
            provider: 'Local Database Fallback'
          };
        }
      }
    }

    if (!location) {
      document.getElementById('quickTiaError').innerHTML = `<strong>‚ùå Could not find that address on the map.</strong><br><span style="font-size: 0.9em;">Try adding suburb/city.</span>`;
      document.getElementById('quickTiaError').style.display = 'block';
      if (searchBtn) { searchBtn.innerHTML = originalBtnText; searchBtn.disabled = false; }
      return;
    }

    if (geoSourceEl) geoSourceEl.textContent = location.provider;
    addSearchMarker(location.lat, location.lon, searchInput);
    
    // 2. Map distances and bearings to all sites
    const sites = Object.entries(macroSitesData).filter(([, d]) => d.latitude && d.longitude).map(([id, data]) => {
      const dist = haversineDistance(location.lat, location.lon, Number(data.latitude), Number(data.longitude));
      const direction = getBearingDirection(location.lat, location.lon, Number(data.latitude), Number(data.longitude));
      return { id, data, dist, direction };
    });

    // 3. SMART FILTER: Check for sites on the EXACT SAME ROAD
    const targetRoad = location.road || searchInput;
    const sameRoadSites = sites
      .filter(s => isSameRoad(targetRoad, s.data.road_name))
      .sort((a, b) => a.dist - b.dist);

    if (sameRoadSites.length > 0) {
      const selectedPoints = sameRoadSites.slice(0, 3);

      if (selectedPoints.length === 1 && selectedPoints[0].dist < 150) {
        displayQuickTiaExactMatch(selectedPoints[0].id, selectedPoints[0].data);
        showNotification(`‚úì Exact data found on ${selectedPoints[0].data.road_name}!`);
      } else {
        const formattedArray = selectedPoints.map(s => [s.id, s.data, s.dist, s.direction]);
        displayQuickTiaMultipleRefs(targetRoad, formattedArray, location.lat, location.lon, true);
        showNotification(`üìç Found ${formattedArray.length} traffic counters along ${targetRoad}.`);
      }
    } else {
      const radiusMeters = 5000;
      const closestSites = sites
        .filter(s => s.dist <= radiusMeters)
        .sort((a, b) => a.dist - b.dist)
        .slice(0, 5);
      if (closestSites.length === 0) {
        document.getElementById('quickTiaError').innerHTML = `<strong>‚ùå No traffic data found within 5km.</strong>`;
        document.getElementById('quickTiaError').style.display = 'block';
      } else {
        const nearbyArray = closestSites.map(s => [s.id, s.data, s.dist, s.direction]);
        displayQuickTiaMultipleRefs(searchInput, nearbyArray, location.lat, location.lon, false);
        showNotification(`‚ö† Address found, but no counters on that exact road. Loading nearest references within 5km.`);
      }
    }

      if (searchBtn) { searchBtn.innerHTML = originalBtnText; searchBtn.disabled = false; }
    } catch (err) {
      console.error('performQuickTIASearch error', err);
      const errEl = document.getElementById('quickTiaError');
      if (errEl) { errEl.innerHTML = `<strong>‚ùå Error:</strong> ${String(err && err.message ? err.message : err)}`; errEl.style.display = 'block'; }
      // try to restore button state if possible
      try { const b = document.getElementById('quickTiaSearchBtn'); if (b) { b.innerHTML = 'üîç Search'; b.disabled = false; } } catch (_) {}
    }
  }

  window.performQuickTIASearch = performQuickTIASearch;

  function addSearchMarker(lat, lon, label) {
    // Clear previous search markers
    if (macroSearchMarkerLayer) {
      macroMapInstance.removeLayer(macroSearchMarkerLayer);
    }

    // Create new marker layer for search result
    macroSearchMarkerLayer = L.layerGroup().addTo(macroMapInstance);

    // Add marker with custom styling
    const marker = L.circleMarker([lat, lon], {
      radius: 10,
      fillColor: '#ff7043',
      color: '#d84315',
      weight: 3,
      opacity: 1,
      fillOpacity: 0.7
    }).addTo(macroSearchMarkerLayer);

    // Add popup with label
    marker.bindPopup(`<b>${label}</b>`, {
      autoClose: false,
      closeButton: true
    }).openPopup();

    // Pan and zoom to marker
    macroMapInstance.setView([lat, lon], Math.max(macroMapInstance.getZoom(), 17));
  }

  function showNotification(message) {
    // Create or reuse notification element
    let notif = document.getElementById('quickTiaNotification');
    if (!notif) {
      notif = document.createElement('div');
      notif.id = 'quickTiaNotification';
      notif.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #4caf50;
        color: white;
        padding: 12px 20px;
        border-radius: 4px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        z-index: 10000;
        font-weight: bold;
      `;
      document.body.appendChild(notif);
    }

    notif.textContent = message;
    notif.style.display = 'block';

    // Auto-hide after 3 seconds
    setTimeout(() => {
      notif.style.display = 'none';
    }, 3000);
  }

  function displayQuickTiaExactMatch(siteId, siteData) {
    document.getElementById('quickTiaMatchType').textContent = '‚úì Exact Road Match';
    document.getElementById('quickTiaMatchRoad').textContent = siteData.road_name || siteData.description;
    const d1DirLabel = String(siteData.d1_direction_label || 'Direction 1').trim();
    const d2DirLabel = String(siteData.d2_direction_label || 'Direction 2').trim();
    const exactD1LabelEl = document.getElementById('quickTiaExactD1Label');
    const exactD2LabelEl = document.getElementById('quickTiaExactD2Label');
    if (exactD1LabelEl) exactD1LabelEl.textContent = formatDirectionalVadtLabel('D1', d1DirLabel);
    if (exactD2LabelEl) exactD2LabelEl.textContent = formatDirectionalVadtLabel('D2', d2DirLabel);
    
    document.getElementById('quickTiaExactVADT').textContent = siteData.vadt.toLocaleString();
    document.getElementById('quickTiaExactD1').textContent = siteData.d1_vadt.toLocaleString();
    document.getElementById('quickTiaExactD2').textContent = siteData.d2_vadt.toLocaleString();

    document.getElementById('quickTiaExactMatch').style.display = 'block';
    document.getElementById('quickTiaMultipleRefs').style.display = 'none';
    
    // Store for later use
    window.selectedTiaData = {
      type: 'exact',
      siteId: siteId,
      vadt: siteData.vadt,
      d1_vadt: siteData.d1_vadt,
      d2_vadt: siteData.d2_vadt,
      d1_direction_label: d1DirLabel,
      d2_direction_label: d2DirLabel,
      lat: siteData.latitude,
      lon: siteData.longitude,
      road: siteData.road_name,
      countYear: siteData.countYear || siteData.count_year || null
    };

    document.getElementById('quickTiaPanel').style.display = 'block';
  }

  function displayQuickTiaMultipleRefs(searchTerm, nearbyArray, centerLat, centerLon, isSameRoadMatch = false) {
    document.getElementById('quickTiaMatchType').textContent = isSameRoadMatch
      ? `üìç Along Same Road (${searchTerm})`
      : '‚äô Nearby References (Radius Search)';
    document.getElementById('quickTiaMatchRoad').textContent = isSameRoadMatch
      ? 'Interpolating data points forward/backward on this street.'
      : 'Using closest points (may be on adjacent streets).';
    
    const refList = document.getElementById('quickTiaRefList');
    refList.innerHTML = '';
    
    const refArray = nearbyArray.map((item) => {
      const siteId = item[0];
      const data = item[1];
      const distFromCenter = item[2] || haversineDistance(centerLat, centerLon, Number(data.latitude), Number(data.longitude));
      const direction = item[3] || 'Nearby';
      return {
        siteId,
        road: data.road_name || data.description,
        vadt: data.vadt,
        d1_vadt: data.d1_vadt,
        d2_vadt: data.d2_vadt,
        d1_direction_label: data.d1_direction_label || 'Direction 1',
        d2_direction_label: data.d2_direction_label || 'Direction 2',
        lat: data.latitude,
        lon: data.longitude,
        source: data.source || 'Unknown',
        distance: Math.round(distFromCenter),
        description: data.description,
        direction,
        countYear: data.countYear || data.count_year || null
      };
    });

    const areaProfile = detectAreaProfile(searchTerm, refArray);
    refArray.forEach(site => {
      site.typePercent = calcReferenceTypePercent(areaProfile.type, site.vadt);
    });

    let totalInverseDist = 0;
    refArray.forEach(site => {
      site.invDist = 1 / (site.distance + 10);
      totalInverseDist += site.invDist;
    });

    let currentWeightSum = 0;
    refArray.forEach(site => {
      site.autoWeight = Math.round((site.invDist / totalInverseDist) * 100);
      currentWeightSum += site.autoWeight;
    });

    if (refArray.length > 0 && currentWeightSum !== 100) {
      refArray[0].autoWeight += (100 - currentWeightSum);
    }

    // Draw link lines from search point to each reference site
    if (macroMapInstance && typeof L !== 'undefined') {
      if (macroReferenceLinkLayer) {
        macroMapInstance.removeLayer(macroReferenceLinkLayer);
      }
      macroReferenceLinkLayer = L.layerGroup().addTo(macroMapInstance);
    }

    refArray.forEach((site, idx) => {
      const div = document.createElement('div');
      div.style.cssText = isSameRoadMatch
        ? 'padding: 10px; border: 1px solid #e0e0e0; border-radius: 6px; font-size: 0.85em; background: #e8f5e9;'
        : 'padding: 10px; border: 1px solid #e0e0e0; border-radius: 6px; font-size: 0.85em; background: #fafafa;';
      const distanceText = site.distance < 1000 ? `${site.distance}m` : `${(site.distance/1000).toFixed(1)}km`;
      const sourceLabel = `[${site.source}]`;
      const suggestedWeight = Math.max(0, Math.min(100, site.autoWeight));
      const matchBadge = isSameRoadMatch
        ? '<span style="margin-left: 6px; padding: 1px 6px; border-radius: 10px; background: #2e7d32; color: #fff; font-size: 0.72em;">Same road</span>'
        : '<span style="margin-left: 6px; padding: 1px 6px; border-radius: 10px; background: #546e7a; color: #fff; font-size: 0.72em;">Nearby</span>';
      div.innerHTML = `
        <strong>${idx + 1}.</strong> ${site.road} ${matchBadge}<br/>
        <small style="color: #666;">${sourceLabel} ‚Ä¢ <strong>${distanceText} ${site.direction} of address</strong> ‚Ä¢ ${site.vadt.toLocaleString()} VADT</small>
        <div style="margin-top: 6px; display: grid; grid-template-columns: 1fr auto auto auto auto; align-items: center; gap: 8px;">
          <span style="color: #333; font-size: 0.8em;">Distance Weighting:</span>
          <input type="range" class="ref-weight-slider" data-siteid="${site.siteId}" min="0" max="100" step="1" value="${suggestedWeight}" style="width: 100%; cursor: pointer;" />
          <input type="number" class="ref-weight" data-siteid="${site.siteId}" min="0" max="100" step="1" value="${suggestedWeight}" style="width: 62px; padding: 2px 4px; border: 1px solid #ccc; border-radius: 3px; font-size: 0.85em;" />
          <span style="font-size: 0.8em; color: #666;">%</span>
          <span style="font-size: 0.75em; color: #1f5e63; background: #e3f2fd; border: 1px solid #90caf9; border-radius: 10px; padding: 1px 6px;">${site.typePercent}%</span>
        </div>
      `;
      refList.appendChild(div);

      const sliderInput = div.querySelector('.ref-weight-slider');
      const weightInput = div.querySelector('.ref-weight');
      if (sliderInput && weightInput) {
        sliderInput.addEventListener('input', () => {
          weightInput.value = sliderInput.value;
          updateTiaCalculations();
        });
        weightInput.addEventListener('input', () => {
          const v = Math.max(0, Math.min(100, Number(weightInput.value) || 0));
          weightInput.value = String(v);
          sliderInput.value = String(v);
          updateTiaCalculations();
        });
      }

      // Add visual link on the map
      if (macroReferenceLinkLayer && Number.isFinite(site.lat) && Number.isFinite(site.lon)) {
        L.polyline([[centerLat, centerLon], [Number(site.lat), Number(site.lon)]], {
          color: '#1976d2',
          weight: 2,
          opacity: 0.7,
          dashArray: '4,6'
        }).addTo(macroReferenceLinkLayer);
      }
    });

    // Calculate weighted averages based on per-road weights
    const weightInputs = refList.querySelectorAll('.ref-weight');
    const weights = Array.from(weightInputs).map(input => Number(input.value) || 0);
    const weightTotal = weights.reduce((sum, w) => sum + w, 0) || 1;

    const avgVADT = Math.round(refArray.reduce((sum, s, i) => sum + (s.vadt * (weights[i] || 0)), 0) / weightTotal);
    const avgD1 = Math.round(refArray.reduce((sum, s, i) => sum + (s.d1_vadt * (weights[i] || 0)), 0) / weightTotal);
    const avgD2 = Math.round(refArray.reduce((sum, s, i) => sum + (s.d2_vadt * (weights[i] || 0)), 0) / weightTotal);

    window.selectedTiaData = {
      type: 'references',
      references: refArray,
      avgVADT: avgVADT,
      avgD1: avgD1,
      avgD2: avgD2,
      avgD1Label: refArray.length ? String(refArray[0].d1_direction_label || 'Direction 1') : 'Direction 1',
      avgD2Label: refArray.length ? String(refArray[0].d2_direction_label || 'Direction 2') : 'Direction 2',
      areaType: areaProfile.type,
      areaTypeFactorPercent: areaProfile.factorPercent,
      lat: centerLat,    // <-- ADD THIS
      lon: centerLon,    // <-- ADD THIS
      road: searchTerm   // <-- ADD THIS
    };

    updateTiaCalculations();

    document.getElementById('quickTiaExactMatch').style.display = 'none';
    document.getElementById('quickTiaMultipleRefs').style.display = 'block';
    document.getElementById('quickTiaPanel').style.display = 'block';
  }

  function updateTiaCalculations() {
    if (!window.selectedTiaData || window.selectedTiaData.type !== 'references') return;

    const refWeights = Array.from(document.querySelectorAll('#quickTiaRefList .ref-weight')).map(input => Number(input.value) || 0);
    const refs = window.selectedTiaData.references || [];
    const n = Math.max(1, refs.length);
    const percentAdjustedMean = (key) => {
      const adjustedSum = refs.reduce((sum, s, i) => {
        const value = Number(s[key]) || 0;
        const percent = Math.max(0, Math.min(100, Number(refWeights[i]) || 0));
        const typePercent = Math.max(0, Math.min(140, Number(s && s.typePercent) || 100));
        return sum + ((percent / 100) * (typePercent / 100) * value);
      }, 0);
      return adjustedSum / n;
    };

    const avgVadtRaw = percentAdjustedMean('vadt');
    const avgD1Raw = percentAdjustedMean('d1_vadt');
    const avgD2Raw = percentAdjustedMean('d2_vadt');

    const weightedAvgVADT = Math.round(avgVadtRaw);
    const weightedAvgD1 = Math.round(avgD1Raw);
    const weightedAvgD2 = Math.round(avgD2Raw);

    const areaTypeFactorPercent = Math.max(30, Math.min(130, Number(window.selectedTiaData.areaTypeFactorPercent) || 100));
    const finalAvgVADT = Math.round(weightedAvgVADT * (areaTypeFactorPercent / 100));
    const finalAvgD1 = Math.round(weightedAvgD1 * (areaTypeFactorPercent / 100));
    const finalAvgD2 = Math.round(weightedAvgD2 * (areaTypeFactorPercent / 100));

    window.selectedTiaData.avgVADT = finalAvgVADT;
    window.selectedTiaData.avgD1 = finalAvgD1;
    window.selectedTiaData.avgD2 = finalAvgD2;

    const calcD1LabelEl = document.getElementById('quickTiaCalcD1Label');
    const calcD2LabelEl = document.getElementById('quickTiaCalcD2Label');
    const areaTypeEl = document.getElementById('quickTiaAreaType');
    const typePercentEl = document.getElementById('quickTiaTypePercent');
    if (calcD1LabelEl) calcD1LabelEl.textContent = formatDirectionalVadtLabel('D1', window.selectedTiaData.avgD1Label || 'Direction 1', 'Calculated ');
    if (calcD2LabelEl) calcD2LabelEl.textContent = formatDirectionalVadtLabel('D2', window.selectedTiaData.avgD2Label || 'Direction 2', 'Calculated ');
    if (areaTypeEl) areaTypeEl.textContent = String(window.selectedTiaData.areaType || 'Mixed Urban Street');
    if (typePercentEl) typePercentEl.textContent = `${areaTypeFactorPercent}%`;

    document.getElementById('quickTiaCalcAvgVADT').textContent = finalAvgVADT.toLocaleString();
    document.getElementById('quickTiaCalcAdjVADT').textContent = finalAvgVADT.toLocaleString();
    document.getElementById('quickTiaCalcD1').textContent = finalAvgD1.toLocaleString();
    document.getElementById('quickTiaCalcD2').textContent = finalAvgD2.toLocaleString();
  }

  function useExactTIAData() {
    if (!window.selectedTiaData || !window.selectedTiaData.siteId) return;

    customDirectionContext = null;
    if (macroSitesData[window.selectedTiaData.siteId]) {
      selectMacroSite(window.selectedTiaData.siteId);
      document.querySelector('.card:nth-of-type(2)').scrollIntoView({ behavior: 'smooth' });
      return;
    }
    selectedMacroSite = null;
    
    // Auto-fill the main form
    document.getElementById('macroSiteSearch').value = window.selectedTiaData.siteId;
    document.getElementById('D1_VADT').value = window.selectedTiaData.d1_vadt;
    document.getElementById('D2_VADT').value = window.selectedTiaData.d2_vadt;
    document.getElementById('VADT').value = window.selectedTiaData.vadt;
    applyManualEntryVisuals();
    setDirectionalInputLabels(window.selectedTiaData.d1_direction_label, window.selectedTiaData.d2_direction_label, ' (from custom address)');
    showCustomAddressDetails({
      siteId: window.selectedTiaData.siteId,
      roadName: window.selectedTiaData.road,
      description: 'Direct road match from quick address search',
      countYear: window.selectedTiaData.countYear || 'N/A',
      d1Label: window.selectedTiaData.d1_direction_label,
      d2Label: window.selectedTiaData.d2_direction_label,
      d1: window.selectedTiaData.d1_vadt,
      d2: window.selectedTiaData.d2_vadt,
      total: window.selectedTiaData.vadt,
      lat: window.selectedTiaData.lat,
      lon: window.selectedTiaData.lon
    });
    const baseYearInput = document.getElementById('baseYear');
    if (baseYearInput) {
      const year = Number(window.selectedTiaData.countYear);
      baseYearInput.value = Number.isFinite(year) ? year : '';
    }

    renderCustomAddressCharts(window.selectedTiaData);
    
    // Scroll to form
    document.querySelector('.card:nth-of-type(2)').scrollIntoView({ behavior: 'smooth' });
    populateDetourDropdown(); // trigger updated detour options
  }

  function useCalculatedTIAData() {
    if (!window.selectedTiaData || window.selectedTiaData.type !== 'references') return;
    selectedMacroSite = null;

    const adjVADT = Math.round(window.selectedTiaData.avgVADT || 0);
    let adjD1 = Math.round(window.selectedTiaData.avgD1 || 0);
    let adjD2 = Math.round(window.selectedTiaData.avgD2 || 0);

    const dirSum = adjD1 + adjD2;
    if (adjVADT > 0 && dirSum !== adjVADT) {
      const d1Ratio = dirSum > 0 ? (adjD1 / dirSum) : 0.5;
      adjD1 = Math.round(adjVADT * d1Ratio);
      adjD2 = Math.max(0, adjVADT - adjD1);
    }

    // Auto-fill the main form
    document.getElementById('D1_VADT').value = adjD1;
    document.getElementById('D2_VADT').value = adjD2;
    document.getElementById('VADT').value = adjVADT;
    document.getElementById('macroSiteSearch').value = 'Custom Address (weighted references)';
    const siteIdInput = document.getElementById('macroSiteId');
    if (siteIdInput) siteIdInput.value = 'CUSTOM';
    const dtcaInput = document.getElementById('DTCA');
    if (dtcaInput) dtcaInput.value = 'Yes';
    applyManualEntryVisuals();

    const customD1Label = String(window.selectedTiaData.avgD1Label || 'Direction 1').trim();
    const customD2Label = String(window.selectedTiaData.avgD2Label || 'Direction 2').trim();
    customDirectionContext = {
      d1Label: customD1Label,
      d2Label: customD2Label
    };
    setDirectionalInputLabels(customD1Label, customD2Label, ' (from custom address)');

    const quickSearchAddressEl = document.getElementById('quickTiaSearchAddress');
    showCustomAddressDetails({
      siteId: 'CUSTOM ADDRESS',
      roadName: window.selectedTiaData.road || (quickSearchAddressEl ? quickSearchAddressEl.textContent : 'Custom Address'),
      description: 'Calculated from nearby references (within 5km)',
      countYear: 'Averaged from references',
      d1Label: customD1Label,
      d2Label: customD2Label,
      d1: adjD1,
      d2: adjD2,
      total: adjVADT,
      lat: window.selectedTiaData.lat,
      lon: window.selectedTiaData.lon
    });

    const baseYearInput = document.getElementById('baseYear');
    if (baseYearInput) {
      const years = (window.selectedTiaData.references || [])
        .map(ref => Number(ref.countYear))
        .filter(y => Number.isFinite(y) && y > 0);
      if (years.length) {
        const avgYear = Math.round(years.reduce((sum, y) => sum + y, 0) / years.length);
        baseYearInput.value = avgYear;
      } else {
        baseYearInput.value = '';
      }
    }

    renderCustomAddressCharts({
      ...window.selectedTiaData,
      d1_vadt: adjD1,
      d2_vadt: adjD2,
      d1_direction_label: customD1Label,
      d2_direction_label: customD2Label
    });
    
    // Scroll to form
    const allCards = document.querySelectorAll('.card');
    allCards[1].scrollIntoView({ behavior: 'smooth' });
    populateDetourDropdown(); // refresh detour list after using calculated data
  }

  // Quick-search handlers are attached in DOMContentLoaded block.
</script>
</body>
</html>